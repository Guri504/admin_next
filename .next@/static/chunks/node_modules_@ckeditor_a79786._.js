(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@ckeditor_a79786._.js", {

"[project]/node_modules/@ckeditor/ckeditor5-integrations-common/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "CKBOX_CDN_URL": (()=>CKBOX_CDN_URL),
    "CK_CDN_URL": (()=>CK_CDN_URL),
    "INJECTED_SCRIPTS": (()=>INJECTED_SCRIPTS),
    "INJECTED_STYLESHEETS": (()=>INJECTED_STYLESHEETS),
    "appendExtraPluginsToEditorConfig": (()=>appendExtraPluginsToEditorConfig),
    "createCKBoxCdnUrl": (()=>createCKBoxCdnUrl),
    "createCKCdnUrl": (()=>createCKCdnUrl),
    "createDefer": (()=>createDefer),
    "createIntegrationUsageDataPlugin": (()=>createIntegrationUsageDataPlugin),
    "filterBlankObjectValues": (()=>filterBlankObjectValues),
    "filterObjectValues": (()=>filterObjectValues),
    "injectScript": (()=>injectScript),
    "injectScriptsInParallel": (()=>injectScriptsInParallel),
    "injectStylesheet": (()=>injectStylesheet),
    "isCKEditorFreeLicense": (()=>isCKEditorFreeLicense),
    "isSSR": (()=>isSSR),
    "loadCKEditorCloud": (()=>loadCKEditorCloud),
    "mapObjectValues": (()=>mapObjectValues),
    "once": (()=>once),
    "overwriteArray": (()=>overwriteArray),
    "overwriteObject": (()=>overwriteObject),
    "preloadResource": (()=>preloadResource),
    "shallowCompareArrays": (()=>shallowCompareArrays),
    "uid": (()=>uid),
    "uniq": (()=>uniq),
    "waitFor": (()=>waitFor),
    "waitForWindowEntry": (()=>waitForWindowEntry),
    "without": (()=>without)
});
function createDefer() {
    const deferred = {
        resolve: null,
        promise: null
    };
    deferred.promise = new Promise((resolve)=>{
        deferred.resolve = resolve;
    });
    return deferred;
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function waitFor(callback, { timeOutAfter = 500, retryAfter = 100 } = {}) {
    return new Promise((resolve, reject)=>{
        const startTime = Date.now();
        let lastError = null;
        const timeoutTimerId = setTimeout(()=>{
            reject(lastError ?? new Error("Timeout"));
        }, timeOutAfter);
        const tick = async ()=>{
            try {
                const result = await callback();
                clearTimeout(timeoutTimerId);
                resolve(result);
            } catch (err) {
                lastError = err;
                if (Date.now() - startTime > timeOutAfter) {
                    reject(err);
                } else {
                    setTimeout(tick, retryAfter);
                }
            }
        };
        tick();
    });
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const INJECTED_SCRIPTS = /* @__PURE__ */ new Map();
function injectScript(src, { attributes } = {}) {
    if (INJECTED_SCRIPTS.has(src)) {
        return INJECTED_SCRIPTS.get(src);
    }
    const maybePrevScript = document.querySelector(`script[src="${src}"]`);
    if (maybePrevScript) {
        console.warn(`Script with "${src}" src is already present in DOM!`);
        maybePrevScript.remove();
    }
    const promise = new Promise((resolve, reject)=>{
        const script = document.createElement("script");
        script.onerror = reject;
        script.onload = ()=>{
            resolve();
        };
        for (const [key, value] of Object.entries(attributes || {})){
            script.setAttribute(key, value);
        }
        script.setAttribute("data-injected-by", "ckeditor-integration");
        script.type = "text/javascript";
        script.async = true;
        script.src = src;
        document.head.appendChild(script);
        const observer = new MutationObserver((mutations)=>{
            const removedNodes = mutations.flatMap((mutation)=>Array.from(mutation.removedNodes));
            if (removedNodes.includes(script)) {
                INJECTED_SCRIPTS.delete(src);
                observer.disconnect();
            }
        });
        observer.observe(document.head, {
            childList: true,
            subtree: true
        });
    });
    INJECTED_SCRIPTS.set(src, promise);
    return promise;
}
async function injectScriptsInParallel(sources, props) {
    await Promise.all(sources.map((src)=>injectScript(src, props)));
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const INJECTED_STYLESHEETS = /* @__PURE__ */ new Map();
function injectStylesheet({ href, placementInHead = "start", attributes = {} }) {
    if (INJECTED_STYLESHEETS.has(href)) {
        return INJECTED_STYLESHEETS.get(href);
    }
    const maybePrevStylesheet = document.querySelector(`link[href="${href}"][rel="stylesheet"]`);
    if (maybePrevStylesheet) {
        console.warn(`Stylesheet with "${href}" href is already present in DOM!`);
        maybePrevStylesheet.remove();
    }
    const appendLinkTagToHead = (link)=>{
        const previouslyInjectedLinks = Array.from(document.head.querySelectorAll('link[data-injected-by="ckeditor-integration"]'));
        switch(placementInHead){
            case "start":
                if (previouslyInjectedLinks.length) {
                    previouslyInjectedLinks.slice(-1)[0].after(link);
                } else {
                    document.head.insertBefore(link, document.head.firstChild);
                }
                break;
            case "end":
                document.head.appendChild(link);
                break;
        }
    };
    const promise = new Promise((resolve, reject)=>{
        const link = document.createElement("link");
        for (const [key, value] of Object.entries(attributes || {})){
            link.setAttribute(key, value);
        }
        link.setAttribute("data-injected-by", "ckeditor-integration");
        link.rel = "stylesheet";
        link.href = href;
        link.onerror = reject;
        link.onload = ()=>{
            resolve();
        };
        appendLinkTagToHead(link);
        const observer = new MutationObserver((mutations)=>{
            const removedNodes = mutations.flatMap((mutation)=>Array.from(mutation.removedNodes));
            if (removedNodes.includes(link)) {
                INJECTED_STYLESHEETS.delete(href);
                observer.disconnect();
            }
        });
        observer.observe(document.head, {
            childList: true,
            subtree: true
        });
    });
    INJECTED_STYLESHEETS.set(href, promise);
    return promise;
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function isSSR() {
    return typeof window === "undefined";
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function once(fn) {
    let lastResult = null;
    return (...args)=>{
        if (!lastResult) {
            lastResult = {
                current: fn(...args)
            };
        }
        return lastResult.current;
    };
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function overwriteArray(source, destination) {
    destination.length = 0;
    destination.push(...source);
    return destination;
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function overwriteObject(source, destination) {
    for (const prop of Object.getOwnPropertyNames(destination)){
        delete destination[prop];
    }
    for (const [key, value] of Object.entries(source)){
        if (value !== destination && key !== "prototype" && key !== "__proto__") {
            destination[key] = value;
        }
    }
    return destination;
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function preloadResource(url, { attributes } = {}) {
    if (document.head.querySelector(`link[href="${url}"][rel="preload"]`)) {
        return;
    }
    const link = document.createElement("link");
    for (const [key, value] of Object.entries(attributes || {})){
        link.setAttribute(key, value);
    }
    link.setAttribute("data-injected-by", "ckeditor-integration");
    link.rel = "preload";
    link.as = detectTypeOfResource(url);
    link.href = url;
    document.head.insertBefore(link, document.head.firstChild);
}
function detectTypeOfResource(url) {
    switch(true){
        case /\.css$/.test(url):
            return "style";
        case /\.js$/.test(url):
            return "script";
        default:
            return "fetch";
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function shallowCompareArrays(a, b) {
    if (a === b) {
        return true;
    }
    if (!a || !b) {
        return false;
    }
    for(let i = 0; i < a.length; ++i){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const HEX_NUMBERS = new Array(256).fill("").map((_, index)=>("0" + index.toString(16)).slice(-2));
function uid() {
    const [r1, r2, r3, r4] = crypto.getRandomValues(new Uint32Array(4));
    return "e" + HEX_NUMBERS[r1 >> 0 & 255] + HEX_NUMBERS[r1 >> 8 & 255] + HEX_NUMBERS[r1 >> 16 & 255] + HEX_NUMBERS[r1 >> 24 & 255] + HEX_NUMBERS[r2 >> 0 & 255] + HEX_NUMBERS[r2 >> 8 & 255] + HEX_NUMBERS[r2 >> 16 & 255] + HEX_NUMBERS[r2 >> 24 & 255] + HEX_NUMBERS[r3 >> 0 & 255] + HEX_NUMBERS[r3 >> 8 & 255] + HEX_NUMBERS[r3 >> 16 & 255] + HEX_NUMBERS[r3 >> 24 & 255] + HEX_NUMBERS[r4 >> 0 & 255] + HEX_NUMBERS[r4 >> 8 & 255] + HEX_NUMBERS[r4 >> 16 & 255] + HEX_NUMBERS[r4 >> 24 & 255];
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function uniq(source) {
    return Array.from(new Set(source));
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ async function waitForWindowEntry(entryNames, config) {
    const tryPickBundle = ()=>entryNames.map((name)=>window[name]).filter(Boolean)[0];
    return waitFor(()=>{
        const result = tryPickBundle();
        if (!result) {
            throw new Error(`Window entry "${entryNames.join(",")}" not found.`);
        }
        return result;
    }, config);
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function filterObjectValues(obj, filter) {
    const filteredEntries = Object.entries(obj).filter(([key, value])=>filter(value, key));
    return Object.fromEntries(filteredEntries);
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function filterBlankObjectValues(obj) {
    return filterObjectValues(obj, (value)=>value !== null && value !== void 0);
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function mapObjectValues(obj, mapper) {
    const mappedEntries = Object.entries(obj).map(([key, value])=>[
            key,
            mapper(value, key)
        ]);
    return Object.fromEntries(mappedEntries);
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function without(itemsToRemove, items) {
    return items.filter((item)=>!itemsToRemove.includes(item));
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function appendExtraPluginsToEditorConfig(config, plugins) {
    const extraPlugins = config.extraPlugins || [];
    return {
        ...config,
        extraPlugins: [
            ...extraPlugins,
            ...plugins.filter((item)=>!extraPlugins.includes(item))
        ]
    };
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function isSemanticVersion(version) {
    return !!version && /^\d+\.\d+\.\d+/.test(version);
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function isCKCdnTestingVersion(version) {
    if (!version) {
        return false;
    }
    return [
        "nightly",
        "alpha",
        "internal",
        "nightly-",
        "staging"
    ].some((testVersion)=>version.includes(testVersion));
}
function isCKCdnVersion(version) {
    return isSemanticVersion(version) || isCKCdnTestingVersion(version);
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function destructureSemanticVersion(version) {
    if (!isSemanticVersion(version)) {
        throw new Error(`Invalid semantic version: ${version || "<blank>"}.`);
    }
    const [major, minor, patch] = version.split(".");
    return {
        major: Number.parseInt(major, 10),
        minor: Number.parseInt(minor, 10),
        patch: Number.parseInt(patch, 10)
    };
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function getLicenseVersionFromEditorVersion(version) {
    if (isCKCdnTestingVersion(version)) {
        return 3;
    }
    const { major } = destructureSemanticVersion(version);
    switch(true){
        case major >= 44:
            return 3;
        case major >= 38:
            return 2;
        default:
            return 1;
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function getCKBaseBundleInstallationInfo() {
    const { CKEDITOR_VERSION, CKEDITOR } = window;
    if (!isCKCdnVersion(CKEDITOR_VERSION)) {
        return null;
    }
    return {
        source: CKEDITOR ? "cdn" : "npm",
        version: CKEDITOR_VERSION
    };
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function getSupportedLicenseVersionInstallationInfo() {
    const installationInfo = getCKBaseBundleInstallationInfo();
    if (!installationInfo) {
        return null;
    }
    return getLicenseVersionFromEditorVersion(installationInfo.version);
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function isCKEditorFreeLicense(licenseKey, licenseVersion) {
    licenseVersion ||= getSupportedLicenseVersionInstallationInfo() || void 0;
    switch(licenseVersion){
        case 1:
        case 2:
            return licenseKey === void 0;
        case 3:
            return licenseKey === "GPL";
        default:
            {
                return false;
            }
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function createIntegrationUsageDataPlugin(integrationName, usageData) {
    return function IntegrationUsageDataPlugin(editor) {
        if (isCKEditorFreeLicense(editor.config.get("licenseKey"))) {
            return;
        }
        editor.on("collectUsageData", (source, { setUsageData })=>{
            setUsageData(`integration.${integrationName}`, usageData);
        });
    };
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const CK_CDN_URL = "https://cdn.ckeditor.com";
function createCKCdnUrl(bundle, file, version) {
    return `${CK_CDN_URL}/${bundle}/${version}/${file}`;
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const CKBOX_CDN_URL = "https://cdn.ckbox.io";
function createCKBoxCdnUrl(bundle, file, version) {
    return `${CKBOX_CDN_URL}/${bundle}/${version}/${file}`;
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const CK_DOCS_URL = "https://ckeditor.com/docs/ckeditor5";
function createCKDocsUrl(path, version = "latest") {
    return `${CK_DOCS_URL}/${version}/${path}`;
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function createCKCdnBaseBundlePack({ version, translations, createCustomCdnUrl = createCKCdnUrl }) {
    const urls = {
        scripts: [
            // Load the main script of the base features.
            createCustomCdnUrl("ckeditor5", "ckeditor5.umd.js", version),
            // Load all JavaScript files from the base features.
            // EN bundle is prebuilt into the main script, so we don't need to load it separately.
            ...without([
                "en"
            ], translations || []).map((translation)=>createCustomCdnUrl("ckeditor5", `translations/${translation}.umd.js`, version))
        ],
        stylesheets: [
            createCustomCdnUrl("ckeditor5", "ckeditor5.css", version)
        ]
    };
    return {
        // Preload resources specified in the pack, before loading the main script.
        preload: [
            ...urls.stylesheets,
            ...urls.scripts
        ],
        scripts: [
            // It's safe to load translations and the main script in parallel.
            async (attributes)=>injectScriptsInParallel(urls.scripts, attributes)
        ],
        // Load all stylesheets of the base features.
        stylesheets: urls.stylesheets,
        // Pick the exported global variables from the window object.
        checkPluginLoaded: async ()=>waitForWindowEntry([
                "CKEDITOR"
            ]),
        // Check if the CKEditor base bundle is already loaded and throw an error if it is.
        beforeInject: ()=>{
            const installationInfo = getCKBaseBundleInstallationInfo();
            switch(installationInfo?.source){
                case "npm":
                    throw new Error("CKEditor 5 is already loaded from npm. Check the migration guide for more details: " + createCKDocsUrl("updating/migration-to-cdn/vanilla-js.html"));
                case "cdn":
                    if (installationInfo.version !== version) {
                        throw new Error(`CKEditor 5 is already loaded from CDN in version ${installationInfo.version}. Remove the old <script> and <link> tags loading CKEditor 5 to allow loading the ${version} version.`);
                    }
                    break;
            }
        }
    };
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function createCKCdnPremiumBundlePack({ version, translations, createCustomCdnUrl = createCKCdnUrl }) {
    const urls = {
        scripts: [
            // Load the main script of the premium features.
            createCustomCdnUrl("ckeditor5-premium-features", "ckeditor5-premium-features.umd.js", version),
            // Load all JavaScript files from the premium features.
            // EN bundle is prebuilt into the main script, so we don't need to load it separately.
            ...without([
                "en"
            ], translations || []).map((translation)=>createCustomCdnUrl("ckeditor5-premium-features", `translations/${translation}.umd.js`, version))
        ],
        stylesheets: [
            createCustomCdnUrl("ckeditor5-premium-features", "ckeditor5-premium-features.css", version)
        ]
    };
    return {
        // Preload resources specified in the pack, before loading the main script.
        preload: [
            ...urls.stylesheets,
            ...urls.scripts
        ],
        scripts: [
            // It's safe to load translations and the main script in parallel.
            async (attributes)=>injectScriptsInParallel(urls.scripts, attributes)
        ],
        // Load all stylesheets of the premium features.
        stylesheets: urls.stylesheets,
        // Pick the exported global variables from the window object.
        checkPluginLoaded: async ()=>waitForWindowEntry([
                "CKEDITOR_PREMIUM_FEATURES"
            ])
    };
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ async function loadCKCdnResourcesPack(pack) {
    let { htmlAttributes = {}, scripts = [], stylesheets = [], preload, beforeInject, checkPluginLoaded } = normalizeCKCdnResourcesPack(pack);
    beforeInject?.();
    if (!preload) {
        preload = uniq([
            ...stylesheets.filter((item)=>typeof item === "string"),
            ...scripts.filter((item)=>typeof item === "string")
        ]);
    }
    for (const url of preload){
        preloadResource(url, {
            attributes: htmlAttributes
        });
    }
    await Promise.all(uniq(stylesheets).map((href)=>injectStylesheet({
            href,
            attributes: htmlAttributes,
            placementInHead: "start"
        })));
    for (const script of uniq(scripts)){
        const injectorProps = {
            attributes: htmlAttributes
        };
        if (typeof script === "string") {
            await injectScript(script, injectorProps);
        } else {
            await script(injectorProps);
        }
    }
    return checkPluginLoaded?.();
}
function normalizeCKCdnResourcesPack(pack) {
    if (Array.isArray(pack)) {
        return {
            scripts: pack.filter((item)=>typeof item === "function" || item.endsWith(".js")),
            stylesheets: pack.filter((item)=>item.endsWith(".css"))
        };
    }
    if (typeof pack === "function") {
        return {
            checkPluginLoaded: pack
        };
    }
    return pack;
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function combineCKCdnBundlesPacks(packs) {
    const normalizedPacks = mapObjectValues(filterBlankObjectValues(packs), normalizeCKCdnResourcesPack);
    const mergedPacks = Object.values(normalizedPacks).reduce((acc, pack)=>{
        acc.scripts.push(...pack.scripts ?? []);
        acc.stylesheets.push(...pack.stylesheets ?? []);
        acc.preload.push(...pack.preload ?? []);
        return acc;
    }, {
        preload: [],
        scripts: [],
        stylesheets: []
    });
    const checkPluginLoaded = async ()=>{
        const exportedGlobalVariables = /* @__PURE__ */ Object.create(null);
        for (const [name, pack] of Object.entries(normalizedPacks)){
            exportedGlobalVariables[name] = await pack?.checkPluginLoaded?.();
        }
        return exportedGlobalVariables;
    };
    const beforeInject = ()=>{
        for (const pack of Object.values(normalizedPacks)){
            pack.beforeInject?.();
        }
    };
    return {
        ...mergedPacks,
        beforeInject,
        checkPluginLoaded
    };
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function getCKBoxInstallationInfo() {
    const version = window.CKBox?.version;
    if (!isSemanticVersion(version)) {
        return null;
    }
    return {
        source: "cdn",
        version
    };
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function createCKBoxBundlePack({ version, theme = "lark", translations, createCustomCdnUrl = createCKBoxCdnUrl }) {
    return {
        // Load the main script of the base features.
        scripts: [
            createCustomCdnUrl("ckbox", "ckbox.js", version),
            // EN bundle is prebuilt into the main script, so we don't need to load it separately.
            ...without([
                "en"
            ], translations || []).map((translation)=>createCustomCdnUrl("ckbox", `translations/${translation}.js`, version))
        ],
        // Load optional theme, if provided. It's not required but recommended because it improves the look and feel.
        ...theme && {
            stylesheets: [
                createCustomCdnUrl("ckbox", `styles/themes/${theme}.css`, version)
            ]
        },
        // Pick the exported global variables from the window object.
        checkPluginLoaded: async ()=>waitForWindowEntry([
                "CKBox"
            ]),
        // Check if the CKBox bundle is already loaded and throw an error if it is.
        beforeInject: ()=>{
            const installationInfo = getCKBoxInstallationInfo();
            if (installationInfo && installationInfo.version !== version) {
                throw new Error(`CKBox is already loaded from CDN in version ${installationInfo.version}. Remove the old <script> and <link> tags loading CKBox to allow loading the ${version} version.`);
            }
        }
    };
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function isCKCdnSupportedByEditorVersion(version) {
    if (isCKCdnTestingVersion(version)) {
        return true;
    }
    const { major } = destructureSemanticVersion(version);
    const licenseVersion = getLicenseVersionFromEditorVersion(version);
    switch(licenseVersion){
        case 3:
            return true;
        default:
            return major === 43;
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function combineCdnPluginsPacks(pluginsPacks) {
    const normalizedPluginsPacks = mapObjectValues(pluginsPacks, (pluginPack, pluginName)=>{
        if (!pluginPack) {
            return void 0;
        }
        const normalizedPluginPack = normalizeCKCdnResourcesPack(pluginPack);
        return {
            // Provide default window accessor object if the plugin pack does not define it.
            checkPluginLoaded: async ()=>waitForWindowEntry([
                    pluginName
                ]),
            // Transform the plugin pack to a normalized advanced pack.
            ...normalizedPluginPack
        };
    });
    return combineCKCdnBundlesPacks(normalizedPluginsPacks);
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function loadCKEditorCloud(config) {
    const { version, translations, plugins, premium, ckbox, createCustomCdnUrl, injectedHtmlElementsAttributes = {
        crossorigin: "anonymous"
    } } = config;
    validateCKEditorVersion(version);
    const pack = combineCKCdnBundlesPacks({
        CKEditor: createCKCdnBaseBundlePack({
            version,
            translations,
            createCustomCdnUrl
        }),
        ...premium && {
            CKEditorPremiumFeatures: createCKCdnPremiumBundlePack({
                version,
                translations,
                createCustomCdnUrl
            })
        },
        ...ckbox && {
            CKBox: createCKBoxBundlePack(ckbox)
        },
        loadedPlugins: combineCdnPluginsPacks(plugins ?? {})
    });
    return loadCKCdnResourcesPack({
        ...pack,
        htmlAttributes: injectedHtmlElementsAttributes
    });
}
function validateCKEditorVersion(version) {
    if (isCKCdnTestingVersion(version)) {
        console.warn("You are using a testing version of CKEditor 5. Please remember that it is not suitable for production environments.");
    }
    if (!isCKCdnSupportedByEditorVersion(version)) {
        throw new Error(`The CKEditor 5 CDN can't be used with the given editor version: ${version}. Please make sure you are using at least the CKEditor 5 version 44.`);
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-react/dist/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CKEditor": (()=>CKEditor),
    "CKEditorContext": (()=>CKEditorContext),
    "useCKEditorCloud": (()=>useCKEditorCloud),
    "useMultiRootEditor": (()=>useMultiRootEditor),
    "withCKEditorCloud": (()=>withCKEditorCloud)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-integrations-common/dist/index.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
;
;
;
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const _LifeCycleElementSemaphore = class _LifeCycleElementSemaphore {
    constructor(element, lifecycle){
        /**
     * This should define async methods for initializing and destroying the editor.
     * Essentially, it's an async version of basic React lifecycle methods like `componentDidMount`, `componentWillUnmount`.
     *
     * 	* Result of {@link LifeCycleAsyncOperators#mount} method is passed to {@link LifeCycleAsyncOperators#unmount} as an argument.
     */ __publicField(this, "_lifecycle");
        /**
     * This is the element instance that the editor uses for mounting. This element should contain the `ckeditorInstance` member
     * once the editor has been successfully mounted to it. The semaphore ensures that a new instance of the editor, which will
     * be assigned to this element by the {@link #_lifecycle:mount} method, will always be initialized after the successful
     * destruction of the underlying `ckeditorInstance` that was previously mounted on this element.
     */ __publicField(this, "_element");
        /**
     * This is the lock mechanism utilized by the {@link #lock} and {@link #release} methods.
     *
     * 	* If the editor is not yet mounted and is awaiting mounting (for instance, when another editor is
     * 	  occupying the element), then it is null.
     *
     * 	* When the editor is mounted on the element, this variable holds an unresolved promise that will be
     * 	  resolved after the editor is destroyed.
     *
     * 	* Once the editor is destroyed (and it was previously mounted), the promise is resolved.
     */ __publicField(this, "_releaseLock", null);
        /**
     * This is the result of the {@link #_lifecycle:mount} function. This value should be reset to `null`
     * once the semaphore is released. It is utilized to store certain data that must be removed following
     * the destruction of the editor. This data may include the editor's instance, the assigned watchdog,
     * or handles for additional window listeners.
     */ __publicField(this, "_value", null);
        /**
     * This is a list of callbacks that are triggered if the semaphore {@link #_lifecycle:mount} method executes successfully.
     * It is utilized in scenarios where we need to assign certain properties to an editor that is currently in the process of mounting.
     * An instance of such usage could be two-way binding. We aim to prevent the loss of all `setData` calls if the editor has not
     * yet been mounted, therefore these calls will be executed immediately following the completion of the mounting process.
     */ __publicField(this, "_afterMountCallbacks", []);
        /**
     * This represents the actual mounting state of the semaphore. It is primarily used by the {@link #release} method to
     * determine whether the initialization of the editor should be skipped or, if the editor is already initialized, the editor
     * should be destroyed.
     *
     * 	* If `destroyedBeforeInitialization` is true, then the {@link #release} method was invoked before the editor began to mount.
     * 	  This often occurs in strict mode when we assign a promise to the {@link LifeCycleEditorElementSemaphore#_semaphores} map
     * 	  and the assigned `mount` callback has not yet been called. In this scenario, it is safe to skip the initialization of the editor
     * 	  and simply release the semaphore.
     *
     *	* If `mountingInProgress` is a Promise, then the {@link #release} method was invoked after the initialization of the editor and
     	  the editor must be destroyed before the semaphore is released.
    */ __publicField(this, "_state", {
            destroyedBeforeInitialization: false,
            mountingInProgress: null
        });
        /**
     * Inverse of {@link #_lock} method that tries to destroy attached editor.
     *
     * 	* If editor is being already attached to element (or is in attaching process) then after fully initialization of editor
     * 	  destroy is performed and semaphore is released. The {@link #_lifecycle} unmount method is called.
     *
     * 	* If editor is being destroyed before initialization then it does nothing but sets `destroyedBeforeInitialization` flag that
     * 	  will be later checked by {@link #_lock} method in initialization. The {@link #_lifecycle} unmount method is not called.
     *
     * *Important note:*
     *
     * It’s really important to keep this method *sync*. If we make this method *async*, it won’t work well because
     * it will cause problems when we’re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.
     */ __publicField(this, "release", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["once"])(()=>{
            const { _releaseLock, _state, _element, _lifecycle } = this;
            if (_state.mountingInProgress) {
                _state.mountingInProgress.then(()=>_lifecycle.unmount({
                        element: _element,
                        // Mount result might be overridden by watchdog during restart so use instance variable.
                        mountResult: this.value
                    })).catch((error)=>{
                    console.error("Semaphore unmounting error:", error);
                }).then(_releaseLock.resolve).then(()=>{
                    this._value = null;
                });
            } else {
                _state.destroyedBeforeInitialization = true;
                _releaseLock.resolve();
            }
        }));
        this._element = element;
        this._lifecycle = lifecycle;
        this._lock();
    }
    /**
   * Getter for {@link #_value}.
   */ get value() {
        return this._value;
    }
    /**
   * Occasionally, the Watchdog restarts the editor instance, resulting in a new instance being assigned to the semaphore.
   * In terms of race conditions, it's generally safer to simply override the semaphore value rather than recreating it
   * with a different one.
   */ unsafeSetValue(value) {
        this._value = value;
        this._afterMountCallbacks.forEach((callback)=>callback(value));
        this._afterMountCallbacks = [];
    }
    /**
   * This registers a callback that will be triggered after the editor has been successfully mounted.
   *
   * 	* If the editor is already mounted, the callback will be executed immediately.
   *	* If the editor is in the process of mounting, the callback will be executed upon successful mounting.
  * 	* If the editor is never mounted, the passed callback will not be executed.
  * 	* If an exception is thrown within the callback, it will be re-thrown in the semaphore.
  */ runAfterMount(callback) {
        const { _value, _afterMountCallbacks } = this;
        if (_value) {
            callback(_value);
        } else {
            _afterMountCallbacks.push(callback);
        }
    }
    /**
   * This method is used to inform other components that the {@link #_element} will be used by the editor,
   * which is initialized by the {@link #_lifecycle} methods.
   *
   * 	* If an editor is already present on the provided element, the initialization of the current one
   * 	  will be postponed until the previous one is destroyed.
   *
   * 	* If the element is empty and does not have an editor attached to it, the currently locked editor will
   * 	  be mounted immediately.
   *
   * After the successful initialization of the editor and the assignment of the {@link #_value} member,
   * the `onReady` lifecycle method is called.
   *
   * *Important note:*
   *
   * It’s really important to keep this method *sync*. If we make this method *async*, it won’t work well because
   * it will cause problems when we’re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.
   */ _lock() {
        const { _semaphores } = _LifeCycleElementSemaphore;
        const { _state, _element, _lifecycle } = this;
        const prevElementSemaphore = _semaphores.get(_element) || Promise.resolve(null);
        const releaseLock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDefer"])();
        this._releaseLock = releaseLock;
        const newElementSemaphore = prevElementSemaphore.then(()=>{
            if (_state.destroyedBeforeInitialization) {
                return Promise.resolve(void 0);
            }
            _state.mountingInProgress = _lifecycle.mount().then((mountResult)=>{
                if (mountResult) {
                    this.unsafeSetValue(mountResult);
                }
                return mountResult;
            });
            return _state.mountingInProgress;
        }).then(async (mountResult)=>{
            if (mountResult && _lifecycle.afterMount) {
                await _lifecycle.afterMount({
                    element: _element,
                    mountResult
                });
            }
        }).then(()=>releaseLock.promise).catch((error)=>{
            console.error("Semaphore mounting error:", error);
        }).then(()=>{
            if (_semaphores.get(_element) === newElementSemaphore) {
                _semaphores.delete(_element);
            }
        });
        _semaphores.set(_element, newElementSemaphore);
    }
};
/**
 * This is a map of elements associated with promises. It informs the semaphore that the underlying HTML element, used as a key,
 * is currently in use by another editor. Each element is assigned a promise, which allows for the easy chaining of new
 * editor instances on an element that is already in use by another instance. The process works as follows:
 *
 * 	1. If an element is being used by an editor, then the initialization of a new editor
 * 	   instance is chained using the `.then()` method of the Promise.
 *
 * 	2. If the editor associated with the underlying element is destroyed, then `Promise.resolve()` is called
 * 	   and the previously assigned `.then()` editor callback is executed.
 *
 *  @see {@link #lock} for more detailed information on the implementation.
 */ __publicField(_LifeCycleElementSemaphore, "_semaphores", /* @__PURE__ */ new Map());
let LifeCycleElementSemaphore = _LifeCycleElementSemaphore;
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const ReactContextMetadataKey = "$__CKEditorReactContextMetadata";
function withCKEditorReactContextMetadata(metadata, config) {
    return {
        ...config,
        [ReactContextMetadataKey]: metadata
    };
}
function tryExtractCKEditorReactContextMetadata(object) {
    return object.get(ReactContextMetadataKey);
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const useIsMountedRef = ()=>{
    const mountedRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(false);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useIsMountedRef.useEffect": ()=>{
            mountedRef.current = true;
            return ({
                "useIsMountedRef.useEffect": ()=>{
                    mountedRef.current = false;
                }
            })["useIsMountedRef.useEffect"];
        }
    }["useIsMountedRef.useEffect"], []);
    return mountedRef;
};
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const useRefSafeCallback = (fn)=>{
    const callbackRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
    callbackRef.current = fn;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRefSafeCallback.useCallback": (...args)=>callbackRef.current(...args)
    }["useRefSafeCallback.useCallback"], []);
};
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const useInitializedCKEditorsMap = ({ currentContextWatchdog, onChangeInitializedEditors })=>{
    const onChangeInitializedEditorsSafe = useRefSafeCallback(onChangeInitializedEditors || ({
        "useInitializedCKEditorsMap.useRefSafeCallback[onChangeInitializedEditorsSafe]": ()=>{}
    })["useInitializedCKEditorsMap.useRefSafeCallback[onChangeInitializedEditorsSafe]"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useInitializedCKEditorsMap.useEffect": ()=>{
            var _a;
            if (currentContextWatchdog.status !== "initialized") {
                return;
            }
            const { watchdog } = currentContextWatchdog;
            const editors = (_a = watchdog == null ? void 0 : watchdog.context) == null ? void 0 : _a.editors;
            if (!editors) {
                return;
            }
            const getInitializedContextEditors = {
                "useInitializedCKEditorsMap.useEffect.getInitializedContextEditors": ()=>[
                        ...editors
                    ].reduce({
                        "useInitializedCKEditorsMap.useEffect.getInitializedContextEditors": (map, editor)=>{
                            var _a2;
                            if (editor.state !== "ready") {
                                return map;
                            }
                            const metadata = tryExtractCKEditorReactContextMetadata(editor.config);
                            const nameOrId = (_a2 = metadata == null ? void 0 : metadata.name) != null ? _a2 : editor.id;
                            map[nameOrId] = {
                                instance: editor,
                                metadata
                            };
                            return map;
                        }
                    }["useInitializedCKEditorsMap.useEffect.getInitializedContextEditors"], /* @__PURE__ */ Object.create({}))
            }["useInitializedCKEditorsMap.useEffect.getInitializedContextEditors"];
            const onEditorStatusChange = {
                "useInitializedCKEditorsMap.useEffect.onEditorStatusChange": ()=>{
                    onChangeInitializedEditorsSafe(getInitializedContextEditors(), watchdog);
                }
            }["useInitializedCKEditorsMap.useEffect.onEditorStatusChange"];
            const trackEditorLifecycle = {
                "useInitializedCKEditorsMap.useEffect.trackEditorLifecycle": (editor)=>{
                    editor.once("ready", onEditorStatusChange, {
                        priority: "lowest"
                    });
                    editor.once("destroy", onEditorStatusChange, {
                        priority: "lowest"
                    });
                }
            }["useInitializedCKEditorsMap.useEffect.trackEditorLifecycle"];
            const onAddEditorToCollection = {
                "useInitializedCKEditorsMap.useEffect.onAddEditorToCollection": (_, editor)=>{
                    trackEditorLifecycle(editor);
                }
            }["useInitializedCKEditorsMap.useEffect.onAddEditorToCollection"];
            editors.forEach(trackEditorLifecycle);
            editors.on("add", onAddEditorToCollection);
            if (Array.from(editors).some({
                "useInitializedCKEditorsMap.useEffect": (editor)=>editor.state === "ready"
            }["useInitializedCKEditorsMap.useEffect"])) {
                onEditorStatusChange();
            }
            return ({
                "useInitializedCKEditorsMap.useEffect": ()=>{
                    editors.off("add", onAddEditorToCollection);
                }
            })["useInitializedCKEditorsMap.useEffect"];
        }
    }["useInitializedCKEditorsMap.useEffect"], [
        currentContextWatchdog
    ]);
};
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const ContextWatchdogContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createContext(null);
const CKEditorContext = (props)=>{
    const { id, context, watchdogConfig, children, config, onReady, contextWatchdog: ContextWatchdogConstructor, isLayoutReady = true, onChangeInitializedEditors, onError = (error, details)=>console.error(error, details) } = props;
    const isMountedRef = useIsMountedRef();
    const prevWatchdogInitializationIDRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const [currentContextWatchdog, setCurrentContextWatchdog] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        status: "initializing"
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "CKEditorContext.useEffect": ()=>{
            if (isLayoutReady) {
                initializeContextWatchdog();
            } else {
                setCurrentContextWatchdog({
                    status: "initializing"
                });
            }
        }
    }["CKEditorContext.useEffect"], [
        id,
        isLayoutReady
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "CKEditorContext.useEffect": ()=>({
                "CKEditorContext.useEffect": ()=>{
                    if (currentContextWatchdog.status === "initialized") {
                        currentContextWatchdog.watchdog.destroy();
                    }
                }
            })["CKEditorContext.useEffect"]
    }["CKEditorContext.useEffect"], [
        currentContextWatchdog
    ]);
    useInitializedCKEditorsMap({
        currentContextWatchdog,
        onChangeInitializedEditors
    });
    function regenerateInitializationID() {
        prevWatchdogInitializationIDRef.current = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])();
        return prevWatchdogInitializationIDRef.current;
    }
    function canUpdateState(initializationID) {
        return prevWatchdogInitializationIDRef.current === initializationID && isMountedRef.current;
    }
    function initializeContextWatchdog() {
        const watchdogInitializationID = regenerateInitializationID();
        const contextWatchdog = new ContextWatchdogConstructor(context, watchdogConfig);
        contextWatchdog.on("error", (_, errorEvent)=>{
            /* istanbul ignore else -- @preserve */ if (canUpdateState(watchdogInitializationID)) {
                onError(errorEvent.error, {
                    phase: "runtime",
                    willContextRestart: errorEvent.causesRestart
                });
            }
        });
        contextWatchdog.on("stateChange", ()=>{
            if (onReady && contextWatchdog.state === "ready" && canUpdateState(watchdogInitializationID)) {
                onReady(contextWatchdog.context, contextWatchdog);
            }
        });
        contextWatchdog.create(config).then(()=>{
            if (canUpdateState(watchdogInitializationID)) {
                setCurrentContextWatchdog({
                    status: "initialized",
                    watchdog: contextWatchdog
                });
            } else {
                contextWatchdog.destroy();
            }
        }).catch((error)=>{
            if (canUpdateState(watchdogInitializationID)) {
                onError(error, {
                    phase: "initialization",
                    willContextRestart: false
                });
                setCurrentContextWatchdog({
                    status: "error",
                    error
                });
            }
        });
        return contextWatchdog;
    }
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(ContextWatchdogContext.Provider, {
        value: currentContextWatchdog
    }, children);
};
const isContextWatchdogValue = (obj)=>!!obj && typeof obj === "object" && "status" in obj && [
        "initializing",
        "initialized",
        "error"
    ].includes(obj.status);
const isContextWatchdogValueWithStatus = (status)=>(obj)=>isContextWatchdogValue(obj) && obj.status === status;
const isContextWatchdogInitializing = isContextWatchdogValueWithStatus("initializing");
const isContextWatchdogReadyToUse = (obj)=>isContextWatchdogValueWithStatus("initialized")(obj) && obj.watchdog.state === "ready";
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const ReactIntegrationUsageDataPlugin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createIntegrationUsageDataPlugin"])("react", {
    version: "9.5.0",
    frameworkVersion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version
});
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function appendAllIntegrationPluginsToConfig(editorConfig) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isCKEditorFreeLicense"])(editorConfig.licenseKey)) {
        return editorConfig;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["appendExtraPluginsToEditorConfig"])(editorConfig, [
        /**
     * This part of the code is not executed in open-source implementations using a GPL key.
     * It only runs when a specific license key is provided. If you are uncertain whether
     * this applies to your installation, please contact our support team.
     */ ReactIntegrationUsageDataPlugin
    ]);
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const REACT_INTEGRATION_READ_ONLY_LOCK_ID$1 = "Lock from React integration (@ckeditor/ckeditor5-react)";
class CKEditor extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Component {
    constructor(props){
        super(props);
        /**
     * After mounting the editor, the variable will contain a reference to the created editor.
     * @see: https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html
     */ __publicField(this, "domContainer", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createRef());
        /**
     * Unlocks element in editor semaphore after destroy editor instance.
     */ __publicField(this, "editorSemaphore", null);
        this._checkVersion();
    }
    /**
   * Checks if the CKEditor version used in the application is compatible with the component.
   */ _checkVersion() {
        const { CKEDITOR_VERSION } = window;
        if (!CKEDITOR_VERSION) {
            return console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');
        }
        const [major] = CKEDITOR_VERSION.split(".").map(Number);
        if (major >= 42 || CKEDITOR_VERSION.startsWith("0.0.0")) {
            return;
        }
        console.warn("The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.");
    }
    get _semaphoreValue() {
        const { editorSemaphore } = this;
        return editorSemaphore ? editorSemaphore.value : null;
    }
    /**
   * An watchdog instance.
   */ get watchdog() {
        const { _semaphoreValue } = this;
        return _semaphoreValue ? _semaphoreValue.watchdog : null;
    }
    /**
   * An editor instance.
   */ get editor() {
        const { _semaphoreValue } = this;
        return _semaphoreValue ? _semaphoreValue.instance : null;
    }
    /**
   * The CKEditor component should not be updated by React itself.
   * However, if the component identifier changes, the whole structure should be created once again.
   */ shouldComponentUpdate(nextProps) {
        const { props, editorSemaphore } = this;
        if (nextProps.id !== props.id) {
            return true;
        }
        if (nextProps.disableWatchdog !== props.disableWatchdog) {
            return true;
        }
        if (editorSemaphore) {
            editorSemaphore.runAfterMount(({ instance })=>{
                if (this._shouldUpdateEditorData(props, nextProps, instance)) {
                    instance.data.set(nextProps.data);
                }
            });
            if ("disabled" in nextProps) {
                editorSemaphore.runAfterMount(({ instance })=>{
                    if (nextProps.disabled) {
                        instance.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID$1);
                    } else {
                        instance.disableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID$1);
                    }
                });
            }
        }
        return false;
    }
    /**
   * Initialize the editor when the component is mounted.
   */ componentDidMount() {
        if (!isContextWatchdogInitializing(this.context)) {
            this._initLifeCycleSemaphore();
        }
    }
    /**
   * Re-render the entire component once again. The old editor will be destroyed and the new one will be created.
   */ componentDidUpdate() {
        if (!isContextWatchdogInitializing(this.context)) {
            this._initLifeCycleSemaphore();
        }
    }
    /**
   * Destroy the editor before unmounting the component.
   */ componentWillUnmount() {
        this._unlockLifeCycleSemaphore();
    }
    /**
   * Async destroy attached editor and unlock element semaphore.
   */ _unlockLifeCycleSemaphore() {
        if (this.editorSemaphore) {
            this.editorSemaphore.release();
            this.editorSemaphore = null;
        }
    }
    /**
   * Unlocks previous editor semaphore and creates new one..
   */ _initLifeCycleSemaphore() {
        this._unlockLifeCycleSemaphore();
        this.editorSemaphore = new LifeCycleElementSemaphore(this.domContainer.current, {
            mount: async ()=>this._initializeEditor(),
            afterMount: ({ mountResult })=>{
                const { onReady } = this.props;
                if (onReady && this.domContainer.current !== null) {
                    onReady(mountResult.instance);
                }
            },
            unmount: async ({ element, mountResult })=>{
                const { onAfterDestroy } = this.props;
                try {
                    await this._destroyEditor(mountResult);
                    element.innerHTML = "";
                } finally{
                    if (onAfterDestroy) {
                        onAfterDestroy(mountResult.instance);
                    }
                }
            }
        });
    }
    /**
   * Render a <div> element which will be replaced by CKEditor.
   */ render() {
        return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
            ref: this.domContainer
        });
    }
    /**
   * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.
   */ async _initializeEditor() {
        if (this.props.disableWatchdog) {
            const instance = await this._createEditor(this.domContainer.current, this._getConfig());
            return {
                instance,
                watchdog: null
            };
        }
        const watchdog = (()=>{
            if (isContextWatchdogReadyToUse(this.context)) {
                return new EditorWatchdogAdapter(this.context.watchdog);
            }
            return new this.props.editor.EditorWatchdog(this.props.editor, this.props.watchdogConfig);
        })();
        const totalRestartsRef = {
            current: 0
        };
        watchdog.setCreator(async (el, config)=>{
            var _a;
            const { editorSemaphore } = this;
            const { onAfterDestroy } = this.props;
            if (totalRestartsRef.current > 0 && onAfterDestroy && ((_a = editorSemaphore == null ? void 0 : editorSemaphore.value) == null ? void 0 : _a.instance)) {
                onAfterDestroy(editorSemaphore.value.instance);
            }
            const instance = await this._createEditor(el, config);
            if (editorSemaphore && totalRestartsRef.current > 0) {
                editorSemaphore.unsafeSetValue({
                    instance,
                    watchdog
                });
                setTimeout(()=>{
                    if (this.props.onReady) {
                        this.props.onReady(watchdog.editor);
                    }
                });
            }
            totalRestartsRef.current++;
            return instance;
        });
        watchdog.on("error", (_, { error, causesRestart })=>{
            const onError = this.props.onError || console.error;
            onError(error, {
                phase: "runtime",
                willEditorRestart: causesRestart
            });
        });
        await watchdog.create(this.domContainer.current, this._getConfig()).catch((error)=>{
            const onError = this.props.onError || console.error;
            onError(error, {
                phase: "initialization",
                willEditorRestart: false
            });
        });
        return {
            watchdog,
            instance: watchdog.editor
        };
    }
    /**
   * Creates an editor from the element and configuration.
   *
   * @param element The source element.
   * @param config CKEditor 5 editor configuration.
   */ _createEditor(element, config) {
        const { contextItemMetadata } = this.props;
        if (contextItemMetadata) {
            config = withCKEditorReactContextMetadata(contextItemMetadata, config);
        }
        return this.props.editor.create(element, appendAllIntegrationPluginsToConfig(config)).then((editor)=>{
            if ("disabled" in this.props) {
                /* istanbul ignore else -- @preserve */ if (this.props.disabled) {
                    editor.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID$1);
                }
            }
            const modelDocument = editor.model.document;
            const viewDocument = editor.editing.view.document;
            modelDocument.on("change:data", (event)=>{
                /* istanbul ignore else -- @preserve */ if (this.props.onChange) {
                    this.props.onChange(event, editor);
                }
            });
            viewDocument.on("focus", (event)=>{
                /* istanbul ignore else -- @preserve */ if (this.props.onFocus) {
                    this.props.onFocus(event, editor);
                }
            });
            viewDocument.on("blur", (event)=>{
                /* istanbul ignore else -- @preserve */ if (this.props.onBlur) {
                    this.props.onBlur(event, editor);
                }
            });
            return editor;
        });
    }
    /**
   * Destroys the editor by destroying the watchdog.
   */ async _destroyEditor(initializeResult) {
        const { watchdog, instance } = initializeResult;
        return new Promise((resolve, reject)=>{
            /* istanbul ignore next -- @preserve */ setTimeout(async ()=>{
                try {
                    if (watchdog) {
                        await watchdog.destroy();
                        return resolve();
                    }
                    if (instance) {
                        await instance.destroy();
                        return resolve();
                    }
                    resolve();
                } catch (e) {
                    console.error(e);
                    reject(e);
                }
            });
        });
    }
    /**
   * Returns true when the editor should be updated.
   *
   * @param prevProps Previous react's properties.
   * @param nextProps React's properties.
   * @param editor Current editor instance.
   */ _shouldUpdateEditorData(prevProps, nextProps, editor) {
        if (prevProps.data === nextProps.data) {
            return false;
        }
        if (editor.data.get() === nextProps.data) {
            return false;
        }
        return true;
    }
    /**
   * Returns the editor configuration.
   */ _getConfig() {
        const config = this.props.config || {};
        if (this.props.data && config.initialData) {
            console.warn("Editor data should be provided either using `config.initialData` or `content` property. The config value takes precedence over `content` property and will be used when both are specified.");
        }
        return {
            ...config,
            initialData: config.initialData || this.props.data || ""
        };
    }
}
__publicField(CKEditor, "contextType", ContextWatchdogContext);
class EditorWatchdogAdapter {
    /**
   * @param contextWatchdog The context watchdog instance that will be wrapped into editor watchdog API.
   */ constructor(contextWatchdog){
        /**
     * The context watchdog instance that will be wrapped into editor watchdog API.
     */ __publicField(this, "_contextWatchdog");
        /**
     * A unique id for the adapter to distinguish editor items when using the context watchdog API.
     */ __publicField(this, "_id");
        /**
     * A watchdog's editor creator function.
     */ __publicField(this, "_creator");
        this._contextWatchdog = contextWatchdog;
        this._id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])();
    }
    /**
   *  @param creator A watchdog's editor creator function.
   */ setCreator(creator) {
        this._creator = creator;
    }
    /**
   * Adds an editor configuration to the context watchdog registry. Creates an instance of it.
   *
   * @param sourceElementOrData A source element or data for the new editor.
   * @param config CKEditor 5 editor config.
   */ create(sourceElementOrData, config) {
        return this._contextWatchdog.add({
            sourceElementOrData,
            config,
            creator: this._creator,
            id: this._id,
            type: "editor"
        });
    }
    /**
   * Creates a listener that is attached to context watchdog's item and run when the context watchdog fires.
   * Currently works only for the `error` event.
   */ on(_, callback) {
        this._contextWatchdog.on("itemError", (_2, { itemId, error })=>{
            if (itemId === this._id) {
                callback(null, {
                    error,
                    causesRestart: void 0
                });
            }
        });
    }
    destroy() {
        if (this._contextWatchdog.state === "ready") {
            return this._contextWatchdog.remove(this._id);
        }
        return Promise.resolve();
    }
    /**
   * An editor instance.
   */ get editor() {
        return this._contextWatchdog.getItem(this._id);
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const useLifeCycleSemaphoreSyncRef = ()=>{
    const semaphoreRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const [revision, setRevision] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "useLifeCycleSemaphoreSyncRef.useState": ()=>Date.now()
    }["useLifeCycleSemaphoreSyncRef.useState"]);
    const refresh = ()=>{
        setRevision(Date.now());
    };
    const release = (rerender = true)=>{
        if (semaphoreRef.current) {
            semaphoreRef.current.release();
            semaphoreRef.current = null;
        }
        if (rerender) {
            setRevision(Date.now());
        }
    };
    const unsafeSetValue = (value)=>{
        var _a;
        (_a = semaphoreRef.current) == null ? void 0 : _a.unsafeSetValue(value);
        refresh();
    };
    const runAfterMount = (callback)=>{
        if (semaphoreRef.current) {
            semaphoreRef.current.runAfterMount(callback);
        }
    };
    const replace = (newSemaphore)=>{
        release(false);
        semaphoreRef.current = newSemaphore();
        refresh();
        runAfterMount(refresh);
    };
    const createAttributeRef = (key)=>({
            get current () {
                if (!semaphoreRef.current || !semaphoreRef.current.value) {
                    return null;
                }
                return semaphoreRef.current.value[key];
            }
        });
    return {
        get current () {
            return semaphoreRef.current;
        },
        revision,
        createAttributeRef,
        unsafeSetValue,
        release,
        replace,
        runAfterMount
    };
};
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function mergeRefs(...refs) {
    return (value)=>{
        refs.forEach((ref)=>{
            if (typeof ref === "function") {
                ref(value);
            } else if (ref != null) {
                ref.current = value;
            }
        });
    };
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const useInstantEffect = (fn, deps)=>{
    const [prevDeps, setDeps] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallowCompareArrays"])(prevDeps, deps)) {
        fn();
        setDeps([
            ...deps
        ]);
    }
};
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const useInstantEditorEffect = (semaphore, fn, deps)=>{
    useInstantEffect({
        "useInstantEditorEffect.useInstantEffect": ()=>{
            if (semaphore) {
                semaphore.runAfterMount(fn);
            }
        }
    }["useInstantEditorEffect.useInstantEffect"], [
        semaphore,
        ...deps
    ]);
};
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const REACT_INTEGRATION_READ_ONLY_LOCK_ID = "Lock from React integration (@ckeditor/ckeditor5-react)";
const useMultiRootEditor = (props)=>{
    const semaphoreElementRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(props.semaphoreElement || null);
    const semaphore = useLifeCycleSemaphoreSyncRef();
    const editorRefs = {
        watchdog: semaphore.createAttributeRef("watchdog"),
        instance: semaphore.createAttributeRef("instance")
    };
    const context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(ContextWatchdogContext);
    const [roots, setRoots] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "useMultiRootEditor.useState": ()=>Object.keys(props.data)
    }["useMultiRootEditor.useState"]);
    const [data, setData] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        ...props.data
    });
    const [attributes, setAttributes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        ...props.rootsAttributes
    });
    const shouldUpdateEditor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(true);
    const forceAssignFakeEditableElements = ()=>{
        const editor = editorRefs.instance.current;
        if (!editor) {
            return;
        }
        const initializeEditableWithFakeElement = (editable)=>{
            if (editable.name && !editor.editing.view.getDomRoot(editable.name)) {
                editor.editing.view.attachDomRoot(document.createElement("div"), editable.name);
            }
        };
        Object.values(editor.ui.view.editables).forEach(initializeEditableWithFakeElement);
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useMultiRootEditor.useEffect": ()=>{
            const semaphoreElement = semaphoreElementRef.current;
            if (context && !isContextWatchdogReadyToUse(context)) {
                return;
            }
            if (!semaphoreElement || props.isLayoutReady === false) {
                return;
            }
            semaphore.replace({
                "useMultiRootEditor.useEffect": ()=>new LifeCycleElementSemaphore(semaphoreElement, {
                        mount: _initializeEditor,
                        afterMount: {
                            "useMultiRootEditor.useEffect": ({ mountResult })=>{
                                const { onReady } = props;
                                if (onReady && semaphoreElementRef.current !== null) {
                                    onReady(mountResult.instance);
                                }
                            }
                        }["useMultiRootEditor.useEffect"],
                        unmount: {
                            "useMultiRootEditor.useEffect": async ({ element, mountResult })=>{
                                const { onAfterDestroy } = props;
                                try {
                                    await _destroyEditor(mountResult);
                                    element.innerHTML = "";
                                } finally{
                                    if (onAfterDestroy) {
                                        onAfterDestroy(mountResult.instance);
                                    }
                                }
                            }
                        }["useMultiRootEditor.useEffect"]
                    })
            }["useMultiRootEditor.useEffect"]);
            return ({
                "useMultiRootEditor.useEffect": ()=>{
                    forceAssignFakeEditableElements();
                    semaphore.release(false);
                }
            })["useMultiRootEditor.useEffect"];
        }
    }["useMultiRootEditor.useEffect"], [
        props.id,
        props.isLayoutReady,
        context == null ? void 0 : context.status
    ]);
    const _getConfig = ()=>{
        const config = props.config || {};
        if (props.data && config.initialData) {
            console.warn("Editor data should be provided either using `config.initialData` or `data` property. The config value takes precedence over `data` property and will be used when both are specified.");
        }
        return {
            ...config,
            rootsAttributes: attributes
        };
    };
    const onChangeData = useRefSafeCallback({
        "useMultiRootEditor.useRefSafeCallback[onChangeData]": (editor, event)=>{
            const modelDocument = editor.model.document;
            if (!props.disableTwoWayDataBinding) {
                const newData = {};
                const newAttributes = {};
                modelDocument.differ.getChanges().forEach({
                    "useMultiRootEditor.useRefSafeCallback[onChangeData]": (change)=>{
                        let root;
                        /* istanbul ignore else -- @preserve */ if (change.type == "insert" || change.type == "remove") {
                            root = change.position.root;
                        } else {
                            root = change.range.root;
                        }
                        if (!root.isAttached()) {
                            return;
                        }
                        const { rootName } = root;
                        newData[rootName] = editor.getData({
                            rootName
                        });
                    }
                }["useMultiRootEditor.useRefSafeCallback[onChangeData]"]);
                modelDocument.differ.getChangedRoots().forEach({
                    "useMultiRootEditor.useRefSafeCallback[onChangeData]": (changedRoot)=>{
                        if (changedRoot.state) {
                            if (newData[changedRoot.name] !== void 0) {
                                delete newData[changedRoot.name];
                            }
                            return;
                        }
                        const rootName = changedRoot.name;
                        newAttributes[rootName] = editor.getRootAttributes(rootName);
                    }
                }["useMultiRootEditor.useRefSafeCallback[onChangeData]"]);
                if (Object.keys(newData).length) {
                    setData({
                        "useMultiRootEditor.useRefSafeCallback[onChangeData]": (previousData)=>({
                                ...previousData,
                                ...newData
                            })
                    }["useMultiRootEditor.useRefSafeCallback[onChangeData]"]);
                }
                if (Object.keys(newAttributes).length) {
                    setAttributes({
                        "useMultiRootEditor.useRefSafeCallback[onChangeData]": (previousAttributes)=>({
                                ...previousAttributes,
                                ...newAttributes
                            })
                    }["useMultiRootEditor.useRefSafeCallback[onChangeData]"]);
                }
            }
            /* istanbul ignore else -- @preserve */ if (props.onChange) {
                props.onChange(event, editor);
            }
        }
    }["useMultiRootEditor.useRefSafeCallback[onChangeData]"]);
    const onAddRoot = useRefSafeCallback({
        "useMultiRootEditor.useRefSafeCallback[onAddRoot]": (editor, _evt, root)=>{
            const rootName = root.rootName;
            if (!props.disableTwoWayDataBinding) {
                setData({
                    "useMultiRootEditor.useRefSafeCallback[onAddRoot]": (previousData)=>({
                            ...previousData,
                            [rootName]: editor.getData({
                                rootName
                            })
                        })
                }["useMultiRootEditor.useRefSafeCallback[onAddRoot]"]);
                setAttributes({
                    "useMultiRootEditor.useRefSafeCallback[onAddRoot]": (previousAttributes)=>({
                            ...previousAttributes,
                            [rootName]: editor.getRootAttributes(rootName)
                        })
                }["useMultiRootEditor.useRefSafeCallback[onAddRoot]"]);
            }
            setRoots({
                "useMultiRootEditor.useRefSafeCallback[onAddRoot]": (prevRoots)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uniq"])([
                        ...prevRoots,
                        root.rootName
                    ])
            }["useMultiRootEditor.useRefSafeCallback[onAddRoot]"]);
        }
    }["useMultiRootEditor.useRefSafeCallback[onAddRoot]"]);
    const onDetachRoot = useRefSafeCallback({
        "useMultiRootEditor.useRefSafeCallback[onDetachRoot]": (_editor, _evt, root)=>{
            const rootName = root.rootName;
            if (!props.disableTwoWayDataBinding) {
                setData({
                    "useMultiRootEditor.useRefSafeCallback[onDetachRoot]": (previousData)=>{
                        const { [rootName]: _, ...newData } = previousData;
                        return {
                            ...newData
                        };
                    }
                }["useMultiRootEditor.useRefSafeCallback[onDetachRoot]"]);
                setAttributes({
                    "useMultiRootEditor.useRefSafeCallback[onDetachRoot]": (previousAttributes)=>{
                        const { [rootName]: _, ...newAttributes } = previousAttributes;
                        return {
                            ...newAttributes
                        };
                    }
                }["useMultiRootEditor.useRefSafeCallback[onDetachRoot]"]);
            }
            setRoots({
                "useMultiRootEditor.useRefSafeCallback[onDetachRoot]": (prevRoots)=>prevRoots.filter({
                        "useMultiRootEditor.useRefSafeCallback[onDetachRoot]": (root2)=>root2 !== rootName
                    }["useMultiRootEditor.useRefSafeCallback[onDetachRoot]"])
            }["useMultiRootEditor.useRefSafeCallback[onDetachRoot]"]);
        }
    }["useMultiRootEditor.useRefSafeCallback[onDetachRoot]"]);
    const _createEditor = useRefSafeCallback({
        "useMultiRootEditor.useRefSafeCallback[_createEditor]": (initialData, config)=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["overwriteObject"])({
                ...props.rootsAttributes
            }, attributes);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["overwriteObject"])({
                ...props.data
            }, data);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["overwriteArray"])(Object.keys(props.data), roots);
            return props.editor.create(initialData, appendAllIntegrationPluginsToConfig(config)).then({
                "useMultiRootEditor.useRefSafeCallback[_createEditor]": (editor)=>{
                    const editorData = editor.getFullData();
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["overwriteObject"])({
                        ...editorData
                    }, data);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["overwriteObject"])({
                        ...editor.getRootsAttributes()
                    }, attributes);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["overwriteArray"])(Object.keys(editorData), roots);
                    if (props.disabled) {
                        /* istanbul ignore else -- @preserve */ editor.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID);
                    }
                    const modelDocument = editor.model.document;
                    const viewDocument = editor.editing.view.document;
                    modelDocument.on("change:data", {
                        "useMultiRootEditor.useRefSafeCallback[_createEditor]": (evt)=>onChangeData(editor, evt)
                    }["useMultiRootEditor.useRefSafeCallback[_createEditor]"]);
                    editor.on("addRoot", {
                        "useMultiRootEditor.useRefSafeCallback[_createEditor]": (evt, root)=>onAddRoot(editor, evt, root)
                    }["useMultiRootEditor.useRefSafeCallback[_createEditor]"]);
                    editor.on("detachRoot", {
                        "useMultiRootEditor.useRefSafeCallback[_createEditor]": (evt, root)=>onDetachRoot(editor, evt, root)
                    }["useMultiRootEditor.useRefSafeCallback[_createEditor]"]);
                    viewDocument.on("focus", {
                        "useMultiRootEditor.useRefSafeCallback[_createEditor]": (event)=>{
                            /* istanbul ignore else -- @preserve */ if (props.onFocus) {
                                props.onFocus(event, editor);
                            }
                        }
                    }["useMultiRootEditor.useRefSafeCallback[_createEditor]"]);
                    viewDocument.on("blur", {
                        "useMultiRootEditor.useRefSafeCallback[_createEditor]": (event)=>{
                            /* istanbul ignore else -- @preserve */ if (props.onBlur) {
                                props.onBlur(event, editor);
                            }
                        }
                    }["useMultiRootEditor.useRefSafeCallback[_createEditor]"]);
                    return editor;
                }
            }["useMultiRootEditor.useRefSafeCallback[_createEditor]"]);
        }
    }["useMultiRootEditor.useRefSafeCallback[_createEditor]"]);
    const _destroyEditor = (initializeResult)=>{
        const { watchdog, instance } = initializeResult;
        return new Promise((resolve, reject)=>{
            /* istanbul ignore next -- @preserve */ setTimeout(async ()=>{
                try {
                    if (watchdog) {
                        await watchdog.destroy();
                        return resolve();
                    }
                    if (instance) {
                        await instance.destroy();
                        return resolve();
                    }
                    resolve();
                } catch (e) {
                    console.error(e);
                    reject(e);
                }
            });
        });
    };
    const _initializeEditor = async ()=>{
        if (props.disableWatchdog) {
            const instance = await _createEditor(props.data, _getConfig());
            return {
                instance,
                watchdog: null
            };
        }
        const watchdog = (()=>{
            if (isContextWatchdogReadyToUse(context)) {
                return new EditorWatchdogAdapter(context.watchdog);
            }
            return new props.editor.EditorWatchdog(props.editor, props.watchdogConfig);
        })();
        const totalRestartsRef = {
            current: 0
        };
        watchdog.setCreator(async (_, config)=>{
            const { onAfterDestroy } = props;
            if (totalRestartsRef.current > 0 && onAfterDestroy && editorRefs.instance.current) {
                onAfterDestroy(editorRefs.instance.current);
            }
            const instance = await _createEditor(data, config);
            if (totalRestartsRef.current > 0) {
                semaphore.unsafeSetValue({
                    instance,
                    watchdog
                });
                setTimeout(()=>{
                    /* istanbul ignore next -- @preserve */ if (props.onReady) {
                        props.onReady(watchdog.editor);
                    }
                });
            }
            totalRestartsRef.current++;
            return instance;
        });
        watchdog.on("error", (_, { error, causesRestart })=>{
            const onError = props.onError || console.error;
            onError(error, {
                phase: "runtime",
                willEditorRestart: causesRestart
            });
        });
        await watchdog.create(data, _getConfig()).catch((error)=>{
            const onError = props.onError || console.error;
            onError(error, {
                phase: "initialization",
                willEditorRestart: false
            });
            throw error;
        });
        return {
            watchdog,
            instance: watchdog.editor
        };
    };
    const _getStateDiff = (previousState, newState)=>{
        const previousStateKeys = Object.keys(previousState);
        const newStateKeys = Object.keys(newState);
        return {
            addedKeys: newStateKeys.filter((key)=>!previousStateKeys.includes(key)),
            removedKeys: previousStateKeys.filter((key)=>!newStateKeys.includes(key))
        };
    };
    const _externalSetData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMultiRootEditor.useCallback[_externalSetData]": (newData)=>{
            semaphore.runAfterMount({
                "useMultiRootEditor.useCallback[_externalSetData]": ()=>{
                    shouldUpdateEditor.current = true;
                    setData(newData);
                }
            }["useMultiRootEditor.useCallback[_externalSetData]"]);
        }
    }["useMultiRootEditor.useCallback[_externalSetData]"], [
        setData
    ]);
    const _externalSetAttributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMultiRootEditor.useCallback[_externalSetAttributes]": (newAttributes)=>{
            semaphore.runAfterMount({
                "useMultiRootEditor.useCallback[_externalSetAttributes]": ()=>{
                    shouldUpdateEditor.current = true;
                    setAttributes(newAttributes);
                }
            }["useMultiRootEditor.useCallback[_externalSetAttributes]"]);
        }
    }["useMultiRootEditor.useCallback[_externalSetAttributes]"], [
        setAttributes
    ]);
    const toolbarElement = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(EditorToolbarWrapper, {
        ref: semaphoreElementRef,
        editor: editorRefs.instance.current
    });
    useInstantEditorEffect(semaphore.current, {
        "useMultiRootEditor.useInstantEditorEffect": ({ instance })=>{
            if (props.disabled) {
                instance.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID);
            } else {
                instance.disableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID);
            }
        }
    }["useMultiRootEditor.useInstantEditorEffect"], [
        props.disabled
    ]);
    useInstantEditorEffect(semaphore.current, {
        "useMultiRootEditor.useInstantEditorEffect": ({ instance })=>{
            if (shouldUpdateEditor.current) {
                shouldUpdateEditor.current = false;
                const dataKeys = Object.keys(data);
                const attributesKeys = Object.keys(attributes);
                if (!dataKeys.every({
                    "useMultiRootEditor.useInstantEditorEffect": (key)=>attributesKeys.includes(key)
                }["useMultiRootEditor.useInstantEditorEffect"])) {
                    console.error("`data` and `attributes` objects must have the same keys (roots).");
                    throw new Error("`data` and `attributes` objects must have the same keys (roots).");
                }
                const editorData = instance.getFullData();
                const editorAttributes = instance.getRootsAttributes();
                const { addedKeys: newRoots, removedKeys: removedRoots } = _getStateDiff(editorData, data || /* istanbul ignore next -- @preserve: It should never happen, data should be always filled. */ {});
                const modifiedRoots = dataKeys.filter({
                    "useMultiRootEditor.useInstantEditorEffect.modifiedRoots": (rootName)=>editorData[rootName] !== void 0 && JSON.stringify(editorData[rootName]) !== JSON.stringify(data[rootName])
                }["useMultiRootEditor.useInstantEditorEffect.modifiedRoots"]);
                const rootsWithChangedAttributes = attributesKeys.filter({
                    "useMultiRootEditor.useInstantEditorEffect.rootsWithChangedAttributes": (rootName)=>JSON.stringify(editorAttributes[rootName]) !== JSON.stringify(attributes[rootName])
                }["useMultiRootEditor.useInstantEditorEffect.rootsWithChangedAttributes"]);
                const _handleNewRoots = {
                    "useMultiRootEditor.useInstantEditorEffect._handleNewRoots": (roots2)=>{
                        roots2.forEach({
                            "useMultiRootEditor.useInstantEditorEffect._handleNewRoots": (rootName)=>{
                                instance.addRoot(rootName, {
                                    data: data[rootName] || "",
                                    attributes: (attributes == null ? void 0 : attributes[rootName]) || /* istanbul ignore next -- @preserve: attributes should be in sync with root keys */ {},
                                    isUndoable: true
                                });
                            }
                        }["useMultiRootEditor.useInstantEditorEffect._handleNewRoots"]);
                    }
                }["useMultiRootEditor.useInstantEditorEffect._handleNewRoots"];
                const _handleRemovedRoots = {
                    "useMultiRootEditor.useInstantEditorEffect._handleRemovedRoots": (roots2)=>{
                        roots2.forEach({
                            "useMultiRootEditor.useInstantEditorEffect._handleRemovedRoots": (rootName)=>{
                                instance.detachRoot(rootName, true);
                            }
                        }["useMultiRootEditor.useInstantEditorEffect._handleRemovedRoots"]);
                    }
                }["useMultiRootEditor.useInstantEditorEffect._handleRemovedRoots"];
                const _updateEditorData = {
                    "useMultiRootEditor.useInstantEditorEffect._updateEditorData": (roots2)=>{
                        const dataToUpdate = roots2.reduce({
                            "useMultiRootEditor.useInstantEditorEffect._updateEditorData.dataToUpdate": (result, rootName)=>({
                                    ...result,
                                    [rootName]: data[rootName]
                                })
                        }["useMultiRootEditor.useInstantEditorEffect._updateEditorData.dataToUpdate"], /* @__PURE__ */ Object.create(null));
                        instance.data.set(dataToUpdate, {
                            suppressErrorInCollaboration: true
                        });
                    }
                }["useMultiRootEditor.useInstantEditorEffect._updateEditorData"];
                const _updateEditorAttributes = {
                    "useMultiRootEditor.useInstantEditorEffect._updateEditorAttributes": (writer, roots2)=>{
                        roots2.forEach({
                            "useMultiRootEditor.useInstantEditorEffect._updateEditorAttributes": (rootName)=>{
                                Object.keys(attributes[rootName]).forEach({
                                    "useMultiRootEditor.useInstantEditorEffect._updateEditorAttributes": (attr)=>{
                                        instance.registerRootAttribute(attr);
                                    }
                                }["useMultiRootEditor.useInstantEditorEffect._updateEditorAttributes"]);
                                writer.clearAttributes(instance.model.document.getRoot(rootName));
                                writer.setAttributes(attributes[rootName], instance.model.document.getRoot(rootName));
                            }
                        }["useMultiRootEditor.useInstantEditorEffect._updateEditorAttributes"]);
                    }
                }["useMultiRootEditor.useInstantEditorEffect._updateEditorAttributes"];
                setTimeout({
                    "useMultiRootEditor.useInstantEditorEffect": ()=>{
                        instance.model.change({
                            "useMultiRootEditor.useInstantEditorEffect": (writer)=>{
                                _handleNewRoots(newRoots);
                                _handleRemovedRoots(removedRoots);
                                if (modifiedRoots.length) {
                                    _updateEditorData(modifiedRoots);
                                }
                                if (rootsWithChangedAttributes.length) {
                                    _updateEditorAttributes(writer, rootsWithChangedAttributes);
                                }
                            }
                        }["useMultiRootEditor.useInstantEditorEffect"]);
                    }
                }["useMultiRootEditor.useInstantEditorEffect"]);
            }
        }
    }["useMultiRootEditor.useInstantEditorEffect"], [
        data,
        attributes
    ]);
    const editableElements = roots.map((rootName)=>/* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(EditorEditable, {
            key: rootName,
            id: rootName,
            rootName,
            semaphore
        }));
    return {
        editor: editorRefs.instance.current,
        editableElements,
        toolbarElement,
        data,
        setData: _externalSetData,
        attributes,
        setAttributes: _externalSetAttributes
    };
};
const EditorEditable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(({ id, semaphore, rootName }, ref)=>{
    const innerRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "EditorEditable.useEffect": ()=>{
            let editable;
            let editor;
            semaphore.runAfterMount({
                "EditorEditable.useEffect": ({ instance })=>{
                    if (!innerRef.current) {
                        return;
                    }
                    editor = instance;
                    const { ui, model } = editor;
                    const root = model.document.getRoot(rootName);
                    if (root && editor.ui.getEditableElement(rootName)) {
                        editor.detachEditable(root);
                    }
                    editable = ui.view.createEditable(rootName, innerRef.current);
                    ui.addEditable(editable);
                    instance.editing.view.forceRender();
                }
            }["EditorEditable.useEffect"]);
            return ({
                "EditorEditable.useEffect": ()=>{
                    if (editor && editor.state !== "destroyed" && innerRef.current) {
                        const root = editor.model.document.getRoot(rootName);
                        /* istanbul ignore else -- @preserve */ if (root) {
                            editor.detachEditable(root);
                        }
                    }
                }
            })["EditorEditable.useEffect"];
        }
    }["EditorEditable.useEffect"], [
        semaphore.revision
    ]);
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        key: semaphore.revision,
        id,
        ref: mergeRefs(ref, innerRef)
    });
}));
EditorEditable.displayName = "EditorEditable";
const EditorToolbarWrapper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(({ editor }, ref)=>{
    const toolbarRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "EditorToolbarWrapper.useEffect": ()=>{
            const toolbarContainer = toolbarRef.current;
            if (!editor || !toolbarContainer) {
                return void 0;
            }
            const element = editor.ui.view.toolbar.element;
            toolbarContainer.appendChild(element);
            return ({
                "EditorToolbarWrapper.useEffect": ()=>{
                    if (toolbarContainer.contains(element)) {
                        toolbarContainer.removeChild(element);
                    }
                }
            })["EditorToolbarWrapper.useEffect"];
        }
    }["EditorToolbarWrapper.useEffect"], [
        editor && editor.id
    ]);
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        ref: mergeRefs(toolbarRef, ref)
    });
});
EditorToolbarWrapper.displayName = "EditorToolbarWrapper";
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const useIsUnmountedRef = ()=>{
    const mountedRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(false);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useIsUnmountedRef.useEffect": ()=>{
            mountedRef.current = false;
            return ({
                "useIsUnmountedRef.useEffect": ()=>{
                    mountedRef.current = true;
                }
            })["useIsUnmountedRef.useEffect"];
        }
    }["useIsUnmountedRef.useEffect"], []);
    return mountedRef;
};
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const useAsyncCallback = (callback)=>{
    const [asyncState, setAsyncState] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        status: "idle"
    });
    const unmountedRef = useIsUnmountedRef();
    const prevExecutionUIDRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const asyncExecutor = useRefSafeCallback({
        "useAsyncCallback.useRefSafeCallback[asyncExecutor]": async (...args)=>{
            if (unmountedRef.current || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSSR"])()) {
                return null;
            }
            const currentExecutionUUID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])();
            prevExecutionUIDRef.current = currentExecutionUUID;
            try {
                if (asyncState.status !== "loading") {
                    setAsyncState({
                        status: "loading"
                    });
                }
                const result = await callback(...args);
                if (!unmountedRef.current && prevExecutionUIDRef.current === currentExecutionUUID) {
                    setAsyncState({
                        status: "success",
                        data: result
                    });
                }
                return result;
            } catch (error) {
                console.error(error);
                if (!unmountedRef.current && prevExecutionUIDRef.current === currentExecutionUUID) {
                    setAsyncState({
                        status: "error",
                        error
                    });
                }
            }
            return null;
        }
    }["useAsyncCallback.useRefSafeCallback[asyncExecutor]"]);
    return [
        asyncExecutor,
        asyncState
    ];
};
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const useAsyncValue = (callback, deps)=>{
    const [asyncCallback, asyncState] = useAsyncCallback(callback);
    useInstantEffect(asyncCallback, deps);
    if (asyncState.status === "idle") {
        return {
            status: "loading"
        };
    }
    return asyncState;
};
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ function useCKEditorCloud(config) {
    const serializedConfigKey = JSON.stringify(config);
    const result = useAsyncValue({
        "useCKEditorCloud.useAsyncValue[result]": async ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["loadCKEditorCloud"])(config)
    }["useCKEditorCloud.useAsyncValue[result]"], [
        serializedConfigKey
    ]);
    if (result.status === "success") {
        return {
            ...result.data,
            status: "success"
        };
    }
    return result;
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ const withCKEditorCloud = (config)=>(WrappedComponent)=>{
        const ComponentWithCKEditorCloud = (props)=>{
            var _a, _b;
            const ckeditorCloudResult = useCKEditorCloud(config.cloud);
            switch(ckeditorCloudResult.status){
                case "error":
                    if (!config.renderError) {
                        return "Unable to load CKEditor Cloud data!";
                    }
                    return config.renderError(ckeditorCloudResult.error);
                case "success":
                    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(WrappedComponent, {
                        ...props,
                        cloud: ckeditorCloudResult
                    });
                default:
                    return (_b = (_a = config.renderLoader) == null ? void 0 : _a.call(config)) != null ? _b : null;
            }
        };
        ComponentWithCKEditorCloud.displayName = "ComponentWithCKEditorCloud";
        return ComponentWithCKEditorCloud;
    };
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-react/dist/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$integrations$2d$common$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-integrations-common/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$react$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-react/dist/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@ckeditor/ckeditor5-watchdog/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "ContextWatchdog": (()=>ContextWatchdog),
    "EditorWatchdog": (()=>EditorWatchdog),
    "Watchdog": (()=>Watchdog)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/throttle.js [app-client] (ecmascript) <export default as throttle>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/isElement.js [app-client] (ecmascript) <export default as isElement>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$cloneDeepWith$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__cloneDeepWith$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/cloneDeepWith.js [app-client] (ecmascript) <export default as cloneDeepWith>");
;
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module watchdog/watchdog
 */ /* globals window */ /**
 * An abstract watchdog class that handles most of the error handling process and the state of the underlying component.
 *
 * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and how to use it.
 *
 * @internal
 */ class Watchdog {
    /**
	 * An array of crashes saved as an object with the following properties:
	 *
	 * * `message`: `String`,
	 * * `stack`: `String`,
	 * * `date`: `Number`,
	 * * `filename`: `String | undefined`,
	 * * `lineno`: `Number | undefined`,
	 * * `colno`: `Number | undefined`,
	 */ crashes = [];
    /**
	 * Specifies the state of the item watched by the watchdog. The state can be one of the following values:
	 *
	 * * `initializing` &ndash; Before the first initialization, and after crashes, before the item is ready.
	 * * `ready` &ndash; A state when the user can interact with the item.
	 * * `crashed` &ndash; A state when an error occurs. It quickly changes to `initializing` or `crashedPermanently`
	 * depending on how many and how frequent errors have been caught recently.
	 * * `crashedPermanently` &ndash; A state when the watchdog stops reacting to errors and keeps the item it is watching crashed,
	 * * `destroyed` &ndash; A state when the item is manually destroyed by the user after calling `watchdog.destroy()`.
	 */ state = 'initializing';
    /**
	 * @see module:watchdog/watchdog~WatchdogConfig
	 */ _crashNumberLimit;
    /**
	 * Returns the result of the `Date.now()` call. It can be overridden in tests to mock time as some popular
	 * approaches like `sinon.useFakeTimers()` do not work well with error handling.
	 */ _now = Date.now;
    /**
	 * @see module:watchdog/watchdog~WatchdogConfig
	 */ _minimumNonErrorTimePeriod;
    /**
	 * Checks if the event error comes from the underlying item and restarts the item.
	 */ _boundErrorHandler;
    /**
	 * A dictionary of event emitter listeners.
	 */ _listeners;
    /**
	 * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.
	 */ constructor(config){
        this.crashes = [];
        this._crashNumberLimit = typeof config.crashNumberLimit === 'number' ? config.crashNumberLimit : 3;
        this._minimumNonErrorTimePeriod = typeof config.minimumNonErrorTimePeriod === 'number' ? config.minimumNonErrorTimePeriod : 5000;
        this._boundErrorHandler = (evt)=>{
            // `evt.error` is exposed by EventError while `evt.reason` is available in PromiseRejectionEvent.
            const error = 'error' in evt ? evt.error : evt.reason;
            // Note that `evt.reason` might be everything that is in the promise rejection.
            // Similarly everything that is thrown lands in `evt.error`.
            if (error instanceof Error) {
                this._handleError(error, evt);
            }
        };
        this._listeners = {};
        if (!this._restart) {
            throw new Error('The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. ' + 'Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.');
        }
    }
    /**
	 * Destroys the watchdog and releases the resources.
	 */ destroy() {
        this._stopErrorHandling();
        this._listeners = {};
    }
    /**
	 * Starts listening to a specific event name by registering a callback that will be executed
	 * whenever an event with a given name fires.
	 *
	 * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
	 *
	 * @param eventName The event name.
	 * @param callback A callback which will be added to event listeners.
	 */ on(eventName, callback) {
        if (!this._listeners[eventName]) {
            this._listeners[eventName] = [];
        }
        this._listeners[eventName].push(callback);
    }
    /**
	 * Stops listening to the specified event name by removing the callback from event listeners.
	 *
	 * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
	 *
	 * @param eventName The event name.
	 * @param callback A callback which will be removed from event listeners.
	 */ off(eventName, callback) {
        this._listeners[eventName] = this._listeners[eventName].filter((cb)=>cb !== callback);
    }
    /**
	 * Fires an event with a given event name and arguments.
	 *
	 * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
	 */ _fire(eventName, ...args) {
        const callbacks = this._listeners[eventName] || [];
        for (const callback of callbacks){
            callback.apply(this, [
                null,
                ...args
            ]);
        }
    }
    /**
	 * Starts error handling by attaching global error handlers.
	 */ _startErrorHandling() {
        window.addEventListener('error', this._boundErrorHandler);
        window.addEventListener('unhandledrejection', this._boundErrorHandler);
    }
    /**
	 * Stops error handling by detaching global error handlers.
	 */ _stopErrorHandling() {
        window.removeEventListener('error', this._boundErrorHandler);
        window.removeEventListener('unhandledrejection', this._boundErrorHandler);
    }
    /**
	 * Checks if an error comes from the watched item and restarts it.
	 * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.
	 *
	 * @fires error
	 * @param error Error.
	 * @param evt An error event.
	 */ _handleError(error, evt) {
        // @if CK_DEBUG // const err = error as CKEditorError;
        // @if CK_DEBUG // if ( err.is && err.is( 'CKEditorError' ) && err.context === undefined ) {
        // @if CK_DEBUG // console.warn( 'The error is missing its context and Watchdog cannot restart the proper item.' );
        // @if CK_DEBUG // }
        if (this._shouldReactToError(error)) {
            this.crashes.push({
                message: error.message,
                stack: error.stack,
                // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events
                filename: evt instanceof ErrorEvent ? evt.filename : undefined,
                lineno: evt instanceof ErrorEvent ? evt.lineno : undefined,
                colno: evt instanceof ErrorEvent ? evt.colno : undefined,
                date: this._now()
            });
            const causesRestart = this._shouldRestart();
            this.state = 'crashed';
            this._fire('stateChange');
            this._fire('error', {
                error,
                causesRestart
            });
            if (causesRestart) {
                this._restart();
            } else {
                this.state = 'crashedPermanently';
                this._fire('stateChange');
            }
        }
    }
    /**
	 * Checks whether an error should be handled by the watchdog.
	 *
	 * @param error An error that was caught by the error handling process.
	 */ _shouldReactToError(error) {
        return error.is && error.is('CKEditorError') && error.context !== undefined && // In some cases the watched item should not be restarted - e.g. during the item initialization.
        // That's why the `null` was introduced as a correct error context which does cause restarting.
        error.context !== null && // Do not react to errors if the watchdog is in states other than `ready`.
        this.state === 'ready' && this._isErrorComingFromThisItem(error);
    }
    /**
	 * Checks if the watchdog should restart the underlying item.
	 */ _shouldRestart() {
        if (this.crashes.length <= this._crashNumberLimit) {
            return true;
        }
        const lastErrorTime = this.crashes[this.crashes.length - 1].date;
        const firstMeaningfulErrorTime = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
        const averageNonErrorTimePeriod = (lastErrorTime - firstMeaningfulErrorTime) / this._crashNumberLimit;
        return averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module watchdog/utils/getsubnodes
 */ /* globals EventTarget, Event */ function getSubNodes(head, excludedProperties = new Set()) {
    const nodes = [
        head
    ];
    // @if CK_DEBUG_WATCHDOG // const prevNodeMap = new Map();
    // Nodes are stored to prevent infinite looping.
    const subNodes = new Set();
    let nodeIndex = 0;
    while(nodes.length > nodeIndex){
        // Incrementing the iterator is much faster than changing size of the array with Array.prototype.shift().
        const node = nodes[nodeIndex++];
        if (subNodes.has(node) || !shouldNodeBeIncluded(node) || excludedProperties.has(node)) {
            continue;
        }
        subNodes.add(node);
        // Handle arrays, maps, sets, custom collections that implements `[ Symbol.iterator ]()`, etc.
        if (Symbol.iterator in node) {
            // The custom editor iterators might cause some problems if the editor is crashed.
            try {
                for (const n of node){
                    nodes.push(n);
                // @if CK_DEBUG_WATCHDOG // if ( !prevNodeMap.has( n ) ) {
                // @if CK_DEBUG_WATCHDOG // 	prevNodeMap.set( n, node );
                // @if CK_DEBUG_WATCHDOG // }
                }
            } catch (err) {
            // Do not log errors for broken structures
            // since we are in the error handling process already.
            // eslint-disable-line no-empty
            }
        } else {
            for(const key in node){
                // We share a reference via the protobuf library within the editors,
                // hence the shared value should be skipped. Although, it's not a perfect
                // solution since new places like that might occur in the future.
                if (key === 'defaultValue') {
                    continue;
                }
                nodes.push(node[key]);
            // @if CK_DEBUG_WATCHDOG // if ( !prevNodeMap.has( node[ key ] ) ) {
            // @if CK_DEBUG_WATCHDOG // 	prevNodeMap.set( node[ key ], node );
            // @if CK_DEBUG_WATCHDOG // }
            }
        }
    }
    // @if CK_DEBUG_WATCHDOG // return { subNodes, prevNodeMap } as any;
    return subNodes;
}
function shouldNodeBeIncluded(node) {
    const type = Object.prototype.toString.call(node);
    const typeOfNode = typeof node;
    return !(typeOfNode === 'number' || typeOfNode === 'boolean' || typeOfNode === 'string' || typeOfNode === 'symbol' || typeOfNode === 'function' || type === '[object Date]' || type === '[object RegExp]' || type === '[object Module]' || node === undefined || node === null || // This flag is meant to exclude singletons shared across editor instances. So when an error is thrown in one editor,
    // the other editors connected through the reference to the same singleton are not restarted. This is a temporary workaround
    // until a better solution is found.
    // More in https://github.com/ckeditor/ckeditor5/issues/12292.
    node._watchdogExcluded || // Skip native DOM objects, e.g. Window, nodes, events, etc.
    node instanceof EventTarget || node instanceof Event);
}
/**
 * Traverses both structures to find out whether there is a reference that is shared between both structures.
 */ function areConnectedThroughProperties(target1, target2, excludedNodes = new Set()) {
    if (target1 === target2 && isObject(target1)) {
        return true;
    }
    // @if CK_DEBUG_WATCHDOG // return checkConnectionBetweenProps( target1, target2, excludedNodes );
    const subNodes1 = getSubNodes(target1, excludedNodes);
    const subNodes2 = getSubNodes(target2, excludedNodes);
    for (const node of subNodes1){
        if (subNodes2.has(node)) {
            return true;
        }
    }
    return false;
}
function isObject(structure) {
    return typeof structure === 'object' && structure !== null;
}
/**
 * A watchdog for CKEditor 5 editors.
 *
 * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and
 * how to use it.
 */ class EditorWatchdog extends Watchdog {
    /**
	 * The current editor instance.
	 */ _editor = null;
    /**
	 * A promise associated with the life cycle of the editor (creation or destruction processes).
	 *
	 * It is used to prevent the initialization of the editor if the previous instance has not been destroyed yet,
	 * and conversely, to prevent the destruction of the editor if it has not been initialized.
	 */ _lifecyclePromise = null;
    /**
	 * Throttled save method. The `save()` method is called the specified `saveInterval` after `throttledSave()` is called,
	 * unless a new action happens in the meantime.
	 */ _throttledSave;
    /**
	 * The latest saved editor data represented as a root name -> root data object.
	 */ _data;
    /**
	 * The last document version.
	 */ _lastDocumentVersion;
    /**
	 * The editor source element or data.
	 */ _elementOrData;
    /**
	 * Specifies whether the editor was initialized using document data (`true`) or HTML elements (`false`).
	 */ _initUsingData = true;
    /**
	 * The latest record of the editor editable elements. Used to restart the editor.
	 */ _editables = {};
    /**
	 * The editor configuration.
	 */ _config;
    _excludedProps;
    /**
	 * @param Editor The editor class.
	 * @param watchdogConfig The watchdog plugin configuration.
	 */ constructor(Editor, watchdogConfig = {}){
        super(watchdogConfig);
        // this._editorClass = Editor;
        this._throttledSave = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])(this._save.bind(this), typeof watchdogConfig.saveInterval === 'number' ? watchdogConfig.saveInterval : 5000);
        // Set default creator and destructor functions:
        if (Editor) {
            this._creator = (elementOrData, config)=>Editor.create(elementOrData, config);
        }
        this._destructor = (editor)=>editor.destroy();
    }
    /**
	 * The current editor instance.
	 */ get editor() {
        return this._editor;
    }
    /**
	 * @internal
	 */ get _item() {
        return this._editor;
    }
    /**
	 * Sets the function that is responsible for the editor creation.
	 * It expects a function that should return a promise.
	 *
	 * ```ts
	 * watchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );
	 * ```
	 */ setCreator(creator) {
        this._creator = creator;
    }
    /**
	 * Sets the function that is responsible for the editor destruction.
	 * Overrides the default destruction function, which destroys only the editor instance.
	 * It expects a function that should return a promise or `undefined`.
	 *
	 * ```ts
	 * watchdog.setDestructor( editor => {
	 * 	// Do something before the editor is destroyed.
	 *
	 * 	return editor
	 * 		.destroy()
	 * 		.then( () => {
	 * 			// Do something after the editor is destroyed.
	 * 		} );
	 * } );
	 * ```
	 */ setDestructor(destructor) {
        this._destructor = destructor;
    }
    /**
	 * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes
	 * the state to `initializing`.
	 *
	 * @fires restart
	 */ _restart() {
        return Promise.resolve().then(()=>{
            this.state = 'initializing';
            this._fire('stateChange');
            return this._destroy();
        }).catch((err)=>{
            console.error('An error happened during the editor destroying.', err);
        }).then(()=>{
            // Pre-process some data from the original editor config.
            // Our goal here is to make sure that the restarted editor will be reinitialized with correct set of roots.
            // We are not interested in any data set in config or in `.create()` first parameter. It will be replaced anyway.
            // But we need to set them correctly to make sure that proper roots are created.
            //
            // Since a different set of roots will be created, `lazyRoots` and `rootsAttributes` properties must be managed too.
            // Keys are root names, values are ''. Used when the editor was initialized by setting the first parameter to document data.
            const existingRoots = {};
            // Keeps lazy roots. They may be different when compared to initial config if some of the roots were loaded.
            const lazyRoots = [];
            // Roots attributes from the old config. Will be referred when setting new attributes.
            const oldRootsAttributes = this._config.rootsAttributes || {};
            // New attributes to be set. Is filled only for roots that still exist in the document.
            const rootsAttributes = {};
            // Traverse through the roots saved when the editor crashed and set up the discussed values.
            for (const [rootName, rootData] of Object.entries(this._data.roots)){
                if (rootData.isLoaded) {
                    existingRoots[rootName] = '';
                    rootsAttributes[rootName] = oldRootsAttributes[rootName] || {};
                } else {
                    lazyRoots.push(rootName);
                }
            }
            const updatedConfig = {
                ...this._config,
                extraPlugins: this._config.extraPlugins || [],
                lazyRoots,
                rootsAttributes,
                _watchdogInitialData: this._data
            };
            // Delete `initialData` as it is not needed. Data will be set by the watchdog based on `_watchdogInitialData`.
            // First parameter of the editor `.create()` will be used to set up initial roots.
            delete updatedConfig.initialData;
            updatedConfig.extraPlugins.push(EditorWatchdogInitPlugin);
            if (this._initUsingData) {
                return this.create(existingRoots, updatedConfig, updatedConfig.context);
            } else {
                // Set correct editables to make sure that proper roots are created and linked with DOM elements.
                // No need to set initial data, as it would be discarded anyway.
                //
                // If one element was initially set in `elementOrData`, then use that original element to restart the editor.
                // This is for compatibility purposes with single-root editor types.
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__["isElement"])(this._elementOrData)) {
                    return this.create(this._elementOrData, updatedConfig, updatedConfig.context);
                } else {
                    return this.create(this._editables, updatedConfig, updatedConfig.context);
                }
            }
        }).then(()=>{
            this._fire('restart');
        });
    }
    /**
	 * Creates the editor instance and keeps it running, using the defined creator and destructor.
	 *
	 * @param elementOrData The editor source element or the editor data.
	 * @param config The editor configuration.
	 * @param context A context for the editor.
	 */ create(elementOrData = this._elementOrData, config = this._config, context) {
        this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(()=>{
            super._startErrorHandling();
            this._elementOrData = elementOrData;
            // Use document data in the first parameter of the editor `.create()` call only if it was used like this originally.
            // Use document data if a string or object with strings was passed.
            this._initUsingData = typeof elementOrData == 'string' || Object.keys(elementOrData).length > 0 && typeof Object.values(elementOrData)[0] == 'string';
            // Clone configuration because it might be shared within multiple watchdog instances. Otherwise,
            // when an error occurs in one of these editors, the watchdog will restart all of them.
            this._config = this._cloneEditorConfiguration(config) || {};
            this._config.context = context;
            return this._creator(elementOrData, this._config);
        }).then((editor)=>{
            this._editor = editor;
            editor.model.document.on('change:data', this._throttledSave);
            this._lastDocumentVersion = editor.model.document.version;
            this._data = this._getData();
            if (!this._initUsingData) {
                this._editables = this._getEditables();
            }
            this.state = 'ready';
            this._fire('stateChange');
        }).finally(()=>{
            this._lifecyclePromise = null;
        });
        return this._lifecyclePromise;
    }
    /**
	 * Destroys the watchdog and the current editor instance. It fires the callback
	 * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.
	 * It also sets the state to `destroyed`.
	 */ destroy() {
        this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(()=>{
            this.state = 'destroyed';
            this._fire('stateChange');
            super.destroy();
            return this._destroy();
        }).finally(()=>{
            this._lifecyclePromise = null;
        });
        return this._lifecyclePromise;
    }
    _destroy() {
        return Promise.resolve().then(()=>{
            this._stopErrorHandling();
            this._throttledSave.cancel();
            const editor = this._editor;
            this._editor = null;
            // Remove the `change:data` listener before destroying the editor.
            // Incorrectly written plugins may trigger firing `change:data` events during the editor destruction phase
            // causing the watchdog to call `editor.getData()` when some parts of editor are already destroyed.
            editor.model.document.off('change:data', this._throttledSave);
            return this._destructor(editor);
        });
    }
    /**
	 * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at
	 * the moment of the crash.
	 */ _save() {
        const version = this._editor.model.document.version;
        try {
            this._data = this._getData();
            if (!this._initUsingData) {
                this._editables = this._getEditables();
            }
            this._lastDocumentVersion = version;
        } catch (err) {
            console.error(err, 'An error happened during restoring editor data. ' + 'Editor will be restored from the previously saved data.');
        }
    }
    /**
	 * @internal
	 */ _setExcludedProperties(props) {
        this._excludedProps = props;
    }
    /**
	 * Gets all data that is required to reinitialize editor instance.
	 */ _getData() {
        const editor = this._editor;
        const roots = editor.model.document.roots.filter((root)=>root.isAttached() && root.rootName != '$graveyard');
        const { plugins } = editor;
        // `as any` to avoid linking from external private repo.
        const commentsRepository = plugins.has('CommentsRepository') && plugins.get('CommentsRepository');
        const trackChanges = plugins.has('TrackChanges') && plugins.get('TrackChanges');
        const data = {
            roots: {},
            markers: {},
            commentThreads: JSON.stringify([]),
            suggestions: JSON.stringify([])
        };
        roots.forEach((root)=>{
            data.roots[root.rootName] = {
                content: JSON.stringify(Array.from(root.getChildren())),
                attributes: JSON.stringify(Array.from(root.getAttributes())),
                isLoaded: root._isLoaded
            };
        });
        for (const marker of editor.model.markers){
            if (!marker._affectsData) {
                continue;
            }
            data.markers[marker.name] = {
                rangeJSON: marker.getRange().toJSON(),
                usingOperation: marker._managedUsingOperations,
                affectsData: marker._affectsData
            };
        }
        if (commentsRepository) {
            data.commentThreads = JSON.stringify(commentsRepository.getCommentThreads({
                toJSON: true,
                skipNotAttached: true
            }));
        }
        if (trackChanges) {
            data.suggestions = JSON.stringify(trackChanges.getSuggestions({
                toJSON: true,
                skipNotAttached: true
            }));
        }
        return data;
    }
    /**
	 * For each attached model root, returns its HTML editable element (if available).
	 */ _getEditables() {
        const editables = {};
        for (const rootName of this.editor.model.document.getRootNames()){
            const editable = this.editor.ui.getEditableElement(rootName);
            if (editable) {
                editables[rootName] = editable;
            }
        }
        return editables;
    }
    /**
	 * Traverses the error context and the current editor to find out whether these structures are connected
	 * to each other via properties.
	 *
	 * @internal
	 */ _isErrorComingFromThisItem(error) {
        return areConnectedThroughProperties(this._editor, error.context, this._excludedProps);
    }
    /**
	 * Clones the editor configuration.
	 */ _cloneEditorConfiguration(config) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$cloneDeepWith$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__cloneDeepWith$3e$__["cloneDeepWith"])(config, (value, key)=>{
            // Leave DOM references.
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__["isElement"])(value)) {
                return value;
            }
            if (key === 'context') {
                return value;
            }
        });
    }
}
/**
 * Internal plugin that is used to stop the default editor initialization and restoring the editor state
 * based on the `editor.config._watchdogInitialData` data.
 */ class EditorWatchdogInitPlugin {
    editor;
    _data;
    constructor(editor){
        this.editor = editor;
        this._data = editor.config.get('_watchdogInitialData');
    }
    /**
	 * @inheritDoc
	 */ init() {
        // Stops the default editor initialization and use the saved data to restore the editor state.
        // Some of data could not be initialize as a config properties. It is important to keep the data
        // in the same form as it was before the restarting.
        this.editor.data.on('init', (evt)=>{
            evt.stop();
            this.editor.model.enqueueChange({
                isUndoable: false
            }, (writer)=>{
                this._restoreCollaborationData();
                this._restoreEditorData(writer);
            });
            this.editor.data.fire('ready');
        // Keep priority `'high' - 1` to be sure that RTC initialization will be first.
        }, {
            priority: 1000 - 1
        });
    }
    /**
	 * Creates a model node (element or text) based on provided JSON.
	 */ _createNode(writer, jsonNode) {
        if ('name' in jsonNode) {
            // If child has name property, it is an Element.
            const element = writer.createElement(jsonNode.name, jsonNode.attributes);
            if (jsonNode.children) {
                for (const child of jsonNode.children){
                    element._appendChild(this._createNode(writer, child));
                }
            }
            return element;
        } else {
            // Otherwise, it is a Text node.
            return writer.createText(jsonNode.data, jsonNode.attributes);
        }
    }
    /**
	 * Restores the editor by setting the document data, roots attributes and markers.
	 */ _restoreEditorData(writer) {
        const editor = this.editor;
        Object.entries(this._data.roots).forEach(([rootName, { content, attributes }])=>{
            const parsedNodes = JSON.parse(content);
            const parsedAttributes = JSON.parse(attributes);
            const rootElement = editor.model.document.getRoot(rootName);
            for (const [key, value] of parsedAttributes){
                writer.setAttribute(key, value, rootElement);
            }
            for (const child of parsedNodes){
                const node = this._createNode(writer, child);
                writer.insert(node, rootElement, 'end');
            }
        });
        Object.entries(this._data.markers).forEach(([markerName, markerOptions])=>{
            const { document } = editor.model;
            const { rangeJSON: { start, end }, ...options } = markerOptions;
            const root = document.getRoot(start.root);
            const startPosition = writer.createPositionFromPath(root, start.path, start.stickiness);
            const endPosition = writer.createPositionFromPath(root, end.path, end.stickiness);
            const range = writer.createRange(startPosition, endPosition);
            writer.addMarker(markerName, {
                range,
                ...options
            });
        });
    }
    /**
	 * Restores the editor collaboration data - comment threads and suggestions.
	 */ _restoreCollaborationData() {
        // `as any` to avoid linking from external private repo.
        const parsedCommentThreads = JSON.parse(this._data.commentThreads);
        const parsedSuggestions = JSON.parse(this._data.suggestions);
        parsedCommentThreads.forEach((commentThreadData)=>{
            const channelId = this.editor.config.get('collaboration.channelId');
            const commentsRepository = this.editor.plugins.get('CommentsRepository');
            if (commentsRepository.hasCommentThread(commentThreadData.threadId)) {
                const commentThread = commentsRepository.getCommentThread(commentThreadData.threadId);
                commentThread.remove();
            }
            commentsRepository.addCommentThread({
                channelId,
                ...commentThreadData
            });
        });
        parsedSuggestions.forEach((suggestionData)=>{
            const trackChangesEditing = this.editor.plugins.get('TrackChangesEditing');
            if (trackChangesEditing.hasSuggestion(suggestionData.id)) {
                const suggestion = trackChangesEditing.getSuggestion(suggestionData.id);
                suggestion.attributes = suggestionData.attributes;
            } else {
                trackChangesEditing.addSuggestionData(suggestionData);
            }
        });
    }
}
const mainQueueId = Symbol('MainQueueId');
/**
 * A watchdog for the {@link module:core/context~Context} class.
 *
 * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and
 * how to use it.
 */ class ContextWatchdog extends Watchdog {
    /**
	 * A map of internal watchdogs for added items.
	 */ _watchdogs = new Map();
    /**
	 * The watchdog configuration.
	 */ _watchdogConfig;
    /**
	 * The current context instance.
	 */ _context = null;
    /**
	 * Context properties (nodes/references) that are gathered during the initial context creation
	 * and are used to distinguish the origin of an error.
	 */ _contextProps = new Set();
    /**
	 * An action queue, which is used to handle async functions queuing.
	 */ _actionQueues = new ActionQueues();
    /**
	 * The configuration for the {@link module:core/context~Context}.
	 */ _contextConfig;
    /**
	 * The watched item.
	 */ _item;
    /**
	 * The context watchdog class constructor.
	 *
	 * ```ts
	 * const watchdog = new ContextWatchdog( Context );
	 *
	 * await watchdog.create( contextConfiguration );
	 *
	 * await watchdog.add( item );
	 * ```
	 *
	 * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.
	 *
	 * @param Context The {@link module:core/context~Context} class.
	 * @param watchdogConfig The watchdog configuration.
	 */ constructor(Context, watchdogConfig = {}){
        super(watchdogConfig);
        this._watchdogConfig = watchdogConfig;
        // Default creator and destructor.
        this._creator = (contextConfig)=>Context.create(contextConfig);
        this._destructor = (context)=>context.destroy();
        this._actionQueues.onEmpty(()=>{
            if (this.state === 'initializing') {
                this.state = 'ready';
                this._fire('stateChange');
            }
        });
    }
    /**
	 * Sets the function that is responsible for the context creation.
	 * It expects a function that should return a promise (or `undefined`).
	 *
	 * ```ts
	 * watchdog.setCreator( config => Context.create( config ) );
	 * ```
	 */ setCreator(creator) {
        this._creator = creator;
    }
    /**
	 * Sets the function that is responsible for the context destruction.
	 * Overrides the default destruction function, which destroys only the context instance.
	 * It expects a function that should return a promise (or `undefined`).
	 *
	 * ```ts
	 * watchdog.setDestructor( context => {
	 * 	// Do something before the context is destroyed.
	 *
	 * 	return context
	 * 		.destroy()
	 * 		.then( () => {
	 * 			// Do something after the context is destroyed.
	 * 		} );
	 * } );
	 * ```
	 */ setDestructor(destructor) {
        this._destructor = destructor;
    }
    /**
	 * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,
	 * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.
	 */ get context() {
        return this._context;
    }
    /**
	 * Initializes the context watchdog. Once it is created, the watchdog takes care about
	 * recreating the context and the provided items, and starts the error handling mechanism.
	 *
	 * ```ts
	 * await watchdog.create( {
	 * 	plugins: []
	 * } );
	 * ```
	 *
	 * @param contextConfig The context configuration. See {@link module:core/context~Context}.
	 */ create(contextConfig = {}) {
        return this._actionQueues.enqueue(mainQueueId, ()=>{
            this._contextConfig = contextConfig;
            return this._create();
        });
    }
    /**
	 * Returns an item instance with the given `itemId`.
	 *
	 * ```ts
	 * const editor1 = watchdog.getItem( 'editor1' );
	 * ```
	 *
	 * @param itemId The item ID.
	 * @returns The item instance or `undefined` if an item with a given ID has not been found.
	 */ getItem(itemId) {
        const watchdog = this._getWatchdog(itemId);
        return watchdog._item;
    }
    /**
	 * Gets the state of the given item. See {@link #state} for a list of available states.
	 *
	 * ```ts
	 * const editor1State = watchdog.getItemState( 'editor1' );
	 * ```
	 *
	 * @param itemId Item ID.
	 * @returns The state of the item.
	 */ getItemState(itemId) {
        const watchdog = this._getWatchdog(itemId);
        return watchdog.state;
    }
    /**
	 * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.
	 *
	 * Items can be passed together as an array of objects:
	 *
	 * ```ts
	 * await watchdog.add( [ {
	 * 	id: 'editor1',
	 * 	type: 'editor',
	 * 	sourceElementOrData: document.querySelector( '#editor' ),
	 * 	config: {
	 * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
	 * 		toolbar: [ 'bold', 'italic', 'alignment' ]
	 * 	},
	 * 	creator: ( element, config ) => ClassicEditor.create( element, config )
	 * } ] );
	 * ```
	 *
	 * Or one by one as objects:
	 *
	 * ```ts
	 * await watchdog.add( {
	 * 	id: 'editor1',
	 * 	type: 'editor',
	 * 	sourceElementOrData: document.querySelector( '#editor' ),
	 * 	config: {
	 * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
	 * 		toolbar: [ 'bold', 'italic', 'alignment' ]
	 * 	},
	 * 	creator: ( element, config ) => ClassicEditor.create( element, config )
	 * ] );
	 * ```
	 *
	 * Then an instance can be retrieved using the {@link #getItem} method:
	 *
	 * ```ts
	 * const editor1 = watchdog.getItem( 'editor1' );
	 * ```
	 *
	 * Note that this method can be called multiple times, but for performance reasons it is better
	 * to pass all items together.
	 *
	 * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.
	 */ add(itemConfigurationOrItemConfigurations) {
        const itemConfigurations = toArray(itemConfigurationOrItemConfigurations);
        return Promise.all(itemConfigurations.map((item)=>{
            return this._actionQueues.enqueue(item.id, ()=>{
                if (this.state === 'destroyed') {
                    throw new Error('Cannot add items to destroyed watchdog.');
                }
                if (!this._context) {
                    throw new Error('Context was not created yet. You should call the `ContextWatchdog#create()` method first.');
                }
                let watchdog;
                if (this._watchdogs.has(item.id)) {
                    throw new Error(`Item with the given id is already added: '${item.id}'.`);
                }
                if (item.type === 'editor') {
                    watchdog = new EditorWatchdog(null, this._watchdogConfig);
                    watchdog.setCreator(item.creator);
                    watchdog._setExcludedProperties(this._contextProps);
                    if (item.destructor) {
                        watchdog.setDestructor(item.destructor);
                    }
                    this._watchdogs.set(item.id, watchdog);
                    // Enqueue the internal watchdog errors within the main queue.
                    // And propagate the internal `error` events as `itemError` event.
                    watchdog.on('error', (evt, { error, causesRestart })=>{
                        this._fire('itemError', {
                            itemId: item.id,
                            error
                        });
                        // Do not enqueue the item restart action if the item will not restart.
                        if (!causesRestart) {
                            return;
                        }
                        this._actionQueues.enqueue(item.id, ()=>new Promise((res)=>{
                                const rethrowRestartEventOnce = ()=>{
                                    watchdog.off('restart', rethrowRestartEventOnce);
                                    this._fire('itemRestart', {
                                        itemId: item.id
                                    });
                                    res();
                                };
                                watchdog.on('restart', rethrowRestartEventOnce);
                            }));
                    });
                    return watchdog.create(item.sourceElementOrData, item.config, this._context);
                } else {
                    throw new Error(`Not supported item type: '${item.type}'.`);
                }
            });
        }));
    }
    /**
	 * Removes and destroys item(s) with given ID(s).
	 *
	 * ```ts
	 * await watchdog.remove( 'editor1' );
	 * ```
	 *
	 * Or
	 *
	 * ```ts
	 * await watchdog.remove( [ 'editor1', 'editor2' ] );
	 * ```
	 *
	 * @param itemIdOrItemIds Item ID or an array of item IDs.
	 */ remove(itemIdOrItemIds) {
        const itemIds = toArray(itemIdOrItemIds);
        return Promise.all(itemIds.map((itemId)=>{
            return this._actionQueues.enqueue(itemId, ()=>{
                const watchdog = this._getWatchdog(itemId);
                this._watchdogs.delete(itemId);
                return watchdog.destroy();
            });
        }));
    }
    /**
	 * Destroys the context watchdog and all added items.
	 * Once the context watchdog is destroyed, new items cannot be added.
	 *
	 * ```ts
	 * await watchdog.destroy();
	 * ```
	 */ destroy() {
        return this._actionQueues.enqueue(mainQueueId, ()=>{
            this.state = 'destroyed';
            this._fire('stateChange');
            super.destroy();
            return this._destroy();
        });
    }
    /**
	 * Restarts the context watchdog.
	 */ _restart() {
        return this._actionQueues.enqueue(mainQueueId, ()=>{
            this.state = 'initializing';
            this._fire('stateChange');
            return this._destroy().catch((err)=>{
                console.error('An error happened during destroying the context or items.', err);
            }).then(()=>this._create()).then(()=>this._fire('restart'));
        });
    }
    /**
	 * Initializes the context watchdog.
	 */ _create() {
        return Promise.resolve().then(()=>{
            this._startErrorHandling();
            return this._creator(this._contextConfig);
        }).then((context)=>{
            this._context = context;
            this._contextProps = getSubNodes(this._context);
            return Promise.all(Array.from(this._watchdogs.values()).map((watchdog)=>{
                watchdog._setExcludedProperties(this._contextProps);
                return watchdog.create(undefined, undefined, this._context);
            }));
        });
    }
    /**
	 * Destroys the context instance and all added items.
	 */ _destroy() {
        return Promise.resolve().then(()=>{
            this._stopErrorHandling();
            const context = this._context;
            this._context = null;
            this._contextProps = new Set();
            return Promise.all(Array.from(this._watchdogs.values()).map((watchdog)=>watchdog.destroy())) // Context destructor destroys each editor.
            .then(()=>this._destructor(context));
        });
    }
    /**
	 * Returns the watchdog for a given item ID.
	 *
	 * @param itemId Item ID.
	 */ _getWatchdog(itemId) {
        const watchdog = this._watchdogs.get(itemId);
        if (!watchdog) {
            throw new Error(`Item with the given id was not registered: ${itemId}.`);
        }
        return watchdog;
    }
    /**
	 * Checks whether an error comes from the context instance and not from the item instances.
	 *
	 * @internal
	 */ _isErrorComingFromThisItem(error) {
        for (const watchdog of this._watchdogs.values()){
            if (watchdog._isErrorComingFromThisItem(error)) {
                return false;
            }
        }
        return areConnectedThroughProperties(this._context, error.context);
    }
}
/**
 * Manager of action queues that allows queuing async functions.
 */ class ActionQueues {
    _onEmptyCallbacks = [];
    _queues = new Map();
    _activeActions = 0;
    /**
	 * Used to register callbacks that will be run when the queue becomes empty.
	 *
	 * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.
	 */ onEmpty(onEmptyCallback) {
        this._onEmptyCallbacks.push(onEmptyCallback);
    }
    /**
	 * It adds asynchronous actions (functions) to the proper queue and runs them one by one.
	 *
	 * @param queueId The action queue ID.
	 * @param action A function that should be enqueued.
	 */ enqueue(queueId, action) {
        const isMainAction = queueId === mainQueueId;
        this._activeActions++;
        if (!this._queues.get(queueId)) {
            this._queues.set(queueId, Promise.resolve());
        }
        // List all sources of actions that the current action needs to await for.
        // For the main action wait for all other actions.
        // For the item action wait only for the item queue and the main queue.
        const awaitedActions = isMainAction ? Promise.all(this._queues.values()) : Promise.all([
            this._queues.get(mainQueueId),
            this._queues.get(queueId)
        ]);
        const queueWithAction = awaitedActions.then(action);
        // Catch all errors in the main queue to stack promises even if an error occurred in the past.
        const nonErrorQueue = queueWithAction.catch(()=>{});
        this._queues.set(queueId, nonErrorQueue);
        return queueWithAction.finally(()=>{
            this._activeActions--;
            if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {
                this._onEmptyCallbacks.forEach((cb)=>cb());
            }
        });
    }
}
/**
 * Transforms any value to an array. If the provided value is already an array, it is returned unchanged.
 *
 * @param elementOrArray The value to transform to an array.
 * @returns An array created from data.
 */ function toArray(elementOrArray) {
    return Array.isArray(elementOrArray) ? elementOrArray : [
        elementOrArray
    ];
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-upload/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Base64UploadAdapter": (()=>Base64UploadAdapter),
    "FileRepository": (()=>FileRepository),
    "SimpleUploadAdapter": (()=>SimpleUploadAdapter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
;
;
/**
 * Wrapper over the native `FileReader`.
 */ class FileReader extends /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObservableMixin"])() {
    total;
    /**
	 * Instance of native FileReader.
	 */ _reader;
    /**
	 * Holds the data of an already loaded file. The file must be first loaded
	 * by using {@link module:upload/filereader~FileReader#read `read()`}.
	 */ _data;
    /**
	 * Creates an instance of the FileReader.
	 */ constructor(){
        super();
        const reader = new window.FileReader();
        this._reader = reader;
        this._data = undefined;
        this.set('loaded', 0);
        reader.onprogress = (evt)=>{
            this.loaded = evt.loaded;
        };
    }
    /**
	 * Returns error that occurred during file reading.
	 */ get error() {
        return this._reader.error;
    }
    /**
	 * Holds the data of an already loaded file. The file must be first loaded
	 * by using {@link module:upload/filereader~FileReader#read `read()`}.
	 */ get data() {
        return this._data;
    }
    /**
	 * Reads the provided file.
	 *
	 * @param file Native File object.
	 * @returns Returns a promise that will be resolved with file's content.
	 * The promise will be rejected in case of an error or when the reading process is aborted.
	 */ read(file) {
        const reader = this._reader;
        this.total = file.size;
        return new Promise((resolve, reject)=>{
            reader.onload = ()=>{
                const result = reader.result;
                this._data = result;
                resolve(result);
            };
            reader.onerror = ()=>{
                reject('error');
            };
            reader.onabort = ()=>{
                reject('aborted');
            };
            this._reader.readAsDataURL(file);
        });
    }
    /**
	 * Aborts file reader.
	 */ abort() {
        this._reader.abort();
    }
}
/**
 * File repository plugin. A central point for managing file upload.
 *
 * To use it, first you need an upload adapter. Upload adapter's job is to handle communication with the server
 * (sending the file and handling server's response). You can use one of the existing plugins introducing upload adapters
 * (e.g. {@link module:easy-image/cloudservicesuploadadapter~CloudServicesUploadAdapter} or
 * {@link module:adapter-ckfinder/uploadadapter~CKFinderUploadAdapter}) or write your own one – see
 * the {@glink framework/deep-dive/upload-adapter Custom image upload adapter deep-dive} guide.
 *
 * Then, you can use {@link module:upload/filerepository~FileRepository#createLoader `createLoader()`} and the returned
 * {@link module:upload/filerepository~FileLoader} instance to load and upload files.
 */ class FileRepository extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * Collection of loaders associated with this repository.
	 */ loaders = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"]();
    /**
	 * Loaders mappings used to retrieve loaders references.
	 */ _loadersMap = new Map();
    /**
	 * Reference to a pending action registered in a {@link module:core/pendingactions~PendingActions} plugin
	 * while upload is in progress. When there is no upload then value is `null`.
	 */ _pendingAction = null;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FileRepository';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PendingActions"]
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        // Keeps upload in a sync with pending actions.
        this.loaders.on('change', ()=>this._updatePendingAction());
        this.set('uploaded', 0);
        this.set('uploadTotal', null);
        this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', (uploaded, total)=>{
            return total ? uploaded / total * 100 : 0;
        });
    }
    /**
	 * Returns the loader associated with specified file or promise.
	 *
	 * To get loader by id use `fileRepository.loaders.get( id )`.
	 *
	 * @param fileOrPromise Native file or promise handle.
	 */ getLoader(fileOrPromise) {
        return this._loadersMap.get(fileOrPromise) || null;
    }
    /**
	 * Creates a loader instance for the given file.
	 *
	 * Requires {@link #createUploadAdapter} factory to be defined.
	 *
	 * @param fileOrPromise Native File object or native Promise object which resolves to a File.
	 */ createLoader(fileOrPromise) {
        if (!this.createUploadAdapter) {
            /**
			 * You need to enable an upload adapter in order to be able to upload files.
			 *
			 * This warning shows up when {@link module:upload/filerepository~FileRepository} is being used
			 * without {@link module:upload/filerepository~FileRepository#createUploadAdapter defining an upload adapter}.
			 *
			 * **If you see this warning when using one of the {@glink getting-started/legacy/installation-methods/predefined-builds
			 * CKEditor 5 Builds}**
			 * it means that you did not configure any of the upload adapters available by default in those builds.
			 *
			 * Predefined builds are a deprecated solution and we strongly advise
			 * {@glink updating/nim-migration/migration-to-new-installation-methods migrating to new installation methods}.
			 *
			 * See the {@glink features/images/image-upload/image-upload comprehensive "Image upload overview"} to learn which upload
			 * adapters are available in the builds and how to configure them.
			 *
			 * Otherwise, if you see this warning, there is a chance that you enabled
			 * a feature like {@link module:image/imageupload~ImageUpload},
			 * or {@link module:image/imageupload/imageuploadui~ImageUploadUI} but you did not enable any upload adapter.
			 * You can choose one of the existing upload adapters listed in the
			 * {@glink features/images/image-upload/image-upload "Image upload overview"}.
			 *
			 * You can also implement your {@glink framework/deep-dive/upload-adapter own image upload adapter}.
			 *
			 * @error filerepository-no-upload-adapter
			 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('filerepository-no-upload-adapter');
            return null;
        }
        const loader = new FileLoader(Promise.resolve(fileOrPromise), this.createUploadAdapter);
        this.loaders.add(loader);
        this._loadersMap.set(fileOrPromise, loader);
        // Store also file => loader mapping so loader can be retrieved by file instance returned upon Promise resolution.
        if (fileOrPromise instanceof Promise) {
            loader.file.then((file)=>{
                this._loadersMap.set(file, loader);
            }) // Every then() must have a catch().
            // File loader state (and rejections) are handled in read() and upload().
            // Also, see the "does not swallow the file promise rejection" test.
            .catch(()=>{});
        }
        loader.on('change:uploaded', ()=>{
            let aggregatedUploaded = 0;
            for (const loader of this.loaders){
                aggregatedUploaded += loader.uploaded;
            }
            this.uploaded = aggregatedUploaded;
        });
        loader.on('change:uploadTotal', ()=>{
            let aggregatedTotal = 0;
            for (const loader of this.loaders){
                if (loader.uploadTotal) {
                    aggregatedTotal += loader.uploadTotal;
                }
            }
            this.uploadTotal = aggregatedTotal;
        });
        return loader;
    }
    /**
	 * Destroys the given loader.
	 *
	 * @param fileOrPromiseOrLoader File or Promise associated with that loader or loader itself.
	 */ destroyLoader(fileOrPromiseOrLoader) {
        const loader = fileOrPromiseOrLoader instanceof FileLoader ? fileOrPromiseOrLoader : this.getLoader(fileOrPromiseOrLoader);
        loader._destroy();
        this.loaders.remove(loader);
        this._loadersMap.forEach((value, key)=>{
            if (value === loader) {
                this._loadersMap.delete(key);
            }
        });
    }
    /**
	 * Registers or deregisters pending action bound with upload progress.
	 */ _updatePendingAction() {
        const pendingActions = this.editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PendingActions"]);
        if (this.loaders.length) {
            if (!this._pendingAction) {
                const t = this.editor.t;
                const getMessage = (value)=>`${t('Upload in progress')} ${parseInt(value)}%.`;
                this._pendingAction = pendingActions.add(getMessage(this.uploadedPercent));
                this._pendingAction.bind('message').to(this, 'uploadedPercent', getMessage);
            }
        } else {
            pendingActions.remove(this._pendingAction);
            this._pendingAction = null;
        }
    }
}
/**
 * File loader class.
 *
 * It is used to control the process of reading the file and uploading it using the specified upload adapter.
 */ class FileLoader extends /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObservableMixin"])() {
    /**
	 * Unique id of FileLoader instance.
	 *
	 * @readonly
	 */ id;
    /**
	 * Additional wrapper over the initial file promise passed to this loader.
	 */ _filePromiseWrapper;
    /**
	 * Adapter instance associated with this file loader.
	 */ _adapter;
    /**
	 * FileReader used by FileLoader.
	 */ _reader;
    /**
	 * Creates a new instance of `FileLoader`.
	 *
	 * @param filePromise A promise which resolves to a file instance.
	 * @param uploadAdapterCreator The function which returns {@link module:upload/filerepository~UploadAdapter} instance.
	 */ constructor(filePromise, uploadAdapterCreator){
        super();
        this.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])();
        this._filePromiseWrapper = this._createFilePromiseWrapper(filePromise);
        this._adapter = uploadAdapterCreator(this);
        this._reader = new FileReader();
        this.set('status', 'idle');
        this.set('uploaded', 0);
        this.set('uploadTotal', null);
        this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', (uploaded, total)=>{
            return total ? uploaded / total * 100 : 0;
        });
        this.set('uploadResponse', null);
    }
    /**
	 * A `Promise` which resolves to a `File` instance associated with this file loader.
	 */ get file() {
        if (!this._filePromiseWrapper) {
            // Loader was destroyed, return promise which resolves to null.
            return Promise.resolve(null);
        } else {
            // The `this._filePromiseWrapper.promise` is chained and not simply returned to handle a case when:
            //
            //		* The `loader.file.then( ... )` is called by external code (returned promise is pending).
            //		* Then `loader._destroy()` is called (call is synchronous) which destroys the `loader`.
            //		* Promise returned by the first `loader.file.then( ... )` call is resolved.
            //
            // Returning `this._filePromiseWrapper.promise` will still resolve to a `File` instance so there
            // is an additional check needed in the chain to see if `loader` was destroyed in the meantime.
            return this._filePromiseWrapper.promise.then((file)=>this._filePromiseWrapper ? file : null);
        }
    }
    /**
	 * Returns the file data. To read its data, you need for first load the file
	 * by using the {@link module:upload/filerepository~FileLoader#read `read()`} method.
	 */ get data() {
        return this._reader.data;
    }
    /**
	 * Reads file using {@link module:upload/filereader~FileReader}.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-read-wrong-status` when status
	 * is different than `idle`.
	 *
	 * Example usage:
	 *
	 * ```ts
	 * fileLoader.read()
	 * 	.then( data => { ... } )
	 * 	.catch( err => {
	 * 		if ( err === 'aborted' ) {
	 * 			console.log( 'Reading aborted.' );
	 * 		} else {
	 * 			console.log( 'Reading error.', err );
	 * 		}
	 * 	} );
	 * ```
	 *
	 * @returns Returns promise that will be resolved with read data. Promise will be rejected if error
	 * occurs or if read process is aborted.
	 */ read() {
        if (this.status != 'idle') {
            /**
			 * You cannot call read if the status is different than idle.
			 *
			 * @error filerepository-read-wrong-status
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('filerepository-read-wrong-status', this);
        }
        this.status = 'reading';
        return this.file.then((file)=>this._reader.read(file)).then((data)=>{
            // Edge case: reader was aborted after file was read - double check for proper status.
            // It can happen when image was deleted during its upload.
            if (this.status !== 'reading') {
                throw this.status;
            }
            this.status = 'idle';
            return data;
        }).catch((err)=>{
            if (err === 'aborted') {
                this.status = 'aborted';
                throw 'aborted';
            }
            this.status = 'error';
            throw this._reader.error ? this._reader.error : err;
        });
    }
    /**
	 * Reads file using the provided {@link module:upload/filerepository~UploadAdapter}.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-upload-wrong-status` when status
	 * is different than `idle`.
	 * Example usage:
	 *
	 * ```ts
	 * fileLoader.upload()
	 * 	.then( data => { ... } )
	 * 	.catch( e => {
	 * 		if ( e === 'aborted' ) {
	 * 			console.log( 'Uploading aborted.' );
	 * 		} else {
	 * 			console.log( 'Uploading error.', e );
	 * 		}
	 * 	} );
	 * ```
	 *
	 * @returns Returns promise that will be resolved with response data. Promise will be rejected if error
	 * occurs or if read process is aborted.
	 */ upload() {
        if (this.status != 'idle') {
            /**
			 * You cannot call upload if the status is different than idle.
			 *
			 * @error filerepository-upload-wrong-status
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('filerepository-upload-wrong-status', this);
        }
        this.status = 'uploading';
        return this.file.then(()=>this._adapter.upload()).then((data)=>{
            this.uploadResponse = data;
            this.status = 'idle';
            return data;
        }).catch((err)=>{
            if (this.status === 'aborted') {
                throw 'aborted';
            }
            this.status = 'error';
            throw err;
        });
    }
    /**
	 * Aborts loading process.
	 */ abort() {
        const status = this.status;
        this.status = 'aborted';
        if (!this._filePromiseWrapper.isFulfilled) {
            // Edge case: file loader is aborted before read() is called
            // so it might happen that no one handled the rejection of this promise.
            // See https://github.com/ckeditor/ckeditor5-upload/pull/100
            this._filePromiseWrapper.promise.catch(()=>{});
            this._filePromiseWrapper.rejecter('aborted');
        } else if (status == 'reading') {
            this._reader.abort();
        } else if (status == 'uploading' && this._adapter.abort) {
            this._adapter.abort();
        }
        this._destroy();
    }
    /**
	 * Performs cleanup.
	 *
	 * @internal
	 */ _destroy() {
        this._filePromiseWrapper = undefined;
        this._reader = undefined;
        this._adapter = undefined;
        this.uploadResponse = undefined;
    }
    /**
	 * Wraps a given file promise into another promise giving additional
	 * control (resolving, rejecting, checking if fulfilled) over it.
	 *
	 * @param filePromise The initial file promise to be wrapped.
	 */ _createFilePromiseWrapper(filePromise) {
        const wrapper = {};
        wrapper.promise = new Promise((resolve, reject)=>{
            wrapper.rejecter = reject;
            wrapper.isFulfilled = false;
            filePromise.then((file)=>{
                wrapper.isFulfilled = true;
                resolve(file);
            }).catch((err)=>{
                wrapper.isFulfilled = true;
                reject(err);
            });
        });
        return wrapper;
    }
}
/**
 * A plugin that converts images inserted into the editor into [Base64 strings](https://en.wikipedia.org/wiki/Base64)
 * in the {@glink getting-started/setup/getting-and-setting-data editor output}.
 *
 * This kind of image upload does not require server processing – images are stored with the rest of the text and
 * displayed by the web browser without additional requests.
 *
 * Check out the {@glink features/images/image-upload/image-upload comprehensive "Image upload overview"} to learn about
 * other ways to upload images into CKEditor 5.
 */ class Base64UploadAdapter extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            FileRepository
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Base64UploadAdapter';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        this.editor.plugins.get(FileRepository).createUploadAdapter = (loader)=>new Adapter$1(loader);
    }
}
/**
 * The upload adapter that converts images inserted into the editor into Base64 strings.
 */ let Adapter$1 = class Adapter {
    /**
	 * `FileLoader` instance to use during the upload.
	 */ loader;
    reader;
    /**
	 * Creates a new adapter instance.
	 */ constructor(loader){
        this.loader = loader;
    }
    /**
	 * Starts the upload process.
	 *
	 * @see module:upload/filerepository~UploadAdapter#upload
	 */ upload() {
        return new Promise((resolve, reject)=>{
            const reader = this.reader = new window.FileReader();
            reader.addEventListener('load', ()=>{
                resolve({
                    default: reader.result
                });
            });
            reader.addEventListener('error', (err)=>{
                reject(err);
            });
            reader.addEventListener('abort', ()=>{
                reject();
            });
            this.loader.file.then((file)=>{
                reader.readAsDataURL(file);
            });
        });
    }
    /**
	 * Aborts the upload process.
	 *
	 * @see module:upload/filerepository~UploadAdapter#abort
	 */ abort() {
        this.reader.abort();
    }
};
/**
 * The Simple upload adapter allows uploading images to an application running on your server using
 * the [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) API with a
 * minimal {@link module:upload/uploadconfig~SimpleUploadConfig editor configuration}.
 *
 * ```ts
 * ClassicEditor
 * 	.create( document.querySelector( '#editor' ), {
 * 		simpleUpload: {
 * 			uploadUrl: 'http://example.com',
 * 			headers: {
 * 				...
 * 			}
 * 		}
 * 	} )
 * 	.then( ... )
 * 	.catch( ... );
 * ```
 *
 * See the {@glink features/images/image-upload/simple-upload-adapter "Simple upload adapter"} guide to learn how to
 * learn more about the feature (configuration, server–side requirements, etc.).
 *
 * Check out the {@glink features/images/image-upload/image-upload comprehensive "Image upload overview"} to learn about
 * other ways to upload images into CKEditor 5.
 */ class SimpleUploadAdapter extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            FileRepository
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SimpleUploadAdapter';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const options = this.editor.config.get('simpleUpload');
        if (!options) {
            return;
        }
        if (!options.uploadUrl) {
            /**
			 * The {@link module:upload/uploadconfig~SimpleUploadConfig#uploadUrl `config.simpleUpload.uploadUrl`}
			 * configuration required by the {@link module:upload/adapters/simpleuploadadapter~SimpleUploadAdapter `SimpleUploadAdapter`}
			 * is missing. Make sure the correct URL is specified for the image upload to work properly.
			 *
			 * @error simple-upload-adapter-missing-uploadurl
			 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('simple-upload-adapter-missing-uploadurl');
            return;
        }
        this.editor.plugins.get(FileRepository).createUploadAdapter = (loader)=>{
            return new Adapter(loader, options);
        };
    }
}
/**
 * Upload adapter.
 */ class Adapter {
    /**
	 * FileLoader instance to use during the upload.
	 */ loader;
    /**
	 * The configuration of the adapter.
	 */ options;
    xhr;
    /**
	 * Creates a new adapter instance.
	 */ constructor(loader, options){
        this.loader = loader;
        this.options = options;
    }
    /**
	 * Starts the upload process.
	 *
	 * @see module:upload/filerepository~UploadAdapter#upload
	 */ upload() {
        return this.loader.file.then((file)=>new Promise((resolve, reject)=>{
                this._initRequest();
                this._initListeners(resolve, reject, file);
                this._sendRequest(file);
            }));
    }
    /**
	 * Aborts the upload process.
	 *
	 * @see module:upload/filerepository~UploadAdapter#abort
	 */ abort() {
        if (this.xhr) {
            this.xhr.abort();
        }
    }
    /**
	 * Initializes the `XMLHttpRequest` object using the URL specified as
	 * {@link module:upload/uploadconfig~SimpleUploadConfig#uploadUrl `simpleUpload.uploadUrl`} in the editor's
	 * configuration.
	 */ _initRequest() {
        const xhr = this.xhr = new XMLHttpRequest();
        xhr.open('POST', this.options.uploadUrl, true);
        xhr.responseType = 'json';
    }
    /**
	 * Initializes XMLHttpRequest listeners
	 *
	 * @param resolve Callback function to be called when the request is successful.
	 * @param reject Callback function to be called when the request cannot be completed.
	 * @param file Native File object.
	 */ _initListeners(resolve, reject, file) {
        const xhr = this.xhr;
        const loader = this.loader;
        const genericErrorText = `Couldn't upload file: ${file.name}.`;
        xhr.addEventListener('error', ()=>reject(genericErrorText));
        xhr.addEventListener('abort', ()=>reject());
        xhr.addEventListener('load', ()=>{
            const response = xhr.response;
            if (!response || response.error) {
                return reject(response && response.error && response.error.message ? response.error.message : genericErrorText);
            }
            const urls = response.url ? {
                default: response.url
            } : response.urls;
            // Resolve with the normalized `urls` property and pass the rest of the response
            // to allow customizing the behavior of features relying on the upload adapters.
            resolve({
                ...response,
                urls
            });
        });
        // Upload progress when it is supported.
        /* istanbul ignore else -- @preserve */ if (xhr.upload) {
            xhr.upload.addEventListener('progress', (evt)=>{
                if (evt.lengthComputable) {
                    loader.uploadTotal = evt.total;
                    loader.uploaded = evt.loaded;
                }
            });
        }
    }
    /**
	 * Prepares the data and sends the request.
	 *
	 * @param file File instance to be uploaded.
	 */ _sendRequest(file) {
        // Set headers if specified.
        let headers = this.options.headers || {};
        if (typeof headers === 'function') {
            headers = headers(file);
        }
        // Use the withCredentials flag if specified.
        const withCredentials = this.options.withCredentials || false;
        for (const headerName of Object.keys(headers)){
            this.xhr.setRequestHeader(headerName, headers[headerName]);
        }
        this.xhr.withCredentials = withCredentials;
        // Prepare the form data.
        const data = new FormData();
        data.append('upload', file);
        // Send the request.
        this.xhr.send(data);
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-adapter-ckfinder/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "CKFinderUploadAdapter": (()=>CKFinderUploadAdapter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$upload$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-upload/dist/index.js [app-client] (ecmascript)");
;
;
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /* globals window, document */ /**
 * @module adapter-ckfinder/utils
 */ const TOKEN_COOKIE_NAME = 'ckCsrfToken';
const TOKEN_LENGTH = 40;
const tokenCharset = 'abcdefghijklmnopqrstuvwxyz0123456789';
/**
 * Returns the CSRF token value. The value is a hash stored in `document.cookie`
 * under the `ckCsrfToken` key. The CSRF token can be used to secure the communication
 * between the web browser and the CKFinder server.
 */ function getCsrfToken() {
    let token = getCookie(TOKEN_COOKIE_NAME);
    if (!token || token.length != TOKEN_LENGTH) {
        token = generateToken(TOKEN_LENGTH);
        setCookie(TOKEN_COOKIE_NAME, token);
    }
    return token;
}
/**
 * Returns the value of the cookie with a given name or `null` if the cookie is not found.
 */ function getCookie(name) {
    name = name.toLowerCase();
    const parts = document.cookie.split(';');
    for (const part of parts){
        const pair = part.split('=');
        const key = decodeURIComponent(pair[0].trim().toLowerCase());
        if (key === name) {
            return decodeURIComponent(pair[1]);
        }
    }
    return null;
}
/**
 * Sets the value of the cookie with a given name.
 */ function setCookie(name, value) {
    document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value) + ';path=/';
}
/**
 * Generates the CSRF token with the given length.
 */ function generateToken(length) {
    let result = '';
    const randValues = new Uint8Array(length);
    window.crypto.getRandomValues(randValues);
    for(let j = 0; j < randValues.length; j++){
        const character = tokenCharset.charAt(randValues[j] % tokenCharset.length);
        result += Math.random() > 0.5 ? character.toUpperCase() : character;
    }
    return result;
}
/**
 * A plugin that enables file uploads in CKEditor 5 using the CKFinder server–side connector.
 *
 * See the {@glink features/file-management/ckfinder "CKFinder file manager integration"} guide to learn how to configure
 * and use this feature as well as find out more about the full integration with the file manager
 * provided by the {@link module:ckfinder/ckfinder~CKFinder} plugin.
 *
 * Check out the {@glink features/images/image-upload/image-upload comprehensive "Image upload overview"} guide to learn
 * about other ways to upload images into CKEditor 5.
 */ class CKFinderUploadAdapter extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$upload$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileRepository"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CKFinderUploadAdapter';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const url = this.editor.config.get('ckfinder.uploadUrl');
        if (!url) {
            return;
        }
        // Register CKFinderAdapter
        this.editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$upload$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileRepository"]).createUploadAdapter = (loader)=>new UploadAdapter(loader, url, this.editor.t);
    }
}
/**
 * Upload adapter for CKFinder.
 */ class UploadAdapter {
    /**
	 * FileLoader instance to use during the upload.
	 */ loader;
    /**
	 * Upload URL.
	 */ url;
    /**
	 * Locale translation method.
	 */ t;
    xhr;
    /**
	 * Creates a new adapter instance.
	 */ constructor(loader, url, t){
        this.loader = loader;
        this.url = url;
        this.t = t;
    }
    /**
	 * Starts the upload process.
	 *
	 * @see module:upload/filerepository~UploadAdapter#upload
	 */ upload() {
        return this.loader.file.then((file)=>{
            return new Promise((resolve, reject)=>{
                this._initRequest();
                this._initListeners(resolve, reject, file);
                this._sendRequest(file);
            });
        });
    }
    /**
	 * Aborts the upload process.
	 *
	 * @see module:upload/filerepository~UploadAdapter#abort
	 */ abort() {
        if (this.xhr) {
            this.xhr.abort();
        }
    }
    /**
	 * Initializes the XMLHttpRequest object.
	 */ _initRequest() {
        const xhr = this.xhr = new XMLHttpRequest();
        xhr.open('POST', this.url, true);
        xhr.responseType = 'json';
    }
    /**
	 * Initializes XMLHttpRequest listeners.
	 *
	 * @param resolve Callback function to be called when the request is successful.
	 * @param reject Callback function to be called when the request cannot be completed.
	 * @param file File instance to be uploaded.
	 */ _initListeners(resolve, reject, file) {
        const xhr = this.xhr;
        const loader = this.loader;
        const t = this.t;
        const genericError = t('Cannot upload file:') + ` ${file.name}.`;
        xhr.addEventListener('error', ()=>reject(genericError));
        xhr.addEventListener('abort', ()=>reject());
        xhr.addEventListener('load', ()=>{
            const response = xhr.response;
            if (!response || !response.uploaded) {
                return reject(response && response.error && response.error.message ? response.error.message : genericError);
            }
            resolve({
                default: response.url
            });
        });
        // Upload progress when it's supported.
        /* istanbul ignore else -- @preserve */ if (xhr.upload) {
            xhr.upload.addEventListener('progress', (evt)=>{
                if (evt.lengthComputable) {
                    loader.uploadTotal = evt.total;
                    loader.uploaded = evt.loaded;
                }
            });
        }
    }
    /**
	 * Prepares the data and sends the request.
	 *
	 * @param file File instance to be uploaded.
	 */ _sendRequest(file) {
        // Prepare form data.
        const data = new FormData();
        data.append('upload', file);
        data.append('ckCsrfToken', getCsrfToken());
        // Send request.
        this.xhr.send(data);
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-alignment/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Alignment": (()=>Alignment),
    "AlignmentEditing": (()=>AlignmentEditing),
    "AlignmentUI": (()=>AlignmentUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
;
;
;
/**
 * @module alignment/utils
 */ /**
 * The list of supported alignment options:
 *
 * * `'left'`,
 * * `'right'`,
 * * `'center'`,
 * * `'justify'`
 */ const supportedOptions = [
    'left',
    'right',
    'center',
    'justify'
];
/**
 * Checks whether the passed option is supported by {@link module:alignment/alignmentediting~AlignmentEditing}.
 *
 * @param option The option value to check.
 */ function isSupported(option) {
    return supportedOptions.includes(option);
}
/**
 * Checks whether alignment is the default one considering the direction
 * of the editor content.
 *
 * @param alignment The name of the alignment to check.
 * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
 */ function isDefault(alignment, locale) {
    // Right now only LTR is supported so the 'left' value is always the default one.
    if (locale.contentLanguageDirection == 'rtl') {
        return alignment === 'right';
    } else {
        return alignment === 'left';
    }
}
/**
 * Brings the configuration to the common form, an array of objects.
 *
 * @param configuredOptions Alignment plugin configuration.
 * @returns Normalized object holding the configuration.
 */ function normalizeAlignmentOptions(configuredOptions) {
    const normalizedOptions = configuredOptions.map((option)=>{
        let result;
        if (typeof option == 'string') {
            result = {
                name: option
            };
        } else {
            result = option;
        }
        return result;
    }) // Remove all unknown options.
    .filter((option)=>{
        const isNameValid = supportedOptions.includes(option.name);
        if (!isNameValid) {
            /**
				 * The `name` in one of the `alignment.options` is not recognized.
				 * The available options are: `'left'`, `'right'`, `'center'` and `'justify'`.
				 *
				 * @error alignment-config-name-not-recognized
				 * @param option Options with unknown value of the `name` property.
				 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('alignment-config-name-not-recognized', {
                option
            });
        }
        return isNameValid;
    });
    const classNameCount = normalizedOptions.filter((option)=>Boolean(option.className)).length;
    // We either use classes for all styling options or for none.
    if (classNameCount && classNameCount < normalizedOptions.length) {
        /**
		 * The `className` property has to be defined for all options once at least one option declares `className`.
		 *
		 * @error alignment-config-classnames-are-missing
		 * @param configuredOptions Contents of `alignment.options`.
		 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('alignment-config-classnames-are-missing', {
            configuredOptions
        });
    }
    // Validate resulting config.
    normalizedOptions.forEach((option, index, allOptions)=>{
        const succeedingOptions = allOptions.slice(index + 1);
        const nameAlreadyExists = succeedingOptions.some((item)=>item.name == option.name);
        if (nameAlreadyExists) {
            /**
			 * The same `name` in one of the `alignment.options` was already declared.
			 * Each `name` representing one alignment option can be set exactly once.
			 *
			 * @error alignment-config-name-already-defined
			 * @param option First option that declares given `name`.
			 * @param configuredOptions Contents of `alignment.options`.
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('alignment-config-name-already-defined', {
                option,
                configuredOptions
            });
        }
        // The `className` property is present. Check for duplicates then.
        if (option.className) {
            const classNameAlreadyExists = succeedingOptions.some((item)=>item.className == option.className);
            if (classNameAlreadyExists) {
                /**
				 * The same `className` in one of the `alignment.options` was already declared.
				 *
				 * @error alignment-config-classname-already-defined
				 * @param option First option that declares given `className`.
				 * @param configuredOptions
				 * Contents of `alignment.options`.
				 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('alignment-config-classname-already-defined', {
                    option,
                    configuredOptions
                });
            }
        }
    });
    return normalizedOptions;
}
const ALIGNMENT = 'alignment';
/**
 * The alignment command plugin.
 */ class AlignmentCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ refresh() {
        const editor = this.editor;
        const locale = editor.locale;
        const firstBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(this.editor.model.document.selection.getSelectedBlocks());
        // As first check whether to enable or disable the command as the value will always be false if the command cannot be enabled.
        this.isEnabled = Boolean(firstBlock) && this._canBeAligned(firstBlock);
        if (this.isEnabled && firstBlock.hasAttribute('alignment')) {
            this.value = firstBlock.getAttribute('alignment');
        } else {
            this.value = locale.contentLanguageDirection === 'rtl' ? 'right' : 'left';
        }
    }
    /**
	 * Executes the command. Applies the alignment `value` to the selected blocks.
	 * If no `value` is passed, the `value` is the default one or it is equal to the currently selected block's alignment attribute,
	 * the command will remove the attribute from the selected blocks.
	 *
	 * @param options Options for the executed command.
	 * @param options.value The value to apply.
	 * @fires execute
	 */ execute(options = {}) {
        const editor = this.editor;
        const locale = editor.locale;
        const model = editor.model;
        const doc = model.document;
        const value = options.value;
        model.change((writer)=>{
            // Get only those blocks from selected that can have alignment set
            const blocks = Array.from(doc.selection.getSelectedBlocks()).filter((block)=>this._canBeAligned(block));
            const currentAlignment = blocks[0].getAttribute('alignment');
            // Remove alignment attribute if current alignment is:
            // - default (should not be stored in model as it will bloat model data)
            // - equal to currently set
            // - or no value is passed - denotes default alignment.
            const removeAlignment = isDefault(value, locale) || currentAlignment === value || !value;
            if (removeAlignment) {
                removeAlignmentFromSelection(blocks, writer);
            } else {
                setAlignmentOnSelection(blocks, writer, value);
            }
        });
    }
    /**
	 * Checks whether a block can have alignment set.
	 *
	 * @param block The block to be checked.
	 */ _canBeAligned(block) {
        return this.editor.model.schema.checkAttribute(block, ALIGNMENT);
    }
}
/**
 * Removes the alignment attribute from blocks.
 */ function removeAlignmentFromSelection(blocks, writer) {
    for (const block of blocks){
        writer.removeAttribute(ALIGNMENT, block);
    }
}
/**
 * Sets the alignment attribute on blocks.
 */ function setAlignmentOnSelection(blocks, writer, alignment) {
    for (const block of blocks){
        writer.setAttribute(ALIGNMENT, alignment, block);
    }
}
/**
 * The alignment editing feature. It introduces the {@link module:alignment/alignmentcommand~AlignmentCommand command} and adds
 * the `alignment` attribute for block elements in the {@link module:engine/model/model~Model model}.
 */ class AlignmentEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'AlignmentEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('alignment', {
            options: supportedOptions.map((option)=>({
                    name: option
                }))
        });
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const locale = editor.locale;
        const schema = editor.model.schema;
        const options = normalizeAlignmentOptions(editor.config.get('alignment.options'));
        // Filter out unsupported options and those that are redundant, e.g. `left` in LTR / `right` in RTL mode.
        const optionsToConvert = options.filter((option)=>isSupported(option.name) && !isDefault(option.name, locale));
        // Once there is at least one `className` defined, we switch to alignment with classes.
        const shouldUseClasses = optionsToConvert.some((option)=>!!option.className);
        // Allow alignment attribute on all blocks.
        schema.extend('$block', {
            allowAttributes: 'alignment'
        });
        editor.model.schema.setAttributeProperties('alignment', {
            isFormatting: true
        });
        if (shouldUseClasses) {
            editor.conversion.attributeToAttribute(buildClassDefinition(optionsToConvert));
        } else {
            // Downcast inline styles.
            editor.conversion.for('downcast').attributeToAttribute(buildDowncastInlineDefinition(optionsToConvert));
        }
        const upcastInlineDefinitions = buildUpcastInlineDefinitions(optionsToConvert);
        // Always upcast from inline styles.
        for (const definition of upcastInlineDefinitions){
            editor.conversion.for('upcast').attributeToAttribute(definition);
        }
        const upcastCompatibilityDefinitions = buildUpcastCompatibilityDefinitions(optionsToConvert);
        // Always upcast from deprecated `align` attribute.
        for (const definition of upcastCompatibilityDefinitions){
            editor.conversion.for('upcast').attributeToAttribute(definition);
        }
        editor.commands.add('alignment', new AlignmentCommand(editor));
    }
}
/**
 * Prepare downcast conversion definition for inline alignment styling.
 */ function buildDowncastInlineDefinition(options) {
    const view = {};
    for (const { name } of options){
        view[name] = {
            key: 'style',
            value: {
                'text-align': name
            }
        };
    }
    const definition = {
        model: {
            key: 'alignment',
            values: options.map((option)=>option.name)
        },
        view
    };
    return definition;
}
/**
 * Prepare upcast definitions for inline alignment styles.
 */ function buildUpcastInlineDefinitions(options) {
    const definitions = [];
    for (const { name } of options){
        definitions.push({
            view: {
                key: 'style',
                value: {
                    'text-align': name
                }
            },
            model: {
                key: 'alignment',
                value: name
            }
        });
    }
    return definitions;
}
/**
 * Prepare upcast definitions for deprecated `align` attribute.
 */ function buildUpcastCompatibilityDefinitions(options) {
    const definitions = [];
    for (const { name } of options){
        definitions.push({
            view: {
                key: 'align',
                value: name
            },
            model: {
                key: 'alignment',
                value: name
            }
        });
    }
    return definitions;
}
/**
 * Prepare conversion definitions for upcast and downcast alignment with classes.
 */ function buildClassDefinition(options) {
    const view = {};
    for (const option of options){
        view[option.name] = {
            key: 'class',
            value: option.className
        };
    }
    const definition = {
        model: {
            key: 'alignment',
            values: options.map((option)=>option.name)
        },
        view
    };
    return definition;
}
const iconsMap = /* #__PURE__ */ (()=>new Map([
        [
            'left',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].alignLeft
        ],
        [
            'right',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].alignRight
        ],
        [
            'center',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].alignCenter
        ],
        [
            'justify',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].alignJustify
        ]
    ]))();
/**
 * The default alignment UI plugin.
 *
 * It introduces the `'alignment:left'`, `'alignment:right'`, `'alignment:center'` and `'alignment:justify'` buttons
 * and the `'alignment'` dropdown.
 */ class AlignmentUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * Returns the localized option titles provided by the plugin.
	 *
	 * The following localized titles corresponding with
	 * {@link module:alignment/alignmentconfig~AlignmentConfig#options} are available:
	 *
	 * * `'left'`,
	 * * `'right'`,
	 * * `'center'`,
	 * * `'justify'`.
	 *
	 * @readonly
	 */ get localizedOptionTitles() {
        const t = this.editor.t;
        return {
            'left': t('Align left'),
            'right': t('Align right'),
            'center': t('Align center'),
            'justify': t('Justify')
        };
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'AlignmentUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const options = normalizeAlignmentOptions(editor.config.get('alignment.options'));
        options.map((option)=>option.name).filter(isSupported).forEach((option)=>this._addButton(option));
        this._addToolbarDropdown(options);
        this._addMenuBarMenu(options);
    }
    /**
	 * Helper method for initializing the button and linking it with an appropriate command.
	 *
	 * @param option The name of the alignment option for which the button is added.
	 */ _addButton(option) {
        const editor = this.editor;
        editor.ui.componentFactory.add(`alignment:${option}`, (locale)=>this._createButton(locale, option));
    }
    /**
	 * Helper method for creating the button view element.
	 *
	 * @param locale Editor locale.
	 * @param option The name of the alignment option for which the button is added.
	 * @param buttonAttrs Optional parameters passed to button view instance.
	 */ _createButton(locale, option, buttonAttrs = {}) {
        const editor = this.editor;
        const command = editor.commands.get('alignment');
        const buttonView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](locale);
        buttonView.set({
            label: this.localizedOptionTitles[option],
            icon: iconsMap.get(option),
            tooltip: true,
            isToggleable: true,
            ...buttonAttrs
        });
        // Bind button model to command.
        buttonView.bind('isEnabled').to(command);
        buttonView.bind('isOn').to(command, 'value', (value)=>value === option);
        // Execute command.
        this.listenTo(buttonView, 'execute', ()=>{
            editor.execute('alignment', {
                value: option
            });
            editor.editing.view.focus();
        });
        return buttonView;
    }
    /**
	 * Helper method for initializing the toolnar dropdown and linking it with an appropriate command.
	 *
	 * @param option The name of the alignment option for which the button is added.
	 */ _addToolbarDropdown(options) {
        const editor = this.editor;
        const factory = editor.ui.componentFactory;
        factory.add('alignment', (locale)=>{
            const dropdownView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDropdown"])(locale);
            const tooltipPosition = locale.uiLanguageDirection === 'rtl' ? 'w' : 'e';
            const t = locale.t;
            // Add existing alignment buttons to dropdown's toolbar.
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addToolbarToDropdown"])(dropdownView, ()=>options.map((option)=>this._createButton(locale, option.name, {
                        tooltipPosition
                    })), {
                enableActiveItemFocusOnDropdownOpen: true,
                isVertical: true,
                ariaLabel: t('Text alignment toolbar')
            });
            // Configure dropdown properties an behavior.
            dropdownView.buttonView.set({
                label: t('Text alignment'),
                tooltip: true
            });
            dropdownView.extendTemplate({
                attributes: {
                    class: 'ck-alignment-dropdown'
                }
            });
            // The default icon depends on the direction of the content.
            const defaultIcon = locale.contentLanguageDirection === 'rtl' ? iconsMap.get('right') : iconsMap.get('left');
            const command = editor.commands.get('alignment');
            // Change icon to reflect current selection's alignment.
            dropdownView.buttonView.bind('icon').to(command, 'value', (value)=>iconsMap.get(value) || defaultIcon);
            // Enable button if any of the buttons is enabled.
            dropdownView.bind('isEnabled').to(command, 'isEnabled');
            // Focus the editable after executing the command.
            // Overrides a default behaviour where the focus is moved to the dropdown button (#12125).
            this.listenTo(dropdownView, 'execute', ()=>{
                editor.editing.view.focus();
            });
            return dropdownView;
        });
    }
    /**
	 * Creates a menu for all alignment options to use either in menu bar.
	 *
	 * @param options Normalized alignment options from config.
	 */ _addMenuBarMenu(options) {
        const editor = this.editor;
        editor.ui.componentFactory.add('menuBar:alignment', (locale)=>{
            const command = editor.commands.get('alignment');
            const t = locale.t;
            const menuView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuView"](locale);
            const listView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListView"](locale);
            menuView.bind('isEnabled').to(command);
            listView.set({
                ariaLabel: t('Text alignment'),
                role: 'menu'
            });
            menuView.buttonView.set({
                label: t('Text alignment')
            });
            for (const option of options){
                const listItemView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemView"](locale, menuView);
                const buttonView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"](locale);
                buttonView.delegate('execute').to(menuView);
                buttonView.set({
                    label: this.localizedOptionTitles[option.name],
                    icon: iconsMap.get(option.name),
                    role: 'menuitemcheckbox',
                    isToggleable: true
                });
                buttonView.on('execute', ()=>{
                    editor.execute('alignment', {
                        value: option.name
                    });
                    editor.editing.view.focus();
                });
                buttonView.bind('isOn').to(command, 'value', (value)=>value === option.name);
                buttonView.bind('isEnabled').to(command, 'isEnabled');
                listItemView.children.add(buttonView);
                listView.items.add(listItemView);
            }
            menuView.panelView.children.add(listView);
            return menuView;
        });
    }
}
/**
 * The text alignment plugin.
 *
 * For a detailed overview, check the {@glink features/text-alignment Text alignment} feature guide
 * and the {@glink api/alignment package page}.
 *
 * This is a "glue" plugin which loads the {@link module:alignment/alignmentediting~AlignmentEditing} and
 * {@link module:alignment/alignmentui~AlignmentUI} plugins.
 */ class Alignment extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            AlignmentEditing,
            AlignmentUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Alignment';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-typing/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Delete": (()=>Delete),
    "Input": (()=>Input),
    "InsertTextCommand": (()=>InsertTextCommand),
    "TextTransformation": (()=>TextTransformation),
    "TextWatcher": (()=>TextWatcher),
    "TwoStepCaretMovement": (()=>TwoStepCaretMovement),
    "Typing": (()=>Typing),
    "findAttributeRange": (()=>findAttributeRange),
    "findAttributeRangeBound": (()=>findAttributeRangeBound),
    "getLastTextLine": (()=>getLastTextLine),
    "inlineHighlight": (()=>inlineHighlight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$debounce$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__debounce$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/debounce.js [app-client] (ecmascript) <export default as debounce>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$escapeRegExp$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__escapeRegExp$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/escapeRegExp.js [app-client] (ecmascript) <export default as escapeRegExp>");
;
;
;
;
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module typing/utils/changebuffer
 */ /**
 * Change buffer allows to group atomic changes (like characters that have been typed) into
 * {@link module:engine/model/batch~Batch batches}.
 *
 * Batches represent single undo steps, hence changes added to one single batch are undone together.
 *
 * The buffer has a configurable limit of atomic changes that it can accommodate. After the limit was
 * exceeded (see {@link ~ChangeBuffer#input}), a new batch is created in {@link ~ChangeBuffer#batch}.
 *
 * To use the change buffer you need to let it know about the number of changes that were added to the batch:
 *
 * ```ts
 * const buffer = new ChangeBuffer( model, LIMIT );
 *
 * // Later on in your feature:
 * buffer.batch.insert( pos, insertedCharacters );
 * buffer.input( insertedCharacters.length );
 * ```
 */ class ChangeBuffer {
    /**
	 * The model instance.
	 */ model;
    /**
	 * The maximum number of atomic changes which can be contained in one batch.
	 */ limit;
    /**
	 * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
	 */ _isLocked;
    /**
	 * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
	 * the {@link #batch batch} is set to a new one.
	 */ _size;
    /**
	 * The current batch instance.
	 */ _batch = null;
    /**
	 * The callback to document the change event which later needs to be removed.
	 */ _changeCallback;
    /**
	 * The callback to document selection `change:attribute` and `change:range` events which resets the buffer.
	 */ _selectionChangeCallback;
    /**
	 * Creates a new instance of the change buffer.
	 *
	 * @param limit The maximum number of atomic changes which can be contained in one batch.
	 */ constructor(model, limit = 20){
        this.model = model;
        this._size = 0;
        this.limit = limit;
        this._isLocked = false;
        // The function to be called in order to notify the buffer about batches which appeared in the document.
        // The callback will check whether it is a new batch and in that case the buffer will be flushed.
        //
        // The reason why the buffer needs to be flushed whenever a new batch appears is that the changes added afterwards
        // should be added to a new batch. For instance, when the user types, then inserts an image, and then types again,
        // the characters typed after inserting the image should be added to a different batch than the characters typed before.
        this._changeCallback = (evt, batch)=>{
            if (batch.isLocal && batch.isUndoable && batch !== this._batch) {
                this._reset(true);
            }
        };
        this._selectionChangeCallback = ()=>{
            this._reset();
        };
        this.model.document.on('change', this._changeCallback);
        this.model.document.selection.on('change:range', this._selectionChangeCallback);
        this.model.document.selection.on('change:attribute', this._selectionChangeCallback);
    }
    /**
	 * The current batch to which a feature should add its operations. Once the {@link #size}
	 * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
	 */ get batch() {
        if (!this._batch) {
            this._batch = this.model.createBatch({
                isTyping: true
            });
        }
        return this._batch;
    }
    /**
	 * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
	 * the {@link #batch batch} is set to a new one.
	 */ get size() {
        return this._size;
    }
    /**
	 * The input number of changes into the buffer. Once the {@link #size} is
	 * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
	 *
	 * @param changeCount The number of atomic changes to input.
	 */ input(changeCount) {
        this._size += changeCount;
        if (this._size >= this.limit) {
            this._reset(true);
        }
    }
    /**
	 * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
	 */ get isLocked() {
        return this._isLocked;
    }
    /**
	 * Locks the buffer.
	 */ lock() {
        this._isLocked = true;
    }
    /**
	 * Unlocks the buffer.
	 */ unlock() {
        this._isLocked = false;
    }
    /**
	 * Destroys the buffer.
	 */ destroy() {
        this.model.document.off('change', this._changeCallback);
        this.model.document.selection.off('change:range', this._selectionChangeCallback);
        this.model.document.selection.off('change:attribute', this._selectionChangeCallback);
    }
    /**
	 * Resets the change buffer.
	 *
	 * @param ignoreLock Whether internal lock {@link #isLocked} should be ignored.
	 */ _reset(ignoreLock = false) {
        if (!this.isLocked || ignoreLock) {
            this._batch = null;
            this._size = 0;
        }
    }
}
/**
 * The insert text command. Used by the {@link module:typing/input~Input input feature} to handle typing.
 */ class InsertTextCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * Typing's change buffer used to group subsequent changes into batches.
	 */ _buffer;
    /**
	 * Creates an instance of the command.
	 *
	 * @param undoStepSize The maximum number of atomic changes
	 * which can be contained in one batch in the command buffer.
	 */ constructor(editor, undoStepSize){
        super(editor);
        this._buffer = new ChangeBuffer(editor.model, undoStepSize);
        // Since this command may execute on different selectable than selection, it should be checked directly in execute block.
        this._isEnabledBasedOnSelection = false;
    }
    /**
	 * The current change buffer.
	 */ get buffer() {
        return this._buffer;
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this._buffer.destroy();
    }
    /**
	 * Executes the input command. It replaces the content within the given range with the given text.
	 * Replacing is a two step process, first the content within the range is removed and then the new text is inserted
	 * at the beginning of the range (which after the removal is a collapsed range).
	 *
	 * @fires execute
	 * @param options The command options.
	 */ execute(options = {}) {
        const model = this.editor.model;
        const doc = model.document;
        const text = options.text || '';
        const textInsertions = text.length;
        let selection = doc.selection;
        if (options.selection) {
            selection = options.selection;
        } else if (options.range) {
            selection = model.createSelection(options.range);
        }
        // Stop executing if selectable is in non-editable place.
        if (!model.canEditAt(selection)) {
            return;
        }
        const resultRange = options.resultRange;
        model.enqueueChange(this._buffer.batch, (writer)=>{
            this._buffer.lock();
            // Store selection attributes before deleting old content to preserve formatting and link.
            // This unifies the behavior between DocumentSelection and Selection provided as input option.
            const selectionAttributes = Array.from(doc.selection.getAttributes());
            model.deleteContent(selection);
            if (text) {
                model.insertContent(writer.createText(text, selectionAttributes), selection);
            }
            if (resultRange) {
                writer.setSelection(resultRange);
            } else if (!selection.is('documentSelection')) {
                writer.setSelection(selection);
            }
            this._buffer.unlock();
            this._buffer.input(textInsertions);
        });
    }
}
const TYPING_INPUT_TYPES = [
    // For collapsed range:
    //	- This one is a regular typing (all browsers, all systems).
    //	- This one is used by Chrome when typing accented letter – 2nd step when the user selects the accent (Mac).
    // For non-collapsed range:
    //	- This one is used by Chrome when typing accented letter – when the selection box first appears (Mac).
    //	- This one is used by Safari when accepting spell check suggestions from the context menu (Mac).
    'insertText',
    // This one is used by Safari when typing accented letter (Mac).
    // This one is used by Safari when accepting spell check suggestions from the autocorrection pop-up (Mac).
    'insertReplacementText'
];
const TYPING_INPUT_TYPES_ANDROID = [
    ...TYPING_INPUT_TYPES,
    'insertCompositionText'
];
/**
 * Text insertion observer introduces the {@link module:engine/view/document~Document#event:insertText} event.
 */ class InsertTextObserver extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observer"] {
    /**
	 * Instance of the focus observer. Insert text observer calls
	 * {@link module:engine/view/observer/focusobserver~FocusObserver#flush} to mark the latest focus change as complete.
	 */ focusObserver;
    /**
	 * @inheritDoc
	 */ constructor(view){
        super(view);
        this.focusObserver = view.getObserver(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusObserver"]);
        // On Android composition events should immediately be applied to the model. Rendering is not disabled.
        // On non-Android the model is updated only on composition end.
        // On Android we can't rely on composition start/end to update model.
        const typingInputTypes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isAndroid ? TYPING_INPUT_TYPES_ANDROID : TYPING_INPUT_TYPES;
        const viewDocument = view.document;
        viewDocument.on('beforeinput', (evt, data)=>{
            if (!this.isEnabled) {
                return;
            }
            const { data: text, targetRanges, inputType, domEvent } = data;
            if (!typingInputTypes.includes(inputType)) {
                return;
            }
            // Mark the latest focus change as complete (we are typing in editable after the focus
            // so the selection is in the focused element).
            this.focusObserver.flush();
            const eventInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventInfo"](viewDocument, 'insertText');
            viewDocument.fire(eventInfo, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DomEventData"](view, domEvent, {
                text,
                selection: view.createSelection(targetRanges)
            }));
            // Stop the beforeinput event if `delete` event was stopped.
            // https://github.com/ckeditor/ckeditor5/issues/753
            if (eventInfo.stop.called) {
                evt.stop();
            }
        });
        // On Android composition events are immediately applied to the model.
        // On non-Android the model is updated only on composition end.
        // On Android we can't rely on composition start/end to update model.
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isAndroid) {
            // Note: The priority must be lower than the CompositionObserver handler to call it after the renderer is unblocked.
            // This is important for view to DOM position mapping.
            // This causes the effect of first remove composed DOM and then reapply it after model modification.
            viewDocument.on('compositionend', (evt, { data, domEvent })=>{
                if (!this.isEnabled) {
                    return;
                }
                // In case of aborted composition.
                if (!data) {
                    return;
                }
                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
                // @if CK_DEBUG_TYPING // 	console.log( `%c[InsertTextObserver]%c Fire insertText event, %c${ JSON.stringify( data ) }`,
                // @if CK_DEBUG_TYPING // 		'font-weight: bold; color: green;', 'font-weight: bold', 'color: blue'
                // @if CK_DEBUG_TYPING // 	);
                // @if CK_DEBUG_TYPING // }
                // How do we know where to insert the composed text?
                // 1. The SelectionObserver is blocked and the view is not updated with the composition changes.
                // 2. The last moment before it's locked is the `compositionstart` event.
                // 3. The `SelectionObserver` is listening for `compositionstart` event and immediately converts
                //    the selection. Handles this at the lowest priority so after the rendering is blocked.
                viewDocument.fire('insertText', new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DomEventData"](view, domEvent, {
                    text: data
                }));
            }, {
                priority: 'lowest'
            });
        }
    }
    /**
	 * @inheritDoc
	 */ observe() {}
    /**
	 * @inheritDoc
	 */ stopObserving() {}
}
/**
 * Handles text input coming from the keyboard or other input methods.
 */ class Input extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * The queue of `insertText` command executions that are waiting for the DOM to get updated after beforeinput event.
	 */ _compositionQueue;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Input';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const model = editor.model;
        const view = editor.editing.view;
        const mapper = editor.editing.mapper;
        const modelSelection = model.document.selection;
        this._compositionQueue = new CompositionQueue(editor);
        view.addObserver(InsertTextObserver);
        // TODO The above default configuration value should be defined using editor.config.define() once it's fixed.
        const insertTextCommand = new InsertTextCommand(editor, editor.config.get('typing.undoStep') || 20);
        // Register `insertText` command and add `input` command as an alias for backward compatibility.
        editor.commands.add('insertText', insertTextCommand);
        editor.commands.add('input', insertTextCommand);
        this.listenTo(view.document, 'insertText', (evt, data)=>{
            // Rendering is disabled while composing so prevent events that will be rendered by the engine
            // and should not be applied by the browser.
            if (!view.document.isComposing) {
                data.preventDefault();
            }
            // Flush queue on the next beforeinput event because it could happen
            // that the mutation observer does not notice the DOM change in time.
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isAndroid && view.document.isComposing) {
                this._compositionQueue.flush('next beforeinput');
            }
            const { text, selection: viewSelection } = data;
            let modelRanges;
            // If view selection was specified, translate it to model selection.
            if (viewSelection) {
                modelRanges = Array.from(viewSelection.getRanges()).map((viewRange)=>mapper.toModelRange(viewRange));
            } else {
                modelRanges = Array.from(modelSelection.getRanges());
            }
            let insertText = text;
            // Typing in English on Android is firing composition events for the whole typed word.
            // We need to check the target range text to only apply the difference.
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isAndroid) {
                const selectedText = Array.from(modelRanges[0].getItems()).reduce((rangeText, node)=>{
                    return rangeText + (node.is('$textProxy') ? node.data : '');
                }, '');
                if (selectedText) {
                    if (selectedText.length <= insertText.length) {
                        if (insertText.startsWith(selectedText)) {
                            insertText = insertText.substring(selectedText.length);
                            modelRanges[0].start = modelRanges[0].start.getShiftedBy(selectedText.length);
                        }
                    } else {
                        if (selectedText.startsWith(insertText)) {
                            // TODO this should be mapped as delete?
                            modelRanges[0].start = modelRanges[0].start.getShiftedBy(insertText.length);
                            insertText = '';
                        }
                    }
                }
                if (insertText.length == 0 && modelRanges[0].isCollapsed) {
                    // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
                    // @if CK_DEBUG_TYPING // 	console.log( '%c[Input]%c Ignore insertion of an empty data to the collapsed range.',
                    // @if CK_DEBUG_TYPING // 		'font-weight: bold; color: green;', 'font-style: italic'
                    // @if CK_DEBUG_TYPING // 	);
                    // @if CK_DEBUG_TYPING // }
                    return;
                }
            }
            const commandData = {
                text: insertText,
                selection: model.createSelection(modelRanges)
            };
            // This is a composition event and those are not cancellable, so we need to wait until browser updates the DOM
            // and we could apply changes to the model and verify if the DOM is valid.
            // The browser applies changes to the DOM not immediately on beforeinput event.
            // We just wait for mutation observer to notice changes or as a fallback a timeout.
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isAndroid && view.document.isComposing) {
                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
                // @if CK_DEBUG_TYPING // 	console.log( `%c[Input]%c Queue insertText:%c "${ commandData.text }"%c ` +
                // @if CK_DEBUG_TYPING // 		`[${ commandData.selection.getFirstPosition().path }]-` +
                // @if CK_DEBUG_TYPING // 		`[${ commandData.selection.getLastPosition().path }]` +
                // @if CK_DEBUG_TYPING // 		` queue size: ${ this._compositionQueue.length + 1 }`,
                // @if CK_DEBUG_TYPING // 		'font-weight: bold; color: green;', 'font-weight: bold', 'color: blue', ''
                // @if CK_DEBUG_TYPING // 	);
                // @if CK_DEBUG_TYPING // }
                this._compositionQueue.push(commandData);
            } else {
                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
                // @if CK_DEBUG_TYPING // 	console.log( `%c[Input]%c Execute insertText:%c "${ commandData.text }"%c ` +
                // @if CK_DEBUG_TYPING // 		`[${ commandData.selection.getFirstPosition().path }]-` +
                // @if CK_DEBUG_TYPING // 		`[${ commandData.selection.getLastPosition().path }]`,
                // @if CK_DEBUG_TYPING // 		'font-weight: bold; color: green;', 'font-weight: bold', 'color: blue', ''
                // @if CK_DEBUG_TYPING // 	);
                // @if CK_DEBUG_TYPING // }
                editor.execute('insertText', commandData);
                view.scrollToTheSelection();
            }
        });
        // Delete selected content on composition start.
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isAndroid) {
            // On Android with English keyboard, the composition starts just by putting caret
            // at the word end or by selecting a table column. This is not a real composition started.
            // Trigger delete content on first composition key pressed.
            this.listenTo(view.document, 'keydown', (evt, data)=>{
                if (modelSelection.isCollapsed || data.keyCode != 229 || !view.document.isComposing) {
                    return;
                }
                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
                // @if CK_DEBUG_TYPING // 	const firstPositionPath = modelSelection.getFirstPosition()!.path;
                // @if CK_DEBUG_TYPING // 	const lastPositionPath = modelSelection.getLastPosition()!.path;
                // @if CK_DEBUG_TYPING // 	console.log( '%c[Input]%c KeyDown 229%c -> model.deleteContent() ' +
                // @if CK_DEBUG_TYPING // 		`[${ firstPositionPath }]-[${ lastPositionPath }]`,
                // @if CK_DEBUG_TYPING // 		'font-weight: bold; color: green;', 'font-weight: bold', '',
                // @if CK_DEBUG_TYPING // 	);
                // @if CK_DEBUG_TYPING // }
                deleteSelectionContent(model, insertTextCommand);
            });
        } else {
            // Note: The priority must precede the CompositionObserver handler to call it before
            // the renderer is blocked, because we want to render this change.
            this.listenTo(view.document, 'compositionstart', ()=>{
                if (modelSelection.isCollapsed) {
                    return;
                }
                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
                // @if CK_DEBUG_TYPING // 	const firstPositionPath = modelSelection.getFirstPosition()!.path;
                // @if CK_DEBUG_TYPING // 	const lastPositionPath = modelSelection.getLastPosition()!.path;
                // @if CK_DEBUG_TYPING // 	console.log( '%c[Input]%c Composition start%c -> model.deleteContent() ' +
                // @if CK_DEBUG_TYPING // 		`[${ firstPositionPath }]-[${ lastPositionPath }]`,
                // @if CK_DEBUG_TYPING // 		'font-weight: bold; color: green;', 'font-weight: bold', '',
                // @if CK_DEBUG_TYPING // 	);
                // @if CK_DEBUG_TYPING // }
                deleteSelectionContent(model, insertTextCommand);
            });
        }
        // Apply composed changes to the model.
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isAndroid) {
            // Apply changes to the model as they are applied to the DOM by the browser.
            // On beforeinput event, the DOM is not yet modified. We wait for detected mutations to apply model changes.
            this.listenTo(view.document, 'mutations', (evt, { mutations })=>{
                if (!view.document.isComposing) {
                    return;
                }
                // Check if mutations are relevant for queued changes.
                for (const { node } of mutations){
                    const viewElement = findMappedViewAncestor(node, mapper);
                    const modelElement = mapper.toModelElement(viewElement);
                    if (this._compositionQueue.isComposedElement(modelElement)) {
                        this._compositionQueue.flush('mutations');
                        return;
                    }
                }
            // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
            // @if CK_DEBUG_TYPING // 	console.log( '%c[Input]%c Mutations not related to the composition.',
            // @if CK_DEBUG_TYPING // 		'font-weight: bold; color: green;', 'font-style: italic'
            // @if CK_DEBUG_TYPING // 	);
            // @if CK_DEBUG_TYPING // }
            });
            // Make sure that all changes are applied to the model before the end of composition.
            this.listenTo(view.document, 'compositionend', ()=>{
                this._compositionQueue.flush('composition end');
            });
            // Trigger mutations check after the composition completes to fix all DOM changes that got ignored during composition.
            // On Android the Renderer is not disabled while composing. While updating DOM nodes we ignore some changes
            // that are not that important (like NBSP vs plain space character) and could break the composition flow.
            // After composition is completed we trigger additional `mutations` event for elements affected by the composition
            // so the Renderer can adjust the DOM to the expected structure without breaking the composition.
            this.listenTo(view.document, 'compositionend', ()=>{
                const mutations = [];
                for (const element of this._compositionQueue.flushComposedElements()){
                    const viewElement = mapper.toViewElement(element);
                    if (!viewElement) {
                        continue;
                    }
                    mutations.push({
                        type: 'children',
                        node: viewElement
                    });
                }
                if (mutations.length) {
                    // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
                    // @if CK_DEBUG_TYPING // 	console.group( '%c[Input]%c Fire post-composition mutation fixes.',
                    // @if CK_DEBUG_TYPING // 		'font-weight: bold; color: green', 'font-weight: bold', ''
                    // @if CK_DEBUG_TYPING // 	);
                    // @if CK_DEBUG_TYPING // }
                    view.document.fire('mutations', {
                        mutations
                    });
                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
                // @if CK_DEBUG_TYPING // 	console.groupEnd();
                // @if CK_DEBUG_TYPING // }
                }
            }, {
                priority: 'lowest'
            });
        } else {
            // After composition end we need to verify if there are no left-overs.
            // Listening at the lowest priority so after the `InsertTextObserver` added above (all composed text
            // should already be applied to the model, view, and DOM).
            // On non-Android the `Renderer` is blocked while user is composing but the `MutationObserver` still collects
            // mutated nodes and fires `mutations` events.
            // Those events are recorded by the `Renderer` but not applied to the DOM while composing.
            // We need to trigger those checks (and fixes) once again but this time without specifying the exact mutations
            // since they are already recorded by the `Renderer`.
            // It in the most cases just clears the internal record of mutated text nodes
            // since all changes should already be applied to the DOM.
            // This is especially needed when user cancels composition, so we can clear nodes marked to sync.
            this.listenTo(view.document, 'compositionend', ()=>{
                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
                // @if CK_DEBUG_TYPING // 	console.group( '%c[Input]%c Force render after composition end.',
                // @if CK_DEBUG_TYPING // 		'font-weight: bold; color: green', 'font-weight: bold', ''
                // @if CK_DEBUG_TYPING // 	);
                // @if CK_DEBUG_TYPING // }
                view.document.fire('mutations', {
                    mutations: []
                });
            // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
            // @if CK_DEBUG_TYPING // 	console.groupEnd();
            // @if CK_DEBUG_TYPING // }
            }, {
                priority: 'lowest'
            });
        }
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this._compositionQueue.destroy();
    }
}
/**
 * The queue of `insertText` command executions that are waiting for the DOM to get updated after beforeinput event.
 */ class CompositionQueue {
    /**
	 * The editor instance.
	 */ editor;
    /**
	 * Debounced queue flush as a safety mechanism for cases of mutation observer not triggering.
	 */ flushDebounced = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$debounce$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__debounce$3e$__["debounce"])(()=>this.flush('timeout'), 50);
    /**
	 * The queue of `insertText` command executions that are waiting for the DOM to get updated after beforeinput event.
	 */ _queue = [];
    /**
	 * A set of model elements. The composition happened in those elements. It's used for mutations check.
	 */ _compositionElements = new Set();
    /**
	 * @inheritDoc
	 */ constructor(editor){
        this.editor = editor;
    }
    /**
	 * Destroys the helper object.
	 */ destroy() {
        this.flushDebounced.cancel();
        this._compositionElements.clear();
        while(this._queue.length){
            this.shift();
        }
    }
    /**
	 * Returns the size of the queue.
	 */ get length() {
        return this._queue.length;
    }
    /**
	 * Push next insertText command data to the queue.
	 */ push(commandData) {
        const commandLiveData = {
            text: commandData.text
        };
        if (commandData.selection) {
            commandLiveData.selectionRanges = [];
            for (const range of commandData.selection.getRanges()){
                commandLiveData.selectionRanges.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LiveRange"].fromRange(range));
                // Keep reference to the model element for later mutation checks.
                this._compositionElements.add(range.start.parent);
            }
        }
        this._queue.push(commandLiveData);
        this.flushDebounced();
    }
    /**
	 * Shift the first item from the insertText command data queue.
	 */ shift() {
        const commandLiveData = this._queue.shift();
        const commandData = {
            text: commandLiveData.text
        };
        if (commandLiveData.selectionRanges) {
            const ranges = commandLiveData.selectionRanges.map((liveRange)=>detachLiveRange(liveRange)).filter((range)=>!!range);
            if (ranges.length) {
                commandData.selection = this.editor.model.createSelection(ranges);
            }
        }
        return commandData;
    }
    /**
	 * Applies all queued insertText command executions.
	 *
	 * @param reason Used only for debugging.
	 */ flush(reason) {
        const editor = this.editor;
        const model = editor.model;
        const view = editor.editing.view;
        this.flushDebounced.cancel();
        if (!this._queue.length) {
            return;
        }
        // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
        // @if CK_DEBUG_TYPING // 	console.group( `%c[Input]%c Flush insertText queue on ${ reason }.`,
        // @if CK_DEBUG_TYPING // 		'font-weight: bold; color: green;', 'font-weight: bold'
        // @if CK_DEBUG_TYPING // 	);
        // @if CK_DEBUG_TYPING // }
        const insertTextCommand = editor.commands.get('insertText');
        const buffer = insertTextCommand.buffer;
        model.enqueueChange(buffer.batch, ()=>{
            buffer.lock();
            while(this._queue.length){
                const commandData = this.shift();
                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
                // @if CK_DEBUG_TYPING // 	console.log( '%c[Input]%c Execute queued insertText:%c ' +
                // @if CK_DEBUG_TYPING // 		`"${ commandData.text }"%c ` +
                // @if CK_DEBUG_TYPING // 		`[${ commandData.selection.getFirstPosition().path }]-` +
                // @if CK_DEBUG_TYPING // 		`[${ commandData.selection.getLastPosition().path }]`,
                // @if CK_DEBUG_TYPING // 		'font-weight: bold; color: green;', 'font-weight: bold', 'color: blue', ''
                // @if CK_DEBUG_TYPING // 	);
                // @if CK_DEBUG_TYPING // }
                editor.execute('insertText', commandData);
            }
            buffer.unlock();
        });
        view.scrollToTheSelection();
    // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
    // @if CK_DEBUG_TYPING // 	console.groupEnd();
    // @if CK_DEBUG_TYPING // }
    }
    /**
	 * Returns `true` if the given model element is related to recent composition.
	 */ isComposedElement(element) {
        return this._compositionElements.has(element);
    }
    /**
	 * Returns an array of composition-related elements and clears the internal list.
	 */ flushComposedElements() {
        const result = Array.from(this._compositionElements);
        this._compositionElements.clear();
        return result;
    }
}
/**
 * Deletes the content selected by the document selection at the start of composition.
 */ function deleteSelectionContent(model, insertTextCommand) {
    // By relying on the state of the input command we allow disabling the entire input easily
    // by just disabling the input command. We could’ve used here the delete command but that
    // would mean requiring the delete feature which would block loading one without the other.
    // We could also check the editor.isReadOnly property, but that wouldn't allow to block
    // the input without blocking other features.
    if (!insertTextCommand.isEnabled) {
        return;
    }
    const buffer = insertTextCommand.buffer;
    buffer.lock();
    model.enqueueChange(buffer.batch, ()=>{
        model.deleteContent(model.document.selection);
    });
    buffer.unlock();
}
/**
 * Detaches a LiveRange and returns the static range from it.
 */ function detachLiveRange(liveRange) {
    const range = liveRange.toRange();
    liveRange.detach();
    if (range.root.rootName == '$graveyard') {
        return null;
    }
    return range;
}
/**
 * For the given `viewNode`, finds and returns the closest ancestor of this node that has a mapping to the model.
 */ function findMappedViewAncestor(viewNode, mapper) {
    let node = viewNode.is('$text') ? viewNode.parent : viewNode;
    while(!mapper.toModelElement(node)){
        node = node.parent;
    }
    return node;
}
/**
 * The delete command. Used by the {@link module:typing/delete~Delete delete feature} to handle the <kbd>Delete</kbd> and
 * <kbd>Backspace</kbd> keys.
 */ class DeleteCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * The directionality of the delete describing in what direction it should
	 * consume the content when the selection is collapsed.
	 */ direction;
    /**
	 * Delete's change buffer used to group subsequent changes into batches.
	 */ _buffer;
    /**
	 * Creates an instance of the command.
	 *
	 * @param direction The directionality of the delete describing in what direction it
	 * should consume the content when the selection is collapsed.
	 */ constructor(editor, direction){
        super(editor);
        this.direction = direction;
        this._buffer = new ChangeBuffer(editor.model, editor.config.get('typing.undoStep'));
        // Since this command may execute on different selectable than selection, it should be checked directly in execute block.
        this._isEnabledBasedOnSelection = false;
    }
    /**
	 * The current change buffer.
	 */ get buffer() {
        return this._buffer;
    }
    /**
	 * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content
	 * or a piece of content in the {@link #direction defined direction}.
	 *
	 * @fires execute
	 * @param options The command options.
	 * @param options.unit See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.
	 * @param options.sequence A number describing which subsequent delete event it is without the key being released.
	 * See the {@link module:engine/view/document~Document#event:delete} event data.
	 * @param options.selection Selection to remove. If not set, current model selection will be used.
	 */ execute(options = {}) {
        const model = this.editor.model;
        const doc = model.document;
        model.enqueueChange(this._buffer.batch, (writer)=>{
            this._buffer.lock();
            const selection = writer.createSelection(options.selection || doc.selection);
            // Don't execute command when selection is in non-editable place.
            if (!model.canEditAt(selection)) {
                return;
            }
            const sequence = options.sequence || 1;
            // Do not replace the whole selected content if selection was collapsed.
            // This prevents such situation:
            //
            // <h1></h1><p>[]</p>	-->  <h1>[</h1><p>]</p> 		-->  <p></p>
            // starting content		-->   after `modifySelection`	-->  after `deleteContent`.
            const doNotResetEntireContent = selection.isCollapsed;
            // Try to extend the selection in the specified direction.
            if (selection.isCollapsed) {
                model.modifySelection(selection, {
                    direction: this.direction,
                    unit: options.unit,
                    treatEmojiAsSingleUnit: true
                });
            }
            // Check if deleting in an empty editor. See #61.
            if (this._shouldEntireContentBeReplacedWithParagraph(sequence)) {
                this._replaceEntireContentWithParagraph(writer);
                return;
            }
            // Check if deleting in the first empty block.
            // See https://github.com/ckeditor/ckeditor5/issues/8137.
            if (this._shouldReplaceFirstBlockWithParagraph(selection, sequence)) {
                this.editor.execute('paragraph', {
                    selection
                });
                return;
            }
            // If selection is still collapsed, then there's nothing to delete.
            if (selection.isCollapsed) {
                return;
            }
            let changeCount = 0;
            selection.getFirstRange().getMinimalFlatRanges().forEach((range)=>{
                changeCount += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["count"])(range.getWalker({
                    singleCharacters: true,
                    ignoreElementEnd: true,
                    shallow: true
                }));
            });
            // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {
            // @if CK_DEBUG_TYPING // 	console.log( '%c[DeleteCommand]%c Delete content',
            // @if CK_DEBUG_TYPING // 		'font-weight: bold; color: green;', '',
            // @if CK_DEBUG_TYPING // 		`[${ selection.getFirstPosition()!.path }]-[${ selection.getLastPosition()!.path }]`, options
            // @if CK_DEBUG_TYPING // 	);
            // @if CK_DEBUG_TYPING // }
            model.deleteContent(selection, {
                doNotResetEntireContent,
                direction: this.direction
            });
            this._buffer.input(changeCount);
            writer.setSelection(selection);
            this._buffer.unlock();
        });
    }
    /**
	 * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current
	 * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph
	 * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).
	 *
	 * But, if the user pressed the key in an empty editable for the first time,
	 * we want to replace the entire content with a paragraph if:
	 *
	 * * the current limit element is empty,
	 * * the paragraph is allowed in the limit element,
	 * * the limit doesn't already have a paragraph inside.
	 *
	 * See https://github.com/ckeditor/ckeditor5-typing/issues/61.
	 *
	 * @param sequence A number describing which subsequent delete event it is without the key being released.
	 */ _shouldEntireContentBeReplacedWithParagraph(sequence) {
        // Does nothing if user pressed and held the "Backspace" or "Delete" key.
        if (sequence > 1) {
            return false;
        }
        const model = this.editor.model;
        const doc = model.document;
        const selection = doc.selection;
        const limitElement = model.schema.getLimitElement(selection);
        // If a collapsed selection contains the whole content it means that the content is empty
        // (from the user perspective).
        const limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent(limitElement);
        if (!limitElementIsEmpty) {
            return false;
        }
        if (!model.schema.checkChild(limitElement, 'paragraph')) {
            return false;
        }
        const limitElementFirstChild = limitElement.getChild(0);
        // Does nothing if the limit element already contains only a paragraph.
        // We ignore the case when paragraph might have some inline elements (<p><inlineWidget>[]</inlineWidget></p>)
        // because we don't support such cases yet and it's unclear whether inlineWidget shouldn't be a limit itself.
        if (limitElementFirstChild && limitElementFirstChild.is('element', 'paragraph')) {
            return false;
        }
        return true;
    }
    /**
	 * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.
	 *
	 * @param writer The model writer.
	 */ _replaceEntireContentWithParagraph(writer) {
        const model = this.editor.model;
        const doc = model.document;
        const selection = doc.selection;
        const limitElement = model.schema.getLimitElement(selection);
        const paragraph = writer.createElement('paragraph');
        writer.remove(writer.createRangeIn(limitElement));
        writer.insert(paragraph, limitElement);
        writer.setSelection(paragraph, 0);
    }
    /**
	 * Checks if the selection is inside an empty element that is the first child of the limit element
	 * and should be replaced with a paragraph.
	 *
	 * @param selection The selection.
	 * @param sequence A number describing which subsequent delete event it is without the key being released.
	 */ _shouldReplaceFirstBlockWithParagraph(selection, sequence) {
        const model = this.editor.model;
        // Does nothing if user pressed and held the "Backspace" key or it was a "Delete" button.
        if (sequence > 1 || this.direction != 'backward') {
            return false;
        }
        if (!selection.isCollapsed) {
            return false;
        }
        const position = selection.getFirstPosition();
        const limitElement = model.schema.getLimitElement(position);
        const limitElementFirstChild = limitElement.getChild(0);
        // Only elements that are direct children of the limit element can be replaced.
        // Unwrapping from a block quote should be handled in a dedicated feature.
        if (position.parent != limitElementFirstChild) {
            return false;
        }
        // A block should be replaced only if it was empty.
        if (!selection.containsEntireContent(limitElementFirstChild)) {
            return false;
        }
        // Replace with a paragraph only if it's allowed there.
        if (!model.schema.checkChild(limitElement, 'paragraph')) {
            return false;
        }
        // Does nothing if the limit element already contains only a paragraph.
        if (limitElementFirstChild.name == 'paragraph') {
            return false;
        }
        return true;
    }
}
const DELETE_CHARACTER = 'character';
const DELETE_WORD = 'word';
const DELETE_CODE_POINT = 'codePoint';
const DELETE_SELECTION = 'selection';
const DELETE_BACKWARD = 'backward';
const DELETE_FORWARD = 'forward';
const DELETE_EVENT_TYPES = {
    // --------------------------------------- Backward delete types -----------------------------------------------------
    // This happens in Safari on Mac when some content is selected and Ctrl + K is pressed.
    deleteContent: {
        unit: DELETE_SELECTION,
        // According to the Input Events Level 2 spec, this delete type has no direction
        // but to keep things simple, let's default to backward.
        direction: DELETE_BACKWARD
    },
    // Chrome and Safari on Mac: Backspace or Ctrl + H
    deleteContentBackward: {
        // This kind of deletions must be done on the code point-level instead of target range provided by the DOM beforeinput event.
        // Take for instance "👨‍👩‍👧‍👧", it equals:
        //
        //	* [ "👨", "ZERO WIDTH JOINER", "👩", "ZERO WIDTH JOINER", "👧", "ZERO WIDTH JOINER", "👧" ]
        //	* or simply "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}"
        //
        // The range provided by the browser would cause the entire multi-byte grapheme to disappear while the user
        // intention when deleting backwards ("👨‍👩‍👧‍👧[]", then backspace) is gradual "decomposition" (first to "👨‍👩‍👧‍[]",
        // then to "👨‍👩‍[]", etc.).
        //
        //	* "👨‍👩‍👧‍👧[]" + backward delete (by code point)  -> results in "👨‍👩‍👧[]", removed the last "👧" 👍
        //	* "👨‍👩‍👧‍👧[]" + backward delete (by character)  -> results in "[]", removed the whole grapheme 👎
        //
        // Deleting by code-point is simply a better UX. See "deleteContentForward" to learn more.
        unit: DELETE_CODE_POINT,
        direction: DELETE_BACKWARD
    },
    // On Mac: Option + Backspace.
    // On iOS: Hold the backspace for a while and the whole words will start to disappear.
    deleteWordBackward: {
        unit: DELETE_WORD,
        direction: DELETE_BACKWARD
    },
    // Safari on Mac: Cmd + Backspace
    deleteHardLineBackward: {
        unit: DELETE_SELECTION,
        direction: DELETE_BACKWARD
    },
    // Chrome on Mac: Cmd + Backspace.
    deleteSoftLineBackward: {
        unit: DELETE_SELECTION,
        direction: DELETE_BACKWARD
    },
    // --------------------------------------- Forward delete types -----------------------------------------------------
    // Chrome on Mac: Fn + Backspace or Ctrl + D
    // Safari on Mac: Ctrl + K or Ctrl + D
    deleteContentForward: {
        // Unlike backward delete, this delete must be performed by character instead of by code point, which
        // provides the best UX for working with accented letters.
        // Take, for example "b̂" ("\u0062\u0302", or [ "LATIN SMALL LETTER B", "COMBINING CIRCUMFLEX ACCENT" ]):
        //
        //	* "b̂[]" + backward delete (by code point)  -> results in "b[]", removed the combining mark 👍
        //	* "[]b̂" + forward delete (by code point)   -> results in "[]^", a bare combining mark does that not make sense when alone 👎
        //	* "[]b̂" + forward delete (by character)    -> results in "[]", removed both "b" and the combining mark 👍
        //
        // See: "deleteContentBackward" to learn more.
        unit: DELETE_CHARACTER,
        direction: DELETE_FORWARD
    },
    // On Mac: Fn + Option + Backspace.
    deleteWordForward: {
        unit: DELETE_WORD,
        direction: DELETE_FORWARD
    },
    // Chrome on Mac: Ctrl + K (you have to disable the Link plugin first, though, because it uses the same keystroke)
    // This is weird that it does not work in Safari on Mac despite being listed in the official shortcuts listing
    // on Apple's webpage.
    deleteHardLineForward: {
        unit: DELETE_SELECTION,
        direction: DELETE_FORWARD
    },
    // At this moment there is no known way to trigger this event type but let's keep it for the symmetry with
    // deleteSoftLineBackward.
    deleteSoftLineForward: {
        unit: DELETE_SELECTION,
        direction: DELETE_FORWARD
    }
};
/**
 * Delete observer introduces the {@link module:engine/view/document~Document#event:delete} event.
 */ class DeleteObserver extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observer"] {
    /**
	 * @inheritDoc
	 */ constructor(view){
        super(view);
        const document = view.document;
        // It matters how many subsequent deletions were made, e.g. when the backspace key was pressed and held
        // by the user for some time. For instance, if such scenario ocurred and the heading the selection was
        // anchored to was the only content of the editor, it will not be converted into a paragraph (the user
        // wanted to clean it up, not remove it, it's about UX). Check out the DeleteCommand implementation to learn more.
        //
        // Fun fact: Safari on Mac won't fire beforeinput for backspace in an empty heading (only content).
        let sequence = 0;
        document.on('keydown', ()=>{
            sequence++;
        });
        document.on('keyup', ()=>{
            sequence = 0;
        });
        document.on('beforeinput', (evt, data)=>{
            if (!this.isEnabled) {
                return;
            }
            const { targetRanges, domEvent, inputType } = data;
            const deleteEventSpec = DELETE_EVENT_TYPES[inputType];
            if (!deleteEventSpec) {
                return;
            }
            const deleteData = {
                direction: deleteEventSpec.direction,
                unit: deleteEventSpec.unit,
                sequence
            };
            if (deleteData.unit == DELETE_SELECTION) {
                deleteData.selectionToRemove = view.createSelection(targetRanges[0]);
            }
            // The default deletion unit for deleteContentBackward is a single code point
            // but if the browser provides a wider target range then we should use it.
            if (inputType === 'deleteContentBackward') {
                // On Android, deleteContentBackward has sequence 1 by default.
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isAndroid) {
                    deleteData.sequence = 1;
                }
                // The beforeInput event wants more than a single character to be removed.
                if (shouldUseTargetRanges(targetRanges)) {
                    deleteData.unit = DELETE_SELECTION;
                    deleteData.selectionToRemove = view.createSelection(targetRanges);
                }
            }
            const eventInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BubblingEventInfo"](document, 'delete', targetRanges[0]);
            document.fire(eventInfo, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DomEventData"](view, domEvent, deleteData));
            // Stop the beforeinput event if `delete` event was stopped.
            // https://github.com/ckeditor/ckeditor5/issues/753
            if (eventInfo.stop.called) {
                evt.stop();
            }
        });
        // TODO: to be removed when https://bugs.chromium.org/p/chromium/issues/detail?id=1365311 is solved.
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isBlink) {
            enableChromeWorkaround(this);
        }
    }
    /**
	 * @inheritDoc
	 */ observe() {}
    /**
	 * @inheritDoc
	 */ stopObserving() {}
}
/**
 * Enables workaround for the issue https://github.com/ckeditor/ckeditor5/issues/11904.
 */ function enableChromeWorkaround(observer) {
    const view = observer.view;
    const document = view.document;
    let pressedKeyCode = null;
    let beforeInputReceived = false;
    document.on('keydown', (evt, { keyCode })=>{
        pressedKeyCode = keyCode;
        beforeInputReceived = false;
    });
    document.on('keyup', (evt, { keyCode, domEvent })=>{
        const selection = document.selection;
        const shouldFireDeleteEvent = observer.isEnabled && keyCode == pressedKeyCode && isDeleteKeyCode(keyCode) && !selection.isCollapsed && !beforeInputReceived;
        pressedKeyCode = null;
        if (shouldFireDeleteEvent) {
            const targetRange = selection.getFirstRange();
            const eventInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BubblingEventInfo"](document, 'delete', targetRange);
            const deleteData = {
                unit: DELETE_SELECTION,
                direction: getDeleteDirection(keyCode),
                selectionToRemove: selection
            };
            document.fire(eventInfo, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DomEventData"](view, domEvent, deleteData));
        }
    });
    document.on('beforeinput', (evt, { inputType })=>{
        const deleteEventSpec = DELETE_EVENT_TYPES[inputType];
        const isMatchingBeforeInput = isDeleteKeyCode(pressedKeyCode) && deleteEventSpec && deleteEventSpec.direction == getDeleteDirection(pressedKeyCode);
        if (isMatchingBeforeInput) {
            beforeInputReceived = true;
        }
    }, {
        priority: 'high'
    });
    document.on('beforeinput', (evt, { inputType, data })=>{
        const shouldIgnoreBeforeInput = pressedKeyCode == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].delete && inputType == 'insertText' && data == '\x7f'; // Delete character :P
        if (shouldIgnoreBeforeInput) {
            evt.stop();
        }
    }, {
        priority: 'high'
    });
    function isDeleteKeyCode(keyCode) {
        return keyCode == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].backspace || keyCode == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].delete;
    }
    function getDeleteDirection(keyCode) {
        return keyCode == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].backspace ? DELETE_BACKWARD : DELETE_FORWARD;
    }
}
/**
 * Verifies whether the given target ranges cover more than a single character and should be used instead of a single code-point deletion.
 */ function shouldUseTargetRanges(targetRanges) {
    // The collapsed target range could happen for example while deleting inside an inline filler
    // (it's mapped to collapsed position before an inline filler).
    if (targetRanges.length != 1 || targetRanges[0].isCollapsed) {
        return false;
    }
    const walker = targetRanges[0].getWalker({
        direction: 'backward',
        singleCharacters: true,
        ignoreElementEnd: true
    });
    let count = 0;
    for (const { nextPosition, item } of walker){
        if (nextPosition.parent.is('$text')) {
            const data = nextPosition.parent.data;
            const offset = nextPosition.offset;
            // Count combined symbols and emoji sequences as a single character.
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInsideSurrogatePair"])(data, offset) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInsideCombinedSymbol"])(data, offset) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInsideEmojiSequence"])(data, offset)) {
                continue;
            }
            count++;
        } else if (item.is('containerElement') || item.is('emptyElement')) {
            count++;
        }
        if (count > 1) {
            return true;
        }
    }
    return false;
}
/**
 * The delete and backspace feature. Handles keys such as <kbd>Delete</kbd> and <kbd>Backspace</kbd>, other
 * keystrokes and user actions that result in deleting content in the editor.
 */ class Delete extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * Whether pressing backspace should trigger undo action
	 */ _undoOnBackspace;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Delete';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const modelDocument = editor.model.document;
        view.addObserver(DeleteObserver);
        this._undoOnBackspace = false;
        const deleteForwardCommand = new DeleteCommand(editor, 'forward');
        // Register `deleteForward` command and add `forwardDelete` command as an alias for backward compatibility.
        editor.commands.add('deleteForward', deleteForwardCommand);
        editor.commands.add('forwardDelete', deleteForwardCommand);
        editor.commands.add('delete', new DeleteCommand(editor, 'backward'));
        this.listenTo(viewDocument, 'delete', (evt, data)=>{
            // When not in composition, we handle the action, so prevent the default one.
            // When in composition, it's the browser who modify the DOM (renderer is disabled).
            if (!viewDocument.isComposing) {
                data.preventDefault();
            }
            const { direction, sequence, selectionToRemove, unit } = data;
            const commandName = direction === 'forward' ? 'deleteForward' : 'delete';
            const commandData = {
                sequence
            };
            if (unit == 'selection') {
                const modelRanges = Array.from(selectionToRemove.getRanges()).map((viewRange)=>{
                    return editor.editing.mapper.toModelRange(viewRange);
                });
                commandData.selection = editor.model.createSelection(modelRanges);
            } else {
                commandData.unit = unit;
            }
            editor.execute(commandName, commandData);
            view.scrollToTheSelection();
        }, {
            priority: 'low'
        });
        // Handle the Backspace key while at the beginning of a nested editable. See https://github.com/ckeditor/ckeditor5/issues/17383.
        this.listenTo(viewDocument, 'keydown', (evt, data)=>{
            if (viewDocument.isComposing || data.keyCode != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].backspace || !modelDocument.selection.isCollapsed) {
                return;
            }
            const ancestorLimit = editor.model.schema.getLimitElement(modelDocument.selection);
            const limitStartPosition = editor.model.createPositionAt(ancestorLimit, 0);
            if (limitStartPosition.isTouching(modelDocument.selection.getFirstPosition())) {
                data.preventDefault();
            }
        });
        if (this.editor.plugins.has('UndoEditing')) {
            this.listenTo(viewDocument, 'delete', (evt, data)=>{
                if (this._undoOnBackspace && data.direction == 'backward' && data.sequence == 1 && data.unit == 'codePoint') {
                    this._undoOnBackspace = false;
                    editor.execute('undo');
                    data.preventDefault();
                    evt.stop();
                }
            }, {
                context: '$capture'
            });
            this.listenTo(modelDocument, 'change', ()=>{
                this._undoOnBackspace = false;
            });
        }
    }
    /**
	 * If the next user action after calling this method is pressing backspace, it would undo the last change.
	 *
	 * Requires {@link module:undo/undoediting~UndoEditing} plugin. If not loaded, does nothing.
	 */ requestUndoOnBackspace() {
        if (this.editor.plugins.has('UndoEditing')) {
            this._undoOnBackspace = true;
        }
    }
}
/**
 * The typing feature. It handles typing.
 *
 * This is a "glue" plugin which loads the {@link module:typing/input~Input} and {@link module:typing/delete~Delete}
 * plugins.
 */ class Typing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    static get requires() {
        return [
            Input,
            Delete
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Typing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module typing/utils/getlasttextline
 */ /**
 * Returns the last text line from the given range.
 *
 * "The last text line" is understood as text (from one or more text nodes) which is limited either by a parent block
 * or by inline elements (e.g. `<softBreak>`).
 *
 * ```ts
 * const rangeToCheck = model.createRange(
 * 	model.createPositionAt( paragraph, 0 ),
 * 	model.createPositionAt( paragraph, 'end' )
 * );
 *
 * const { text, range } = getLastTextLine( rangeToCheck, model );
 * ```
 *
 * For model below, the returned `text` will be "Foo bar baz" and `range` will be set on whole `<paragraph>` content:
 *
 * ```xml
 * <paragraph>Foo bar baz<paragraph>
 * ```
 *
 * However, in below case, `text` will be set to "baz" and `range` will be set only on "baz".
 *
 * ```xml
 * <paragraph>Foo<softBreak></softBreak>bar<softBreak></softBreak>baz<paragraph>
 * ```
 */ function getLastTextLine(range, model) {
    let start = range.start;
    const text = Array.from(range.getWalker({
        ignoreElementEnd: false
    })).reduce((rangeText, { item })=>{
        // Trim text to a last occurrence of an inline element and update range start.
        if (!(item.is('$text') || item.is('$textProxy'))) {
            start = model.createPositionAfter(item);
            return '';
        }
        return rangeText + item.data;
    }, '');
    return {
        text,
        range: model.createRange(start, range.end)
    };
}
/**
 * The text watcher feature.
 *
 * Fires the {@link module:typing/textwatcher~TextWatcher#event:matched:data `matched:data`},
 * {@link module:typing/textwatcher~TextWatcher#event:matched:selection `matched:selection`} and
 * {@link module:typing/textwatcher~TextWatcher#event:unmatched `unmatched`} events on typing or selection changes.
 */ class TextWatcher extends /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObservableMixin"])() {
    /**
	 * The editor's model.
	 */ model;
    /**
	 * The function used to match the text.
	 *
	 * The test callback can return 3 values:
	 *
	 * * `false` if there is no match,
	 * * `true` if there is a match,
	 * * an object if there is a match and we want to pass some additional information to the {@link #event:matched:data} event.
	 */ testCallback;
    /**
	 * Whether there is a match currently.
	 */ _hasMatch;
    /**
	 * Creates a text watcher instance.
	 *
	 * @param testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.
	 */ constructor(model, testCallback){
        super();
        this.model = model;
        this.testCallback = testCallback;
        this._hasMatch = false;
        this.set('isEnabled', true);
        // Toggle text watching on isEnabled state change.
        this.on('change:isEnabled', ()=>{
            if (this.isEnabled) {
                this._startListening();
            } else {
                this.stopListening(model.document.selection);
                this.stopListening(model.document);
            }
        });
        this._startListening();
    }
    /**
	 * Flag indicating whether there is a match currently.
	 */ get hasMatch() {
        return this._hasMatch;
    }
    /**
	 * Starts listening to the editor for typing and selection events.
	 */ _startListening() {
        const model = this.model;
        const document = model.document;
        this.listenTo(document.selection, 'change:range', (evt, { directChange })=>{
            // Indirect changes (i.e. when the user types or external changes are applied) are handled in the document's change event.
            if (!directChange) {
                return;
            }
            // Act only on collapsed selection.
            if (!document.selection.isCollapsed) {
                if (this.hasMatch) {
                    this.fire('unmatched');
                    this._hasMatch = false;
                }
                return;
            }
            this._evaluateTextBeforeSelection('selection');
        });
        this.listenTo(document, 'change:data', (evt, batch)=>{
            if (batch.isUndo || !batch.isLocal) {
                return;
            }
            this._evaluateTextBeforeSelection('data', {
                batch
            });
        });
    }
    /**
	 * Checks the editor content for matched text.
	 *
	 * @fires matched:data
	 * @fires matched:selection
	 * @fires unmatched
	 *
	 * @param suffix A suffix used for generating the event name.
	 * @param data Data object for event.
	 */ _evaluateTextBeforeSelection(suffix, data = {}) {
        const model = this.model;
        const document = model.document;
        const selection = document.selection;
        const rangeBeforeSelection = model.createRange(model.createPositionAt(selection.focus.parent, 0), selection.focus);
        const { text, range } = getLastTextLine(rangeBeforeSelection, model);
        const testResult = this.testCallback(text);
        if (!testResult && this.hasMatch) {
            this.fire('unmatched');
        }
        this._hasMatch = !!testResult;
        if (testResult) {
            const eventData = Object.assign(data, {
                text,
                range
            });
            // If the test callback returns an object with additional data, assign the data as well.
            if (typeof testResult == 'object') {
                Object.assign(eventData, testResult);
            }
            this.fire(`matched:${suffix}`, eventData);
        }
    }
}
/**
 * This plugin enables the two-step caret (phantom) movement behavior for
 * {@link module:typing/twostepcaretmovement~TwoStepCaretMovement#registerAttribute registered attributes}
 * on arrow right (<kbd>→</kbd>) and left (<kbd>←</kbd>) key press.
 *
 * Thanks to this (phantom) caret movement the user is able to type before/after as well as at the
 * beginning/end of an attribute.
 *
 * **Note:** This plugin support right–to–left (Arabic, Hebrew, etc.) content by mirroring its behavior
 * but for the sake of simplicity examples showcase only left–to–right use–cases.
 *
 * # Forward movement
 *
 * ## "Entering" an attribute:
 *
 * When this plugin is enabled and registered for the `a` attribute and the selection is right before it
 * (at the attribute boundary), pressing the right arrow key will not move the selection but update its
 * attributes accordingly:
 *
 * * When enabled:
 *
 * ```xml
 * foo{}<$text a="true">bar</$text>
 * ```
 *
 * 	<kbd>→</kbd>
 *
 * ```xml
 * foo<$text a="true">{}bar</$text>
 * ```
 *
 * * When disabled:
 *
 * ```xml
 * foo{}<$text a="true">bar</$text>
 * ```
 *
 * 	<kbd>→</kbd>
 *
 * ```xml
 * foo<$text a="true">b{}ar</$text>
 * ```
 *
 *
 * ## "Leaving" an attribute:
 *
 * * When enabled:
 *
 * ```xml
 * <$text a="true">bar{}</$text>baz
 * ```
 *
 * 	<kbd>→</kbd>
 *
 * ```xml
 * <$text a="true">bar</$text>{}baz
 * ```
 *
 * * When disabled:
 *
 * ```xml
 * <$text a="true">bar{}</$text>baz
 * ```
 *
 * 	<kbd>→</kbd>
 *
 * ```xml
 * <$text a="true">bar</$text>b{}az
 * ```
 *
 * # Backward movement
 *
 * * When enabled:
 *
 * ```xml
 * <$text a="true">bar</$text>{}baz
 * ```
 *
 * 	<kbd>←</kbd>
 *
 * ```xml
 * <$text a="true">bar{}</$text>baz
 * ```
 *
 * * When disabled:
 *
 * ```xml
 * <$text a="true">bar</$text>{}baz
 * ```
 *
 * 	<kbd>←</kbd>
 *
 * ```xml
 * <$text a="true">ba{}r</$text>b{}az
 * ```
 *
 * # Multiple attributes
 *
 * * When enabled and many attributes starts or ends at the same position:
 *
 * ```xml
 * <$text a="true" b="true">bar</$text>{}baz
 * ```
 *
 * 	<kbd>←</kbd>
 *
 * ```xml
 * <$text a="true" b="true">bar{}</$text>baz
 * ```
 *
 * * When enabled and one procedes another:
 *
 * ```xml
 * <$text a="true">bar</$text><$text b="true">{}bar</$text>
 * ```
 *
 * 	<kbd>←</kbd>
 *
 * ```xml
 * <$text a="true">bar{}</$text><$text b="true">bar</$text>
 * ```
 *
 */ class TwoStepCaretMovement extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * A set of attributes to handle.
	 */ attributes;
    /**
	 * The current UID of the overridden gravity, as returned by
	 * {@link module:engine/model/writer~Writer#overrideSelectionGravity}.
	 */ _overrideUid;
    /**
	 * A flag indicating that the automatic gravity restoration should not happen upon the next
	 * gravity restoration.
	 * {@link module:engine/model/selection~Selection#event:change:range} event.
	 */ _isNextGravityRestorationSkipped = false;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'TwoStepCaretMovement';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        this.attributes = new Set();
        this._overrideUid = null;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const model = editor.model;
        const view = editor.editing.view;
        const locale = editor.locale;
        const modelSelection = model.document.selection;
        // Listen to keyboard events and handle the caret movement according to the 2-step caret logic.
        this.listenTo(view.document, 'arrowKey', (evt, data)=>{
            // This implementation works only for collapsed selection.
            if (!modelSelection.isCollapsed) {
                return;
            }
            // When user tries to expand the selection or jump over the whole word or to the beginning/end then
            // two-steps movement is not necessary.
            if (data.shiftKey || data.altKey || data.ctrlKey) {
                return;
            }
            const arrowRightPressed = data.keyCode == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].arrowright;
            const arrowLeftPressed = data.keyCode == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].arrowleft;
            // When neither left or right arrow has been pressed then do noting.
            if (!arrowRightPressed && !arrowLeftPressed) {
                return;
            }
            const contentDirection = locale.contentLanguageDirection;
            let isMovementHandled = false;
            if (contentDirection === 'ltr' && arrowRightPressed || contentDirection === 'rtl' && arrowLeftPressed) {
                isMovementHandled = this._handleForwardMovement(data);
            } else {
                isMovementHandled = this._handleBackwardMovement(data);
            }
            // Stop the keydown event if the two-step caret movement handled it. Avoid collisions
            // with other features which may also take over the caret movement (e.g. Widget).
            if (isMovementHandled === true) {
                evt.stop();
            }
        }, {
            context: '$text',
            priority: 'highest'
        });
        // The automatic gravity restoration logic.
        this.listenTo(modelSelection, 'change:range', (evt, data)=>{
            // Skipping the automatic restoration is needed if the selection should change
            // but the gravity must remain overridden afterwards. See the #handleBackwardMovement
            // to learn more.
            if (this._isNextGravityRestorationSkipped) {
                this._isNextGravityRestorationSkipped = false;
                return;
            }
            // Skip automatic restore when the gravity is not overridden — simply, there's nothing to restore
            // at this moment.
            if (!this._isGravityOverridden) {
                return;
            }
            // Skip automatic restore when the change is indirect AND the selection is at the attribute boundary.
            // It means that e.g. if the change was external (collaboration) and the user had their
            // selection around the link, its gravity should remain intact in this change:range event.
            if (!data.directChange && isBetweenDifferentAttributes(modelSelection.getFirstPosition(), this.attributes)) {
                return;
            }
            this._restoreGravity();
        });
        // Handle a click at the beginning/end of a two-step element.
        this._enableClickingAfterNode();
        // Change the attributes of the selection in certain situations after the two-step node was inserted into the document.
        this._enableInsertContentSelectionAttributesFixer();
        // Handle removing the content after the two-step node.
        this._handleDeleteContentAfterNode();
    }
    /**
	 * Registers a given attribute for the two-step caret movement.
	 *
	 * @param attribute Name of the attribute to handle.
	 */ registerAttribute(attribute) {
        this.attributes.add(attribute);
    }
    /**
	 * Updates the document selection and the view according to the two–step caret movement state
	 * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
	 *
	 * @param data Data of the key press.
	 * @returns `true` when the handler prevented caret movement.
	 */ _handleForwardMovement(data) {
        const attributes = this.attributes;
        const model = this.editor.model;
        const selection = model.document.selection;
        const position = selection.getFirstPosition();
        // DON'T ENGAGE 2-SCM if gravity is already overridden. It means that we just entered
        //
        // 		<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>
        //
        // or left the attribute
        //
        // 		<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>
        //
        // and the gravity will be restored automatically.
        if (this._isGravityOverridden) {
            return false;
        }
        // DON'T ENGAGE 2-SCM when the selection is at the beginning of the block AND already has the
        // attribute:
        // * when the selection was initially set there using the mouse,
        // * when the editor has just started
        //
        //		<paragraph><$text attribute>{}bar</$text>baz</paragraph>
        //
        if (position.isAtStart && hasAnyAttribute(selection, attributes)) {
            return false;
        }
        // ENGAGE 2-SCM When at least one of the observed attributes changes its value (incl. starts, ends).
        //
        //		<paragraph>foo<$text attribute>bar{}</$text>baz</paragraph>
        //		<paragraph>foo<$text attribute>bar{}</$text><$text otherAttribute>baz</$text></paragraph>
        //		<paragraph>foo<$text attribute=1>bar{}</$text><$text attribute=2>baz</$text></paragraph>
        //		<paragraph>foo{}<$text attribute>bar</$text>baz</paragraph>
        //
        if (isBetweenDifferentAttributes(position, attributes)) {
            preventCaretMovement(data);
            // CLEAR 2-SCM attributes if we are at the end of one 2-SCM and before
            // the next one with a different value of the same attribute.
            //
            //		<paragraph>foo<$text attribute=1>bar{}</$text><$text attribute=2>bar</$text>baz</paragraph>
            //
            if (hasAnyAttribute(selection, attributes) && isBetweenDifferentAttributes(position, attributes, true)) {
                clearSelectionAttributes(model, attributes);
            } else {
                this._overrideGravity();
            }
            return true;
        }
        return false;
    }
    /**
	 * Updates the document selection and the view according to the two–step caret movement state
	 * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
	 *
	 * @param data Data of the key press.
	 * @returns `true` when the handler prevented caret movement
	 */ _handleBackwardMovement(data) {
        const attributes = this.attributes;
        const model = this.editor.model;
        const selection = model.document.selection;
        const position = selection.getFirstPosition();
        // When the gravity is already overridden (by this plugin), it means we are on the two-step position.
        // Prevent the movement, restore the gravity and update selection attributes.
        //
        //		<paragraph>foo<$text attribute=1>bar</$text><$text attribute=2>{}baz</$text></paragraph>
        //		<paragraph>foo<$text attribute>bar</$text><$text otherAttribute>{}baz</$text></paragraph>
        //		<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>
        //		<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>
        //
        if (this._isGravityOverridden) {
            preventCaretMovement(data);
            this._restoreGravity();
            // CLEAR 2-SCM attributes if we are at the end of one 2-SCM and before
            // the next one with a different value of the same attribute.
            //
            //		<paragraph>foo<$text attribute=1>bar</$text><$text attribute=2>{}bar</$text>baz</paragraph>
            //
            if (isBetweenDifferentAttributes(position, attributes, true)) {
                clearSelectionAttributes(model, attributes);
            } else {
                setSelectionAttributesFromTheNodeBefore(model, attributes, position);
            }
            return true;
        } else {
            // REMOVE SELECTION ATTRIBUTE when restoring gravity towards a non-existent content at the
            // beginning of the block.
            //
            // 		<paragraph>{}<$text attribute>bar</$text></paragraph>
            //
            if (position.isAtStart) {
                if (hasAnyAttribute(selection, attributes)) {
                    preventCaretMovement(data);
                    setSelectionAttributesFromTheNodeBefore(model, attributes, position);
                    return true;
                }
                return false;
            }
            // SET 2-SCM attributes if we are between nodes with the same attribute but with different values.
            //
            //		<paragraph>foo<$text attribute=1>bar</$text>[]<$text attribute=2>bar</$text>baz</paragraph>
            //
            if (!hasAnyAttribute(selection, attributes) && isBetweenDifferentAttributes(position, attributes, true)) {
                preventCaretMovement(data);
                setSelectionAttributesFromTheNodeBefore(model, attributes, position);
                return true;
            }
            // When we are moving from natural gravity, to the position of the 2SCM, we need to override the gravity,
            // and make sure it won't be restored. Unless it's at the end of the block and an observed attribute.
            // We need to check if the caret is a one position before the attribute boundary:
            //
            //		<paragraph>foo<$text attribute=1>bar</$text><$text attribute=2>b{}az</$text></paragraph>
            //		<paragraph>foo<$text attribute>bar</$text><$text otherAttribute>b{}az</$text></paragraph>
            //		<paragraph>foo<$text attribute>b{}ar</$text>baz</paragraph>
            //		<paragraph>foo<$text attribute>bar</$text>b{}az</paragraph>
            //
            if (isStepAfterAnyAttributeBoundary(position, attributes)) {
                // ENGAGE 2-SCM if the selection has no attribute. This may happen when the user
                // left the attribute using a FORWARD 2-SCM.
                //
                // 		<paragraph><$text attribute>bar</$text>{}</paragraph>
                //
                if (position.isAtEnd && !hasAnyAttribute(selection, attributes) && isBetweenDifferentAttributes(position, attributes)) {
                    preventCaretMovement(data);
                    setSelectionAttributesFromTheNodeBefore(model, attributes, position);
                    return true;
                }
                // Skip the automatic gravity restore upon the next selection#change:range event.
                // If not skipped, it would automatically restore the gravity, which should remain
                // overridden.
                this._isNextGravityRestorationSkipped = true;
                this._overrideGravity();
                // Don't return "true" here because we didn't call _preventCaretMovement.
                // Returning here will destabilize the filler logic, which also listens to
                // keydown (and the event would be stopped).
                return false;
            }
        }
        return false;
    }
    /**
	 * Starts listening to {@link module:engine/view/document~Document#event:mousedown} and
	 * {@link module:engine/view/document~Document#event:selectionChange} and puts the selection before/after a 2-step node
	 * if clicked at the beginning/ending of the 2-step node.
	 *
	 * The purpose of this action is to allow typing around the 2-step node directly after a click.
	 *
	 * See https://github.com/ckeditor/ckeditor5/issues/1016.
	 */ _enableClickingAfterNode() {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const document = editor.editing.view.document;
        editor.editing.view.addObserver(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MouseObserver"]);
        editor.editing.view.addObserver(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TouchObserver"]);
        let touched = false;
        let clicked = false;
        // This event should be fired before selection on mobile devices.
        this.listenTo(document, 'touchstart', ()=>{
            clicked = false;
            touched = true;
        });
        // Track mouse click event.
        // Keep in mind that it's often called after the selection change on iOS devices.
        // On the Android devices, it's called before the selection change.
        // That's why we watch `touchstart` event on mobile and set `touched` flag, as it's fired before the selection change.
        // See more: https://github.com/ckeditor/ckeditor5/issues/17171
        this.listenTo(document, 'mousedown', ()=>{
            clicked = true;
        });
        // When the selection has changed...
        this.listenTo(document, 'selectionChange', ()=>{
            const attributes = this.attributes;
            if (!clicked && !touched) {
                return;
            }
            // ...and it was caused by the click or touch...
            clicked = false;
            touched = false;
            // ...and no text is selected...
            if (!selection.isCollapsed) {
                return;
            }
            // ...and clicked text is the 2-step node...
            if (!hasAnyAttribute(selection, attributes)) {
                return;
            }
            const position = selection.getFirstPosition();
            if (!isBetweenDifferentAttributes(position, attributes)) {
                return;
            }
            // The selection at the start of a block would use surrounding attributes
            // from text after the selection so just clear 2-SCM attributes.
            //
            // Also, clear attributes for selection between same attribute with different values.
            if (position.isAtStart || isBetweenDifferentAttributes(position, attributes, true)) {
                clearSelectionAttributes(model, attributes);
            } else if (!this._isGravityOverridden) {
                this._overrideGravity();
            }
        });
    }
    /**
	 * Starts listening to {@link module:engine/model/model~Model#event:insertContent} and corrects the model
	 * selection attributes if the selection is at the end of a two-step node after inserting the content.
	 *
	 * The purpose of this action is to improve the overall UX because the user is no longer "trapped" by the
	 * two-step attribute of the selection, and they can type a "clean" (`linkHref`–less) text right away.
	 *
	 * See https://github.com/ckeditor/ckeditor5/issues/6053.
	 */ _enableInsertContentSelectionAttributesFixer() {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const attributes = this.attributes;
        this.listenTo(model, 'insertContent', ()=>{
            const position = selection.getFirstPosition();
            if (hasAnyAttribute(selection, attributes) && isBetweenDifferentAttributes(position, attributes)) {
                clearSelectionAttributes(model, attributes);
            }
        }, {
            priority: 'low'
        });
    }
    /**
	 * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether
	 * removing a content right after the tow-step attribute.
	 *
	 * If so, the selection should not preserve the two-step attribute. However, if
	 * the {@link module:typing/twostepcaretmovement~TwoStepCaretMovement} plugin is active and
	 * the selection has the two-step attribute due to overridden gravity (at the end), the two-step attribute should stay untouched.
	 *
	 * The purpose of this action is to allow removing the link text and keep the selection outside the link.
	 *
	 * See https://github.com/ckeditor/ckeditor5/issues/7521.
	 */ _handleDeleteContentAfterNode() {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const view = editor.editing.view;
        let isBackspace = false;
        let shouldPreserveAttributes = false;
        // Detect pressing `Backspace`.
        this.listenTo(view.document, 'delete', (evt, data)=>{
            isBackspace = data.direction === 'backward';
        }, {
            priority: 'high'
        });
        // Before removing the content, check whether the selection is inside a two-step attribute.
        // If so, we want to preserve those attributes.
        this.listenTo(model, 'deleteContent', ()=>{
            if (!isBackspace) {
                return;
            }
            const position = selection.getFirstPosition();
            shouldPreserveAttributes = hasAnyAttribute(selection, this.attributes) && !isStepAfterAnyAttributeBoundary(position, this.attributes);
        }, {
            priority: 'high'
        });
        // After removing the content, check whether the current selection should preserve the `linkHref` attribute.
        this.listenTo(model, 'deleteContent', ()=>{
            if (!isBackspace) {
                return;
            }
            isBackspace = false;
            // Do not escape two-step attribute if it was inside it before content deletion.
            if (shouldPreserveAttributes) {
                return;
            }
            // Use `model.enqueueChange()` in order to execute the callback at the end of the changes process.
            editor.model.enqueueChange(()=>{
                const position = selection.getFirstPosition();
                if (hasAnyAttribute(selection, this.attributes) && isBetweenDifferentAttributes(position, this.attributes)) {
                    if (position.isAtStart || isBetweenDifferentAttributes(position, this.attributes, true)) {
                        clearSelectionAttributes(model, this.attributes);
                    } else if (!this._isGravityOverridden) {
                        this._overrideGravity();
                    }
                }
            });
        }, {
            priority: 'low'
        });
    }
    /**
	 * `true` when the gravity is overridden for the plugin.
	 */ get _isGravityOverridden() {
        return !!this._overrideUid;
    }
    /**
	 * Overrides the gravity using the {@link module:engine/model/writer~Writer model writer}
	 * and stores the information about this fact in the {@link #_overrideUid}.
	 *
	 * A shorthand for {@link module:engine/model/writer~Writer#overrideSelectionGravity}.
	 */ _overrideGravity() {
        this._overrideUid = this.editor.model.change((writer)=>{
            return writer.overrideSelectionGravity();
        });
    }
    /**
	 * Restores the gravity using the {@link module:engine/model/writer~Writer model writer}.
	 *
	 * A shorthand for {@link module:engine/model/writer~Writer#restoreSelectionGravity}.
	 */ _restoreGravity() {
        this.editor.model.change((writer)=>{
            writer.restoreSelectionGravity(this._overrideUid);
            this._overrideUid = null;
        });
    }
}
/**
 * Checks whether the selection has any of given attributes.
 */ function hasAnyAttribute(selection, attributes) {
    for (const observedAttribute of attributes){
        if (selection.hasAttribute(observedAttribute)) {
            return true;
        }
    }
    return false;
}
/**
 * Applies the given attributes to the current selection using using the
 * values from the node before the current position. Uses
 * the {@link module:engine/model/writer~Writer model writer}.
 */ function setSelectionAttributesFromTheNodeBefore(model, attributes, position) {
    const nodeBefore = position.nodeBefore;
    model.change((writer)=>{
        if (nodeBefore) {
            const attributes = [];
            const isInlineObject = model.schema.isObject(nodeBefore) && model.schema.isInline(nodeBefore);
            for (const [key, value] of nodeBefore.getAttributes()){
                if (model.schema.checkAttribute('$text', key) && (!isInlineObject || model.schema.getAttributeProperties(key).copyFromObject !== false)) {
                    attributes.push([
                        key,
                        value
                    ]);
                }
            }
            writer.setSelectionAttribute(attributes);
        } else {
            writer.removeSelectionAttribute(attributes);
        }
    });
}
/**
 * Removes 2-SCM attributes from the selection.
 */ function clearSelectionAttributes(model, attributes) {
    model.change((writer)=>{
        writer.removeSelectionAttribute(attributes);
    });
}
/**
 * Prevents the caret movement in the view by calling `preventDefault` on the event data.
 *
 * @alias data.preventDefault
 */ function preventCaretMovement(data) {
    data.preventDefault();
}
/**
 * Checks whether the step before `isBetweenDifferentAttributes()`.
 */ function isStepAfterAnyAttributeBoundary(position, attributes) {
    const positionBefore = position.getShiftedBy(-1);
    return isBetweenDifferentAttributes(positionBefore, attributes);
}
/**
 * Checks whether the given position is between different values of given attributes.
 */ function isBetweenDifferentAttributes(position, attributes, isStrict = false) {
    const { nodeBefore, nodeAfter } = position;
    for (const observedAttribute of attributes){
        const attrBefore = nodeBefore ? nodeBefore.getAttribute(observedAttribute) : undefined;
        const attrAfter = nodeAfter ? nodeAfter.getAttribute(observedAttribute) : undefined;
        if (isStrict && (attrBefore === undefined || attrAfter === undefined)) {
            continue;
        }
        if (attrAfter !== attrBefore) {
            return true;
        }
    }
    return false;
}
// All named transformations.
const TRANSFORMATIONS = {
    // Common symbols:
    copyright: {
        from: '(c)',
        to: '©'
    },
    registeredTrademark: {
        from: '(r)',
        to: '®'
    },
    trademark: {
        from: '(tm)',
        to: '™'
    },
    // Mathematical:
    oneHalf: {
        from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i,
        to: [
            null,
            '½',
            null
        ]
    },
    oneThird: {
        from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i,
        to: [
            null,
            '⅓',
            null
        ]
    },
    twoThirds: {
        from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i,
        to: [
            null,
            '⅔',
            null
        ]
    },
    oneForth: {
        from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i,
        to: [
            null,
            '¼',
            null
        ]
    },
    threeQuarters: {
        from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i,
        to: [
            null,
            '¾',
            null
        ]
    },
    lessThanOrEqual: {
        from: '<=',
        to: '≤'
    },
    greaterThanOrEqual: {
        from: '>=',
        to: '≥'
    },
    notEqual: {
        from: '!=',
        to: '≠'
    },
    arrowLeft: {
        from: '<-',
        to: '←'
    },
    arrowRight: {
        from: '->',
        to: '→'
    },
    // Typography:
    horizontalEllipsis: {
        from: '...',
        to: '…'
    },
    enDash: {
        from: /(^| )(--)( )$/,
        to: [
            null,
            '–',
            null
        ]
    },
    emDash: {
        from: /(^| )(---)( )$/,
        to: [
            null,
            '—',
            null
        ]
    },
    // Quotations:
    // English, US
    quotesPrimary: {
        from: buildQuotesRegExp('"'),
        to: [
            null,
            '“',
            null,
            '”'
        ]
    },
    quotesSecondary: {
        from: buildQuotesRegExp('\''),
        to: [
            null,
            '‘',
            null,
            '’'
        ]
    },
    // English, UK
    quotesPrimaryEnGb: {
        from: buildQuotesRegExp('\''),
        to: [
            null,
            '‘',
            null,
            '’'
        ]
    },
    quotesSecondaryEnGb: {
        from: buildQuotesRegExp('"'),
        to: [
            null,
            '“',
            null,
            '”'
        ]
    },
    // Polish
    quotesPrimaryPl: {
        from: buildQuotesRegExp('"'),
        to: [
            null,
            '„',
            null,
            '”'
        ]
    },
    quotesSecondaryPl: {
        from: buildQuotesRegExp('\''),
        to: [
            null,
            '‚',
            null,
            '’'
        ]
    }
};
// Transformation groups.
const TRANSFORMATION_GROUPS = {
    symbols: [
        'copyright',
        'registeredTrademark',
        'trademark'
    ],
    mathematical: [
        'oneHalf',
        'oneThird',
        'twoThirds',
        'oneForth',
        'threeQuarters',
        'lessThanOrEqual',
        'greaterThanOrEqual',
        'notEqual',
        'arrowLeft',
        'arrowRight'
    ],
    typography: [
        'horizontalEllipsis',
        'enDash',
        'emDash'
    ],
    quotes: [
        'quotesPrimary',
        'quotesSecondary'
    ]
};
// A set of default transformations provided by the feature.
const DEFAULT_TRANSFORMATIONS = [
    'symbols',
    'mathematical',
    'typography',
    'quotes'
];
/**
 * The text transformation plugin.
 */ class TextTransformation extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            'Delete',
            'Input'
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'TextTransformation';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('typing', {
            transformations: {
                include: DEFAULT_TRANSFORMATIONS
            }
        });
    }
    /**
	 * @inheritDoc
	 */ init() {
        const model = this.editor.model;
        const modelSelection = model.document.selection;
        modelSelection.on('change:range', ()=>{
            // Disable plugin when selection is inside a code block.
            this.isEnabled = !modelSelection.anchor.parent.is('element', 'codeBlock');
        });
        this._enableTransformationWatchers();
    }
    /**
	 * Create new TextWatcher listening to the editor for typing and selection events.
	 */ _enableTransformationWatchers() {
        const editor = this.editor;
        const model = editor.model;
        const deletePlugin = editor.plugins.get('Delete');
        const normalizedTransformations = normalizeTransformations(editor.config.get('typing.transformations'));
        const testCallback = (text)=>{
            for (const normalizedTransformation of normalizedTransformations){
                const from = normalizedTransformation.from;
                const match = from.test(text);
                if (match) {
                    return {
                        normalizedTransformation
                    };
                }
            }
        };
        const watcher = new TextWatcher(editor.model, testCallback);
        watcher.on('matched:data', (evt, data)=>{
            if (!data.batch.isTyping) {
                return;
            }
            const { from, to } = data.normalizedTransformation;
            const matches = from.exec(data.text);
            const replaces = to(matches.slice(1));
            const matchedRange = data.range;
            let changeIndex = matches.index;
            model.enqueueChange((writer)=>{
                for(let i = 1; i < matches.length; i++){
                    const match = matches[i];
                    const replaceWith = replaces[i - 1];
                    if (replaceWith == null) {
                        changeIndex += match.length;
                        continue;
                    }
                    const replacePosition = matchedRange.start.getShiftedBy(changeIndex);
                    const replaceRange = model.createRange(replacePosition, replacePosition.getShiftedBy(match.length));
                    const attributes = getTextAttributesAfterPosition(replacePosition);
                    model.insertContent(writer.createText(replaceWith, attributes), replaceRange);
                    changeIndex += replaceWith.length;
                }
                model.enqueueChange(()=>{
                    deletePlugin.requestUndoOnBackspace();
                });
            });
        });
        watcher.bind('isEnabled').to(this);
    }
}
/**
 * Normalizes the configuration `from` parameter value.
 * The normalized value for the `from` parameter is a RegExp instance. If the passed `from` is already a RegExp instance,
 * it is returned unchanged.
 */ function normalizeFrom(from) {
    if (typeof from == 'string') {
        return new RegExp(`(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$escapeRegExp$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__escapeRegExp$3e$__["escapeRegExp"])(from)})$`);
    }
    // `from` is already a regular expression.
    return from;
}
/**
 * Normalizes the configuration `to` parameter value.
 * The normalized value for the `to` parameter is a function that takes an array and returns an array. See more in the
 * configuration description. If the passed `to` is already a function, it is returned unchanged.
 */ function normalizeTo(to) {
    if (typeof to == 'string') {
        return ()=>[
                to
            ];
    } else if (to instanceof Array) {
        return ()=>to;
    }
    // `to` is already a function.
    return to;
}
/**
 * For given `position` returns attributes for the text that is after that position.
 * The text can be in the same text node as the position (`foo[]bar`) or in the next text node (`foo[]<$text bold="true">bar</$text>`).
 */ function getTextAttributesAfterPosition(position) {
    const textNode = position.textNode ? position.textNode : position.nodeAfter;
    return textNode.getAttributes();
}
/**
 * Returns a RegExp pattern string that detects a sentence inside a quote.
 *
 * @param quoteCharacter The character to create a pattern for.
 */ function buildQuotesRegExp(quoteCharacter) {
    return new RegExp(`(^|\\s)(${quoteCharacter})([^${quoteCharacter}]*)(${quoteCharacter})$`);
}
/**
 * Reads text transformation config and returns normalized array of transformations objects.
 */ function normalizeTransformations(config) {
    const extra = config.extra || [];
    const remove = config.remove || [];
    const isNotRemoved = (transformation)=>!remove.includes(transformation);
    const configured = config.include.concat(extra).filter(isNotRemoved);
    return expandGroupsAndRemoveDuplicates(configured).filter(isNotRemoved) // Filter out 'remove' transformations as they might be set in group.
    .map((transformation)=>typeof transformation == 'string' && TRANSFORMATIONS[transformation] ? TRANSFORMATIONS[transformation] : transformation) // Filter out transformations set as string that has not been found.
    .filter((transformation)=>typeof transformation === 'object').map((transformation)=>({
            from: normalizeFrom(transformation.from),
            to: normalizeTo(transformation.to)
        }));
}
/**
 * Reads definitions and expands named groups if needed to transformation names.
 * This method also removes duplicated named transformations if any.
 */ function expandGroupsAndRemoveDuplicates(definitions) {
    // Set is using to make sure that transformation names are not duplicated.
    const definedTransformations = new Set();
    for (const transformationOrGroup of definitions){
        if (typeof transformationOrGroup == 'string' && TRANSFORMATION_GROUPS[transformationOrGroup]) {
            for (const transformation of TRANSFORMATION_GROUPS[transformationOrGroup]){
                definedTransformations.add(transformation);
            }
        } else {
            definedTransformations.add(transformationOrGroup);
        }
    }
    return Array.from(definedTransformations);
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module typing/utils/findattributerange
 */ /**
 * Returns a model range that covers all consecutive nodes with the same `attributeName` and its `value`
 * that intersect the given `position`.
 *
 * It can be used e.g. to get the entire range on which the `linkHref` attribute needs to be changed when having a
 * selection inside a link.
 *
 * @param position The start position.
 * @param attributeName The attribute name.
 * @param value The attribute value.
 * @param model The model instance.
 * @returns The link range.
 */ function findAttributeRange(position, attributeName, value, model) {
    return model.createRange(findAttributeRangeBound(position, attributeName, value, true, model), findAttributeRangeBound(position, attributeName, value, false, model));
}
/**
 * Walks forward or backward (depends on the `lookBack` flag), node by node, as long as they have the same attribute value
 * and returns a position just before or after (depends on the `lookBack` flag) the last matched node.
 *
 * @param position The start position.
 * @param attributeName The attribute name.
 * @param value The attribute value.
 * @param lookBack Whether the walk direction is forward (`false`) or backward (`true`).
 * @returns The position just before the last matched node.
 */ function findAttributeRangeBound(position, attributeName, value, lookBack, model) {
    // Get node before or after position (depends on `lookBack` flag).
    // When position is inside text node then start searching from text node.
    let node = position.textNode || (lookBack ? position.nodeBefore : position.nodeAfter);
    let lastNode = null;
    while(node && node.getAttribute(attributeName) == value){
        lastNode = node;
        node = lookBack ? node.previousSibling : node.nextSibling;
    }
    return lastNode ? model.createPositionAt(lastNode, lookBack ? 'before' : 'after') : position;
}
/**
 * Adds a visual highlight style to an attribute element in which the selection is anchored.
 * Together with two-step caret movement, they indicate that the user is typing inside the element.
 *
 * Highlight is turned on by adding the given class to the attribute element in the view:
 *
 * * The class is removed before the conversion has started, as callbacks added with the `'highest'` priority
 * to {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} events.
 * * The class is added in the view post fixer, after other changes in the model tree were converted to the view.
 *
 * This way, adding and removing the highlight does not interfere with conversion.
 *
 * Usage:
 *
 * ```ts
 * import inlineHighlight from '@ckeditor/ckeditor5-typing/src/utils/inlinehighlight';
 *
 * // Make `ck-link_selected` class be applied on an `a` element
 * // whenever the corresponding `linkHref` attribute element is selected.
 * inlineHighlight( editor, 'linkHref', 'a', 'ck-link_selected' );
 * ```
 *
 * @param editor The editor instance.
 * @param attributeName The attribute name to check.
 * @param tagName The tagName of a view item.
 * @param className The class name to apply in the view.
 */ function inlineHighlight(editor, attributeName, tagName, className) {
    const view = editor.editing.view;
    const highlightedElements = new Set();
    // Adding the class.
    view.document.registerPostFixer((writer)=>{
        const selection = editor.model.document.selection;
        let changed = false;
        if (selection.hasAttribute(attributeName)) {
            const modelRange = findAttributeRange(selection.getFirstPosition(), attributeName, selection.getAttribute(attributeName), editor.model);
            const viewRange = editor.editing.mapper.toViewRange(modelRange);
            // There might be multiple view elements in the `viewRange`, for example, when the `a` element is
            // broken by a UIElement.
            for (const item of viewRange.getItems()){
                if (item.is('element', tagName) && !item.hasClass(className)) {
                    writer.addClass(className, item);
                    highlightedElements.add(item);
                    changed = true;
                }
            }
        }
        return changed;
    });
    // Removing the class.
    editor.conversion.for('editingDowncast').add((dispatcher)=>{
        // Make sure the highlight is removed on every possible event, before conversion is started.
        dispatcher.on('insert', removeHighlight, {
            priority: 'highest'
        });
        dispatcher.on('remove', removeHighlight, {
            priority: 'highest'
        });
        dispatcher.on('attribute', removeHighlight, {
            priority: 'highest'
        });
        dispatcher.on('selection', removeHighlight, {
            priority: 'highest'
        });
        function removeHighlight() {
            view.change((writer)=>{
                for (const item of highlightedElements.values()){
                    writer.removeClass(className, item);
                    highlightedElements.delete(item);
                }
            });
        }
    });
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-autoformat/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Autoformat": (()=>Autoformat),
    "blockAutoformatEditing": (()=>blockAutoformatEditing),
    "inlineAutoformatEditing": (()=>inlineAutoformatEditing)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-typing/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
;
;
;
;
/**
 * The block autoformatting engine. It allows to format various block patterns. For example,
 * it can be configured to turn a paragraph starting with `*` and followed by a space into a list item.
 *
 * The autoformatting operation is integrated with the undo manager,
 * so the autoformatting step can be undone if the user's intention was not to format the text.
 *
 * See the {@link module:autoformat/blockautoformatediting~blockAutoformatEditing `blockAutoformatEditing`} documentation
 * to learn how to create custom block autoformatters. You can also use
 * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters
 * (lists, headings, bold and italic).
 *
 * @module autoformat/blockautoformatediting
 */ /**
 * Creates a listener triggered on {@link module:engine/model/document~Document#event:change:data `change:data`} event in the document.
 * Calls the callback when inserted text matches the regular expression or the command name
 * if provided instead of the callback.
 *
 * Examples of usage:
 *
 * To convert a paragraph into heading 1 when `- ` is typed, using just the command name:
 *
 * ```ts
 * blockAutoformatEditing( editor, plugin, /^\- $/, 'heading1' );
 * ```
 *
 * To convert a paragraph into heading 1 when `- ` is typed, using just the callback:
 *
 * ```ts
 * blockAutoformatEditing( editor, plugin, /^\- $/, ( context ) => {
 * 	const { match } = context;
 * 	const headingLevel = match[ 1 ].length;
 *
 * 	editor.execute( 'heading', {
 * 		formatId: `heading${ headingLevel }`
 * 	} );
 * } );
 * ```
 *
 * @param editor The editor instance.
 * @param plugin The autoformat plugin instance.
 * @param pattern The regular expression to execute on just inserted text. The regular expression is tested against the text
 * from the beginning until the caret position.
 * @param callbackOrCommand The callback to execute or the command to run when the text is matched.
 * In case of providing the callback, it receives the following parameter:
 * * match RegExp.exec() result of matching the pattern to inserted text.
 */ function blockAutoformatEditing(editor, plugin, pattern, callbackOrCommand) {
    let callback;
    let command = null;
    if (typeof callbackOrCommand == 'function') {
        callback = callbackOrCommand;
    } else {
        // We assume that the actual command name was provided.
        command = editor.commands.get(callbackOrCommand);
        callback = ()=>{
            editor.execute(callbackOrCommand);
        };
    }
    editor.model.document.on('change:data', (evt, batch)=>{
        if (command && !command.isEnabled || !plugin.isEnabled) {
            return;
        }
        const range = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(editor.model.document.selection.getRanges());
        if (!range.isCollapsed) {
            return;
        }
        if (batch.isUndo || !batch.isLocal) {
            return;
        }
        const changes = Array.from(editor.model.document.differ.getChanges());
        const entry = changes[0];
        // Typing is represented by only a single change.
        if (changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1) {
            return;
        }
        const blockToFormat = entry.position.parent;
        // Block formatting should be disabled in codeBlocks (#5800).
        if (blockToFormat.is('element', 'codeBlock')) {
            return;
        }
        // Only list commands and custom callbacks can be applied inside a list.
        if (blockToFormat.is('element', 'listItem') && typeof callbackOrCommand !== 'function' && ![
            'numberedList',
            'bulletedList',
            'todoList'
        ].includes(callbackOrCommand)) {
            return;
        }
        // In case a command is bound, do not re-execute it over an existing block style which would result in a style removal.
        // Instead, just drop processing so that autoformat trigger text is not lost. E.g. writing "# " in a level 1 heading.
        if (command && command.value === true) {
            return;
        }
        const firstNode = blockToFormat.getChild(0);
        const firstNodeRange = editor.model.createRangeOn(firstNode);
        // Range is only expected to be within or at the very end of the first text node.
        if (!firstNodeRange.containsRange(range) && !range.end.isEqual(firstNodeRange.end)) {
            return;
        }
        const match = pattern.exec(firstNode.data.substr(0, range.end.offset));
        // ...and this text node's data match the pattern.
        if (!match) {
            return;
        }
        // Use enqueueChange to create new batch to separate typing batch from the auto-format changes.
        editor.model.enqueueChange((writer)=>{
            // Matched range.
            const start = writer.createPositionAt(blockToFormat, 0);
            const end = writer.createPositionAt(blockToFormat, match[0].length);
            const range = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LiveRange"](start, end);
            const wasChanged = callback({
                match
            });
            // Remove matched text.
            if (wasChanged !== false) {
                writer.remove(range);
                const selectionRange = editor.model.document.selection.getFirstRange();
                const blockRange = writer.createRangeIn(blockToFormat);
                // If the block is empty and the document selection has been moved when
                // applying formatting (e.g. is now in newly created block).
                if (blockToFormat.isEmpty && !blockRange.isEqual(selectionRange) && !blockRange.containsRange(selectionRange, true)) {
                    writer.remove(blockToFormat);
                }
            }
            range.detach();
            editor.model.enqueueChange(()=>{
                const deletePlugin = editor.plugins.get('Delete');
                deletePlugin.requestUndoOnBackspace();
            });
        });
    });
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * The inline autoformatting engine. It allows to format various inline patterns. For example,
 * it can be configured to make "foo" bold when typed `**foo**` (the `**` markers will be removed).
 *
 * The autoformatting operation is integrated with the undo manager,
 * so the autoformatting step can be undone if the user's intention was not to format the text.
 *
 * See the {@link module:autoformat/inlineautoformatediting~inlineAutoformatEditing `inlineAutoformatEditing`} documentation
 * to learn how to create custom inline autoformatters. You can also use
 * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters
 * (lists, headings, bold and italic).
 *
 * @module autoformat/inlineautoformatediting
 */ /**
 * Enables autoformatting mechanism for a given {@link module:core/editor/editor~Editor}.
 *
 * It formats the matched text by applying the given model attribute or by running the provided formatting callback.
 * On every {@link module:engine/model/document~Document#event:change:data data change} in the model document
 * the autoformatting engine checks the text on the left of the selection
 * and executes the provided action if the text matches given criteria (regular expression or callback).
 *
 * @param editor The editor instance.
 * @param plugin The autoformat plugin instance.
 * @param testRegexpOrCallback The regular expression or callback to execute on text.
 * Provided regular expression *must* have three capture groups. The first and the third capture group
 * should match opening and closing delimiters. The second capture group should match the text to format.
 *
 * ```ts
 * // Matches the `**bold text**` pattern.
 * // There are three capturing groups:
 * // - The first to match the starting `**` delimiter.
 * // - The second to match the text to format.
 * // - The third to match the ending `**` delimiter.
 * inlineAutoformatEditing( editor, plugin, /(\*\*)([^\*]+?)(\*\*)$/g, formatCallback );
 * ```
 *
 * When a function is provided instead of the regular expression, it will be executed with the text to match as a parameter.
 * The function should return proper "ranges" to delete and format.
 *
 * ```ts
 * {
 * 	remove: [
 * 		[ 0, 1 ],	// Remove the first letter from the given text.
 * 		[ 5, 6 ]	// Remove the 6th letter from the given text.
 * 	],
 * 	format: [
 * 		[ 1, 5 ]	// Format all letters from 2nd to 5th.
 * 	]
 * }
 * ```
 *
 * @param formatCallback A callback to apply actual formatting.
 * It should return `false` if changes should not be applied (e.g. if a command is disabled).
 *
 * ```ts
 * inlineAutoformatEditing( editor, plugin, /(\*\*)([^\*]+?)(\*\*)$/g, ( writer, rangesToFormat ) => {
 * 	const command = editor.commands.get( 'bold' );
 *
 * 	if ( !command.isEnabled ) {
 * 		return false;
 * 	}
 *
 * 	const validRanges = editor.model.schema.getValidRanges( rangesToFormat, 'bold' );
 *
 * 	for ( let range of validRanges ) {
 * 		writer.setAttribute( 'bold', true, range );
 * 	}
 * } );
 * ```
 */ function inlineAutoformatEditing(editor, plugin, testRegexpOrCallback, formatCallback) {
    let regExp;
    let testCallback;
    if (testRegexpOrCallback instanceof RegExp) {
        regExp = testRegexpOrCallback;
    } else {
        testCallback = testRegexpOrCallback;
    }
    // A test callback run on changed text.
    testCallback = testCallback || ((text)=>{
        let result;
        const remove = [];
        const format = [];
        while((result = regExp.exec(text)) !== null){
            // There should be full match and 3 capture groups.
            if (result && result.length < 4) {
                break;
            }
            let { index, '1': leftDel, '2': content, '3': rightDel } = result;
            // Real matched string - there might be some non-capturing groups so we need to recalculate starting index.
            const found = leftDel + content + rightDel;
            index += result[0].length - found.length;
            // Start and End offsets of delimiters to remove.
            const delStart = [
                index,
                index + leftDel.length
            ];
            const delEnd = [
                index + leftDel.length + content.length,
                index + leftDel.length + content.length + rightDel.length
            ];
            remove.push(delStart);
            remove.push(delEnd);
            format.push([
                index + leftDel.length,
                index + leftDel.length + content.length
            ]);
        }
        return {
            remove,
            format
        };
    });
    editor.model.document.on('change:data', (evt, batch)=>{
        if (batch.isUndo || !batch.isLocal || !plugin.isEnabled) {
            return;
        }
        const model = editor.model;
        const selection = model.document.selection;
        // Do nothing if selection is not collapsed.
        if (!selection.isCollapsed) {
            return;
        }
        const changes = Array.from(model.document.differ.getChanges());
        const entry = changes[0];
        // Typing is represented by only a single change.
        if (changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1) {
            return;
        }
        const focus = selection.focus;
        const block = focus.parent;
        const { text, range } = getTextAfterCode(model.createRange(model.createPositionAt(block, 0), focus), model);
        const testOutput = testCallback(text);
        const rangesToFormat = testOutputToRanges(range.start, testOutput.format, model);
        const rangesToRemove = testOutputToRanges(range.start, testOutput.remove, model);
        if (!(rangesToFormat.length && rangesToRemove.length)) {
            return;
        }
        // Use enqueueChange to create new batch to separate typing batch from the auto-format changes.
        model.enqueueChange((writer)=>{
            // Apply format.
            const hasChanged = formatCallback(writer, rangesToFormat);
            // Strict check on `false` to have backward compatibility (when callbacks were returning `undefined`).
            if (hasChanged === false) {
                return;
            }
            // Remove delimiters - use reversed order to not mix the offsets while removing.
            for (const range of rangesToRemove.reverse()){
                writer.remove(range);
            }
            model.enqueueChange(()=>{
                const deletePlugin = editor.plugins.get('Delete');
                deletePlugin.requestUndoOnBackspace();
            });
        });
    });
}
/**
 * Converts output of the test function provided to the inlineAutoformatEditing and converts it to the model ranges
 * inside provided block.
 */ function testOutputToRanges(start, arrays, model) {
    return arrays.filter((array)=>array[0] !== undefined && array[1] !== undefined).map((array)=>{
        return model.createRange(start.getShiftedBy(array[0]), start.getShiftedBy(array[1]));
    });
}
/**
 * Returns the last text line after the last code element from the given range.
 * It is similar to {@link module:typing/utils/getlasttextline.getLastTextLine `getLastTextLine()`},
 * but it ignores any text before the last `code`.
 */ function getTextAfterCode(range, model) {
    let start = range.start;
    const text = Array.from(range.getItems()).reduce((rangeText, node)=>{
        // Trim text to a last occurrence of an inline element and update range start.
        if (!(node.is('$text') || node.is('$textProxy')) || node.getAttribute('code')) {
            start = model.createPositionAfter(node);
            return '';
        }
        return rangeText + node.data;
    }, '');
    return {
        text,
        range: model.createRange(start, range.end)
    };
}
/**
 * Enables a set of predefined autoformatting actions.
 *
 * For a detailed overview, check the {@glink features/autoformat Autoformatting} feature guide
 * and the {@glink api/autoformat package page}.
 */ class Autoformat extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Delete"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Autoformat';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        const editor = this.editor;
        const t = this.editor.t;
        this._addListAutoformats();
        this._addBasicStylesAutoformats();
        this._addHeadingAutoformats();
        this._addBlockQuoteAutoformats();
        this._addCodeBlockAutoformats();
        this._addHorizontalLineAutoformats();
        // Add the information about the keystroke to the accessibility database.
        editor.accessibility.addKeystrokeInfos({
            keystrokes: [
                {
                    label: t('Revert autoformatting action'),
                    keystroke: 'Backspace'
                }
            ]
        });
    }
    /**
	 * Adds autoformatting related to the {@link module:list/list~List}.
	 *
	 * When typed:
	 * - `* ` or `- ` &ndash; A paragraph will be changed into a bulleted list.
	 * - `1. ` or `1) ` &ndash; A paragraph will be changed into a numbered list ("1" can be any digit or a list of digits).
	 * - `[] ` or `[ ] ` &ndash; A paragraph will be changed into a to-do list.
	 * - `[x] ` or `[ x ] ` &ndash; A paragraph will be changed into a checked to-do list.
	 */ _addListAutoformats() {
        const commands = this.editor.commands;
        if (commands.get('bulletedList')) {
            blockAutoformatEditing(this.editor, this, /^[*-]\s$/, 'bulletedList');
        }
        if (commands.get('numberedList')) {
            blockAutoformatEditing(this.editor, this, /^1[.|)]\s$/, 'numberedList');
        }
        if (commands.get('todoList')) {
            blockAutoformatEditing(this.editor, this, /^\[\s?\]\s$/, 'todoList');
        }
        if (commands.get('checkTodoList')) {
            blockAutoformatEditing(this.editor, this, /^\[\s?x\s?\]\s$/, ()=>{
                this.editor.execute('todoList');
                this.editor.execute('checkTodoList');
            });
        }
    }
    /**
	 * Adds autoformatting related to the {@link module:basic-styles/bold~Bold},
	 * {@link module:basic-styles/italic~Italic}, {@link module:basic-styles/code~Code}
	 * and {@link module:basic-styles/strikethrough~Strikethrough}
	 *
	 * When typed:
	 * - `**foobar**` &ndash; `**` characters are removed and `foobar` is set to bold,
	 * - `__foobar__` &ndash; `__` characters are removed and `foobar` is set to bold,
	 * - `*foobar*` &ndash; `*` characters are removed and `foobar` is set to italic,
	 * - `_foobar_` &ndash; `_` characters are removed and `foobar` is set to italic,
	 * - ``` `foobar` &ndash; ``` ` ``` characters are removed and `foobar` is set to code,
	 * - `~~foobar~~` &ndash; `~~` characters are removed and `foobar` is set to strikethrough.
	 */ _addBasicStylesAutoformats() {
        const commands = this.editor.commands;
        if (commands.get('bold')) {
            const boldCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'bold');
            inlineAutoformatEditing(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, boldCallback);
            inlineAutoformatEditing(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, boldCallback);
        }
        if (commands.get('italic')) {
            const italicCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'italic');
            // The italic autoformatter cannot be triggered by the bold markers, so we need to check the
            // text before the pattern (e.g. `(?:^|[^\*])`).
            inlineAutoformatEditing(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, italicCallback);
            inlineAutoformatEditing(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, italicCallback);
        }
        if (commands.get('code')) {
            const codeCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'code');
            inlineAutoformatEditing(this.editor, this, /(`)([^`]+)(`)$/g, codeCallback);
        }
        if (commands.get('strikethrough')) {
            const strikethroughCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'strikethrough');
            inlineAutoformatEditing(this.editor, this, /(~~)([^~]+)(~~)$/g, strikethroughCallback);
        }
    }
    /**
	 * Adds autoformatting related to {@link module:heading/heading~Heading}.
	 *
	 * It is using a number at the end of the command name to associate it with the proper trigger:
	 *
	 * * `heading` with a `heading1` value will be executed when typing `#`,
	 * * `heading` with a `heading2` value will be executed when typing `##`,
	 * * ... up to `heading6` for `######`.
	 */ _addHeadingAutoformats() {
        const command = this.editor.commands.get('heading');
        if (command) {
            command.modelElements.filter((name)=>name.match(/^heading[1-6]$/)).forEach((modelName)=>{
                const level = modelName[7];
                const pattern = new RegExp(`^(#{${level}})\\s$`);
                blockAutoformatEditing(this.editor, this, pattern, ()=>{
                    // Should only be active if command is enabled and heading style associated with pattern is inactive.
                    if (!command.isEnabled || command.value === modelName) {
                        return false;
                    }
                    this.editor.execute('heading', {
                        value: modelName
                    });
                });
            });
        }
    }
    /**
	 * Adds autoformatting related to {@link module:block-quote/blockquote~BlockQuote}.
	 *
	 * When typed:
	 * * `> ` &ndash; A paragraph will be changed to a block quote.
	 */ _addBlockQuoteAutoformats() {
        if (this.editor.commands.get('blockQuote')) {
            blockAutoformatEditing(this.editor, this, /^>\s$/, 'blockQuote');
        }
    }
    /**
	 * Adds autoformatting related to {@link module:code-block/codeblock~CodeBlock}.
	 *
	 * When typed:
	 * - `` ``` `` &ndash; A paragraph will be changed to a code block.
	 */ _addCodeBlockAutoformats() {
        const editor = this.editor;
        const selection = editor.model.document.selection;
        if (editor.commands.get('codeBlock')) {
            blockAutoformatEditing(editor, this, /^```$/, ()=>{
                if (selection.getFirstPosition().parent.is('element', 'listItem')) {
                    return false;
                }
                this.editor.execute('codeBlock', {
                    usePreviousLanguageChoice: true
                });
            });
        }
    }
    /**
	 * Adds autoformatting related to {@link module:horizontal-line/horizontalline~HorizontalLine}.
	 *
	 * When typed:
	 * - `` --- `` &ndash; Will be replaced with a horizontal line.
	 */ _addHorizontalLineAutoformats() {
        if (this.editor.commands.get('horizontalLine')) {
            blockAutoformatEditing(this.editor, this, /^---$/, 'horizontalLine');
        }
    }
}
/**
 * Helper function for getting `inlineAutoformatEditing` callbacks that checks if command is enabled.
 */ function getCallbackFunctionForInlineAutoformat(editor, attributeKey) {
    return (writer, rangesToFormat)=>{
        const command = editor.commands.get(attributeKey);
        if (!command.isEnabled) {
            return false;
        }
        const validRanges = editor.model.schema.getValidRanges(rangesToFormat, attributeKey);
        for (const range of validRanges){
            writer.setAttribute(attributeKey, true, range);
        }
        // After applying attribute to the text, remove given attribute from the selection.
        // This way user is able to type a text without attribute used by auto formatter.
        writer.removeSelectionAttribute(attributeKey);
    };
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-autosave/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Autosave": (()=>Autosave)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$debounce$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__debounce$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/debounce.js [app-client] (ecmascript) <export default as debounce>");
;
;
;
/* globals window */ /**
 * The {@link module:autosave/autosave~Autosave} plugin allows you to automatically save the data (e.g. send it to the server)
 * when needed (when the user changed the content).
 *
 * It listens to the {@link module:engine/model/document~Document#event:change:data `editor.model.document#change:data`}
 * and `window#beforeunload` events and calls the
 * {@link module:autosave/autosave~AutosaveAdapter#save `config.autosave.save()`} function.
 *
 * ```ts
 * ClassicEditor
 * 	.create( document.querySelector( '#editor' ), {
 * 		plugins: [ ArticlePluginSet, Autosave ],
 * 		toolbar: [ 'heading', '|', 'bold', 'italic', 'link', 'bulletedList', 'numberedList', 'blockQuote', 'undo', 'redo' ],
 * 		image: {
 * 			toolbar: [ 'imageStyle:block', 'imageStyle:side', '|', 'toggleImageCaption', 'imageTextAlternative' ],
 * 		},
 * 		autosave: {
 * 			save( editor: Editor ) {
 * 				// The saveData() function must return a promise
 * 				// which should be resolved when the data is successfully saved.
 * 				return saveData( editor.getData() );
 * 			}
 * 		}
 * 	} );
 * ```
 *
 * Read more about this feature in the {@glink features/autosave Autosave} feature guide.
 */ class Autosave extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * The adapter is an object with a `save()` method. That method will be called whenever
	 * the data changes. It might be called some time after the change,
	 * since the event is throttled for performance reasons.
	 */ adapter;
    /**
	 * Debounced save method. The `save()` method is called the specified `waitingTime` after `debouncedSave()` is called,
	 * unless a new action happens in the meantime.
	 */ _debouncedSave;
    /**
	 * The last saved document version.
	 */ _lastDocumentVersion;
    /**
	 * Promise used for asynchronous save calls.
	 *
	 * Created to handle the autosave call to an external data source. It resolves when that call is finished. It is re-used if
	 * save is called before the promise has been resolved. It is set to `null` if there is no call in progress.
	 */ _savePromise;
    /**
	 * DOM emitter.
	 */ _domEmitter;
    /**
	 * The configuration of this plugins.
	 */ _config;
    /**
	 * Editor's pending actions manager.
	 */ _pendingActions;
    /**
	 * Informs whether there should be another autosave callback performed, immediately after current autosave callback finishes.
	 *
	 * This is set to `true` when there is a save request while autosave callback is already being processed
	 * and the model has changed since the last save.
	 */ _makeImmediateSave;
    /**
	 * An action that will be added to the pending action manager for actions happening in that plugin.
	 */ _action = null;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Autosave';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PendingActions"]
        ];
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        const config = editor.config.get('autosave') || {};
        // A minimum amount of time that needs to pass after the last action.
        // After that time the provided save callbacks are being called.
        const waitingTime = config.waitingTime || 1000;
        this.set('state', 'synchronized');
        this._debouncedSave = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$debounce$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__debounce$3e$__["debounce"])(this._save.bind(this), waitingTime);
        this._lastDocumentVersion = editor.model.document.version;
        this._savePromise = null;
        this._domEmitter = new ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DomEmitterMixin"])())();
        this._config = config;
        this._pendingActions = editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PendingActions"]);
        this._makeImmediateSave = false;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const doc = editor.model.document;
        // Add the listener only after the editor is initialized to prevent firing save callback on data init.
        this.listenTo(editor, 'ready', ()=>{
            this.listenTo(doc, 'change:data', (evt, batch)=>{
                if (!this._saveCallbacks.length) {
                    return;
                }
                if (!batch.isLocal) {
                    return;
                }
                if (this.state === 'synchronized') {
                    this.state = 'waiting';
                    // Set pending action already when we are waiting for the autosave callback.
                    this._setPendingAction();
                }
                if (this.state === 'waiting') {
                    this._debouncedSave();
                }
            // If the plugin is in `saving` state, it will change its state later basing on the `document.version`.
            // If the `document.version` will be higher than stored `#_lastDocumentVersion`, then it means, that some `change:data`
            // event has fired in the meantime.
            });
        });
        // Flush on the editor's destroy listener with the highest priority to ensure that
        // `editor.getData()` will be called before plugins are destroyed.
        this.listenTo(editor, 'destroy', ()=>this._flush(), {
            priority: 'highest'
        });
        // It's not possible to easy test it because karma uses `beforeunload` event
        // to warn before full page reload and this event cannot be dispatched manually.
        /* istanbul ignore next -- @preserve */ this._domEmitter.listenTo(window, 'beforeunload', (evtInfo, domEvt)=>{
            if (this._pendingActions.hasAny) {
                domEvt.returnValue = this._pendingActions.first.message;
            }
        });
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        // There's no need for canceling or flushing the throttled save, as
        // it's done on the editor's destroy event with the highest priority.
        this._domEmitter.stopListening();
        super.destroy();
    }
    /**
	 * Immediately calls autosave callback. All previously queued (debounced) callbacks are cleared. If there is already an autosave
	 * callback in progress, then the requested save will be performed immediately after the current callback finishes.
	 *
	 * @returns A promise that will be resolved when the autosave callback is finished.
	 */ save() {
        this._debouncedSave.cancel();
        return this._save();
    }
    /**
	 * Invokes the remaining `_save()` method call.
	 */ _flush() {
        this._debouncedSave.flush();
    }
    /**
	 * If the adapter is set and a new document version exists,
	 * the `_save()` method creates a pending action and calls the `adapter.save()` method.
	 * It waits for the result and then removes the created pending action.
	 *
	 * @returns A promise that will be resolved when the autosave callback is finished.
	 */ _save() {
        if (this._savePromise) {
            this._makeImmediateSave = this.editor.model.document.version > this._lastDocumentVersion;
            return this._savePromise;
        }
        // Make sure there is a pending action (in case if `_save()` was called through manual `save()` call).
        this._setPendingAction();
        this.state = 'saving';
        this._lastDocumentVersion = this.editor.model.document.version;
        // Wait one promise cycle to be sure that save callbacks are not called inside a conversion or when the editor's state changes.
        this._savePromise = Promise.resolve() // Make autosave callback.
        .then(()=>Promise.all(this._saveCallbacks.map((cb)=>cb(this.editor)))) // When the autosave callback is finished, always clear `this._savePromise`, no matter if it was successful or not.
        .finally(()=>{
            this._savePromise = null;
        }) // If the save was successful, we have three scenarios:
        //
        // 1. If a save was requested when an autosave callback was already processed, we need to immediately call
        // another autosave callback. In this case, `this._savePromise` will not be resolved until the next callback is done.
        // 2. Otherwise, if changes happened to the model, make a delayed autosave callback (like the change just happened).
        // 3. If no changes happened to the model, return to the `synchronized` state.
        .then(()=>{
            if (this._makeImmediateSave) {
                this._makeImmediateSave = false;
                // Start another autosave callback. Return a promise that will be resolved after the new autosave callback.
                // This way promises returned by `_save()` will not be resolved until all changes are saved.
                //
                // If `save()` was called when another (most often automatic) autosave callback was already processed,
                // the promise returned by `save()` call will be resolved only after new changes have been saved.
                //
                // Note that it would not work correctly if `this._savePromise` is not cleared.
                return this._save();
            } else {
                if (this.editor.model.document.version > this._lastDocumentVersion) {
                    this.state = 'waiting';
                    this._debouncedSave();
                } else {
                    this.state = 'synchronized';
                    this._pendingActions.remove(this._action);
                    this._action = null;
                }
            }
        }) // In case of an error, retry the autosave callback after a delay (and also throw the original error).
        .catch((err)=>{
            // Change state to `error` so that listeners handling autosave error can be called.
            this.state = 'error';
            // Then, immediately change to the `saving` state as described above.
            // Being in the `saving` state ensures that the autosave callback won't be delayed further by the `change:data` listener.
            this.state = 'saving';
            this._debouncedSave();
            throw err;
        });
        return this._savePromise;
    }
    /**
	 * Creates a pending action if it is not set already.
	 */ _setPendingAction() {
        const t = this.editor.t;
        if (!this._action) {
            this._action = this._pendingActions.add(t('Saving changes'));
        }
    }
    /**
	 * Saves callbacks.
	 */ get _saveCallbacks() {
        const saveCallbacks = [];
        if (this.adapter && this.adapter.save) {
            saveCallbacks.push(this.adapter.save);
        }
        if (this._config.save) {
            saveCallbacks.push(this._config.save);
        }
        return saveCallbacks;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-basic-styles/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "AttributeCommand": (()=>AttributeCommand),
    "Bold": (()=>Bold),
    "BoldEditing": (()=>BoldEditing),
    "BoldUI": (()=>BoldUI),
    "Code": (()=>Code),
    "CodeEditing": (()=>CodeEditing),
    "CodeUI": (()=>CodeUI),
    "Italic": (()=>Italic),
    "ItalicEditing": (()=>ItalicEditing),
    "ItalicUI": (()=>ItalicUI),
    "Strikethrough": (()=>Strikethrough),
    "StrikethroughEditing": (()=>StrikethroughEditing),
    "StrikethroughUI": (()=>StrikethroughUI),
    "Subscript": (()=>Subscript),
    "SubscriptEditing": (()=>SubscriptEditing),
    "SubscriptUI": (()=>SubscriptUI),
    "Superscript": (()=>Superscript),
    "SuperscriptEditing": (()=>SuperscriptEditing),
    "SuperscriptUI": (()=>SuperscriptUI),
    "Underline": (()=>Underline),
    "UnderlineEditing": (()=>UnderlineEditing),
    "UnderlineUI": (()=>UnderlineUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-typing/dist/index.js [app-client] (ecmascript)");
;
;
;
/**
 * An extension of the base {@link module:core/command~Command} class, which provides utilities for a command
 * that toggles a single attribute on a text or an element.
 *
 * `AttributeCommand` uses {@link module:engine/model/document~Document#selection}
 * to decide which nodes (if any) should be changed, and applies or removes the attribute from them.
 *
 * The command checks the {@link module:engine/model/model~Model#schema} to decide if it can be enabled
 * for the current selection and to which nodes the attribute can be applied.
 */ class AttributeCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * The attribute that will be set by the command.
	 */ attributeKey;
    /**
	 * @param attributeKey Attribute that will be set by the command.
	 */ constructor(editor, attributeKey){
        super(editor);
        this.attributeKey = attributeKey;
    }
    /**
	 * Updates the command's {@link #value} and {@link #isEnabled} based on the current selection.
	 */ refresh() {
        const model = this.editor.model;
        const doc = model.document;
        this.value = this._getValueFromFirstAllowedNode();
        this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, this.attributeKey);
    }
    /**
	 * Executes the command &ndash; applies the attribute to the selection or removes it from the selection.
	 *
	 * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.
	 *
	 * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:
	 *
	 * * If the selection is on a range, the command applies the attribute to all nodes in that range
	 * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).
	 * * If the selection is collapsed in a non-empty node, the command applies the attribute to the
	 * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).
	 * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note
	 * that the selection inherits all attributes from a node if it is in an empty node).
	 *
	 * @fires execute
	 * @param options Command options.
	 * @param options.forceValue If set, it will force the command behavior. If `true`,
	 * the command will apply the attribute, otherwise the command will remove the attribute.
	 * If not set, the command will look for its current value to decide what it should do.
	 */ execute(options = {}) {
        const model = this.editor.model;
        const doc = model.document;
        const selection = doc.selection;
        const value = options.forceValue === undefined ? !this.value : options.forceValue;
        model.change((writer)=>{
            if (selection.isCollapsed) {
                if (value) {
                    writer.setSelectionAttribute(this.attributeKey, true);
                } else {
                    writer.removeSelectionAttribute(this.attributeKey);
                }
            } else {
                const ranges = model.schema.getValidRanges(selection.getRanges(), this.attributeKey);
                for (const range of ranges){
                    if (value) {
                        writer.setAttribute(this.attributeKey, value, range);
                    } else {
                        writer.removeAttribute(this.attributeKey, range);
                    }
                }
            }
        });
    }
    /**
	 * Checks the attribute value of the first node in the selection that allows the attribute.
	 * For the collapsed selection returns the selection attribute.
	 *
	 * @returns The attribute value.
	 */ _getValueFromFirstAllowedNode() {
        const model = this.editor.model;
        const schema = model.schema;
        const selection = model.document.selection;
        if (selection.isCollapsed) {
            return selection.hasAttribute(this.attributeKey);
        }
        for (const range of selection.getRanges()){
            for (const item of range.getItems()){
                if (schema.checkAttribute(item, this.attributeKey)) {
                    return item.hasAttribute(this.attributeKey);
                }
            }
        }
        return false;
    }
}
const BOLD$1 = 'bold';
/**
 * The bold editing feature.
 *
 * It registers the `'bold'` command and introduces the `bold` attribute in the model which renders to the view
 * as a `<strong>` element.
 */ class BoldEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'BoldEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = this.editor.t;
        // Allow bold attribute on text nodes.
        editor.model.schema.extend('$text', {
            allowAttributes: BOLD$1
        });
        editor.model.schema.setAttributeProperties(BOLD$1, {
            isFormatting: true,
            copyOnEnter: true
        });
        // Build converter from model to view for data and editing pipelines.
        editor.conversion.attributeToElement({
            model: BOLD$1,
            view: 'strong',
            upcastAlso: [
                'b',
                (viewElement)=>{
                    const fontWeight = viewElement.getStyle('font-weight');
                    if (!fontWeight) {
                        return null;
                    }
                    // Value of the `font-weight` attribute can be defined as a string or a number.
                    if (fontWeight == 'bold' || Number(fontWeight) >= 600) {
                        return {
                            name: true,
                            styles: [
                                'font-weight'
                            ]
                        };
                    }
                    return null;
                }
            ]
        });
        // Create bold command.
        editor.commands.add(BOLD$1, new AttributeCommand(editor, BOLD$1));
        // Set the Ctrl+B keystroke.
        editor.keystrokes.set('CTRL+B', BOLD$1);
        // Add the information about the keystroke to the accessibility database.
        editor.accessibility.addKeystrokeInfos({
            keystrokes: [
                {
                    label: t('Bold text'),
                    keystroke: 'CTRL+B'
                }
            ]
        });
    }
}
/**
 * Returns a function that creates a (toolbar or menu bar) button for a basic style feature.
 */ function getButtonCreator({ editor, commandName, plugin, icon, label, keystroke }) {
    return (ButtonClass)=>{
        const command = editor.commands.get(commandName);
        const view = new ButtonClass(editor.locale);
        view.set({
            label,
            icon,
            keystroke,
            isToggleable: true
        });
        view.bind('isEnabled').to(command, 'isEnabled');
        view.bind('isOn').to(command, 'value');
        if (view instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]) {
            view.set({
                role: 'menuitemcheckbox'
            });
        } else {
            view.set({
                tooltip: true
            });
        }
        // Execute the command.
        plugin.listenTo(view, 'execute', ()=>{
            editor.execute(commandName);
            editor.editing.view.focus();
        });
        return view;
    };
}
const BOLD = 'bold';
/**
 * The bold UI feature. It introduces the Bold button.
 */ class BoldUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'BoldUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.locale.t;
        const createButton = getButtonCreator({
            editor,
            commandName: BOLD,
            plugin: this,
            icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].bold,
            label: t('Bold'),
            keystroke: 'CTRL+B'
        });
        // Add bold button to feature components.
        editor.ui.componentFactory.add(BOLD, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]));
        editor.ui.componentFactory.add('menuBar:' + BOLD, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]));
    }
}
/**
 * The bold feature.
 *
 * For a detailed overview check the {@glink features/basic-styles Basic styles feature} guide
 * and the {@glink api/basic-styles package page}.
 *
 * This is a "glue" plugin which loads the {@link module:basic-styles/bold/boldediting~BoldEditing bold editing feature}
 * and {@link module:basic-styles/bold/boldui~BoldUI bold UI feature}.
 */ class Bold extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            BoldEditing,
            BoldUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Bold';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
const CODE$1 = 'code';
const HIGHLIGHT_CLASS = 'ck-code_selected';
/**
 * The code editing feature.
 *
 * It registers the `'code'` command and introduces the `code` attribute in the model which renders to the view
 * as a `<code>` element.
 */ class CodeEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CodeEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TwoStepCaretMovement"]
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = this.editor.t;
        // Allow code attribute on text nodes.
        editor.model.schema.extend('$text', {
            allowAttributes: CODE$1
        });
        editor.model.schema.setAttributeProperties(CODE$1, {
            isFormatting: true,
            copyOnEnter: false
        });
        editor.conversion.attributeToElement({
            model: CODE$1,
            view: 'code'
        });
        // Create code command.
        editor.commands.add(CODE$1, new AttributeCommand(editor, CODE$1));
        // Enable two-step caret movement for `code` attribute.
        editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TwoStepCaretMovement"]).registerAttribute(CODE$1);
        // Setup highlight over selected element.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inlineHighlight"])(editor, CODE$1, 'code', HIGHLIGHT_CLASS);
        // Add the information about the keystroke to the accessibility database.
        editor.accessibility.addKeystrokeInfos({
            keystrokes: [
                {
                    label: t('Move out of an inline code style'),
                    keystroke: [
                        [
                            'arrowleft',
                            'arrowleft'
                        ],
                        [
                            'arrowright',
                            'arrowright'
                        ]
                    ]
                }
            ]
        });
    }
}
var codeIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m12.5 5.7 5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1zm-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1z\"/></svg>";
const CODE = 'code';
/**
 * The code UI feature. It introduces the Code button.
 */ class CodeUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CodeUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.locale.t;
        const createButton = getButtonCreator({
            editor,
            commandName: CODE,
            plugin: this,
            icon: codeIcon,
            label: t('Code')
        });
        // Add code button to feature components.
        editor.ui.componentFactory.add(CODE, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]));
        editor.ui.componentFactory.add('menuBar:' + CODE, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]));
    }
}
/**
 * The code feature.
 *
 * For a detailed overview check the {@glink features/basic-styles Basic styles feature} guide
 * and the {@glink api/basic-styles package page}.
 *
 * This is a "glue" plugin which loads the {@link module:basic-styles/code/codeediting~CodeEditing code editing feature}
 * and {@link module:basic-styles/code/codeui~CodeUI code UI feature}.
 */ class Code extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            CodeEditing,
            CodeUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Code';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
const ITALIC$1 = 'italic';
/**
 * The italic editing feature.
 *
 * It registers the `'italic'` command, the <kbd>Ctrl+I</kbd> keystroke and introduces the `italic` attribute in the model
 * which renders to the view as an `<i>` element.
 */ class ItalicEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ItalicEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = this.editor.t;
        // Allow italic attribute on text nodes.
        editor.model.schema.extend('$text', {
            allowAttributes: ITALIC$1
        });
        editor.model.schema.setAttributeProperties(ITALIC$1, {
            isFormatting: true,
            copyOnEnter: true
        });
        editor.conversion.attributeToElement({
            model: ITALIC$1,
            view: 'i',
            upcastAlso: [
                'em',
                {
                    styles: {
                        'font-style': 'italic'
                    }
                }
            ]
        });
        // Create italic command.
        editor.commands.add(ITALIC$1, new AttributeCommand(editor, ITALIC$1));
        // Set the Ctrl+I keystroke.
        editor.keystrokes.set('CTRL+I', ITALIC$1);
        // Add the information about the keystroke to the accessibility database.
        editor.accessibility.addKeystrokeInfos({
            keystrokes: [
                {
                    label: t('Italic text'),
                    keystroke: 'CTRL+I'
                }
            ]
        });
    }
}
var italicIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z\"/></svg>";
const ITALIC = 'italic';
/**
 * The italic UI feature. It introduces the Italic button.
 */ class ItalicUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ItalicUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.locale.t;
        const createButton = getButtonCreator({
            editor,
            commandName: ITALIC,
            plugin: this,
            icon: italicIcon,
            keystroke: 'CTRL+I',
            label: t('Italic')
        });
        // Add bold button to feature components.
        editor.ui.componentFactory.add(ITALIC, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]));
        editor.ui.componentFactory.add('menuBar:' + ITALIC, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]));
    }
}
/**
 * The italic feature.
 *
 * For a detailed overview check the {@glink features/basic-styles Basic styles feature} guide
 * and the {@glink api/basic-styles package page}.
 *
 * This is a "glue" plugin which loads the {@link module:basic-styles/italic/italicediting~ItalicEditing} and
 * {@link module:basic-styles/italic/italicui~ItalicUI} plugins.
 */ class Italic extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            ItalicEditing,
            ItalicUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Italic';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
const STRIKETHROUGH$1 = 'strikethrough';
/**
 * The strikethrough editing feature.
 *
 * It registers the `'strikethrough'` command, the <kbd>Ctrl+Shift+X</kbd> keystroke and introduces the
 * `strikethroughsthrough` attribute in the model which renders to the view
 * as a `<s>` element.
 */ class StrikethroughEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'StrikethroughEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = this.editor.t;
        // Allow strikethrough attribute on text nodes.
        editor.model.schema.extend('$text', {
            allowAttributes: STRIKETHROUGH$1
        });
        editor.model.schema.setAttributeProperties(STRIKETHROUGH$1, {
            isFormatting: true,
            copyOnEnter: true
        });
        editor.conversion.attributeToElement({
            model: STRIKETHROUGH$1,
            view: 's',
            upcastAlso: [
                'del',
                'strike',
                {
                    styles: {
                        'text-decoration': 'line-through'
                    }
                }
            ]
        });
        // Create strikethrough command.
        editor.commands.add(STRIKETHROUGH$1, new AttributeCommand(editor, STRIKETHROUGH$1));
        // Set the Ctrl+Shift+X keystroke.
        editor.keystrokes.set('CTRL+SHIFT+X', 'strikethrough');
        // Add the information about the keystroke to the accessibility database.
        editor.accessibility.addKeystrokeInfos({
            keystrokes: [
                {
                    label: t('Strikethrough text'),
                    keystroke: 'CTRL+SHIFT+X'
                }
            ]
        });
    }
}
var strikethroughIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z\"/><path d=\"M3 10.5V9h14v1.5z\"/></svg>";
const STRIKETHROUGH = 'strikethrough';
/**
 * The strikethrough UI feature. It introduces the Strikethrough button.
 */ class StrikethroughUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'StrikethroughUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.locale.t;
        const createButton = getButtonCreator({
            editor,
            commandName: STRIKETHROUGH,
            plugin: this,
            icon: strikethroughIcon,
            keystroke: 'CTRL+SHIFT+X',
            label: t('Strikethrough')
        });
        // Add strikethrough button to feature components.
        editor.ui.componentFactory.add(STRIKETHROUGH, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]));
        editor.ui.componentFactory.add('menuBar:' + STRIKETHROUGH, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]));
    }
}
/**
 * The strikethrough feature.
 *
 * For a detailed overview check the {@glink features/basic-styles Basic styles feature} guide
 * and the {@glink api/basic-styles package page}.
 *
 * This is a "glue" plugin which loads the {@link module:basic-styles/strikethrough/strikethroughediting~StrikethroughEditing} and
 * {@link module:basic-styles/strikethrough/strikethroughui~StrikethroughUI} plugins.
 */ class Strikethrough extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            StrikethroughEditing,
            StrikethroughUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Strikethrough';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
const SUBSCRIPT$1 = 'subscript';
/**
 * The subscript editing feature.
 *
 * It registers the `sub` command and introduces the `sub` attribute in the model which renders to the view
 * as a `<sub>` element.
 */ class SubscriptEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SubscriptEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        // Allow sub attribute on text nodes.
        editor.model.schema.extend('$text', {
            allowAttributes: SUBSCRIPT$1
        });
        editor.model.schema.setAttributeProperties(SUBSCRIPT$1, {
            isFormatting: true,
            copyOnEnter: true
        });
        // Build converter from model to view for data and editing pipelines.
        editor.conversion.attributeToElement({
            model: SUBSCRIPT$1,
            view: 'sub',
            upcastAlso: [
                {
                    styles: {
                        'vertical-align': 'sub'
                    }
                }
            ]
        });
        // Create sub command.
        editor.commands.add(SUBSCRIPT$1, new AttributeCommand(editor, SUBSCRIPT$1));
    }
}
var subscriptIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z\"/></svg>";
const SUBSCRIPT = 'subscript';
/**
 * The subscript UI feature. It introduces the Subscript button.
 */ class SubscriptUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SubscriptUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.locale.t;
        const createButton = getButtonCreator({
            editor,
            commandName: SUBSCRIPT,
            plugin: this,
            icon: subscriptIcon,
            label: t('Subscript')
        });
        // Add subscript button to feature components.
        editor.ui.componentFactory.add(SUBSCRIPT, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]));
        editor.ui.componentFactory.add('menuBar:' + SUBSCRIPT, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]));
    }
}
/**
 * The subscript feature.
 *
 * It loads the {@link module:basic-styles/subscript/subscriptediting~SubscriptEditing} and
 * {@link module:basic-styles/subscript/subscriptui~SubscriptUI} plugins.
 */ class Subscript extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            SubscriptEditing,
            SubscriptUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Subscript';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
const SUPERSCRIPT$1 = 'superscript';
/**
 * The superscript editing feature.
 *
 * It registers the `super` command and introduces the `super` attribute in the model which renders to the view
 * as a `<super>` element.
 */ class SuperscriptEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SuperscriptEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        // Allow super attribute on text nodes.
        editor.model.schema.extend('$text', {
            allowAttributes: SUPERSCRIPT$1
        });
        editor.model.schema.setAttributeProperties(SUPERSCRIPT$1, {
            isFormatting: true,
            copyOnEnter: true
        });
        // Build converter from model to view for data and editing pipelines.
        editor.conversion.attributeToElement({
            model: SUPERSCRIPT$1,
            view: 'sup',
            upcastAlso: [
                {
                    styles: {
                        'vertical-align': 'super'
                    }
                }
            ]
        });
        // Create super command.
        editor.commands.add(SUPERSCRIPT$1, new AttributeCommand(editor, SUPERSCRIPT$1));
    }
}
var superscriptIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z\"/></svg>";
const SUPERSCRIPT = 'superscript';
/**
 * The superscript UI feature. It introduces the Superscript button.
 */ class SuperscriptUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SuperscriptUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.locale.t;
        const createButton = getButtonCreator({
            editor,
            commandName: SUPERSCRIPT,
            plugin: this,
            icon: superscriptIcon,
            label: t('Superscript')
        });
        // Add superscript button to feature components.
        editor.ui.componentFactory.add(SUPERSCRIPT, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]));
        editor.ui.componentFactory.add('menuBar:' + SUPERSCRIPT, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]));
    }
}
/**
 * The superscript feature.
 *
 * It loads the {@link module:basic-styles/superscript/superscriptediting~SuperscriptEditing} and
 * {@link module:basic-styles/superscript/superscriptui~SuperscriptUI} plugins.
 */ class Superscript extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            SuperscriptEditing,
            SuperscriptUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Superscript';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
const UNDERLINE$1 = 'underline';
/**
 * The underline editing feature.
 *
 * It registers the `'underline'` command, the <kbd>Ctrl+U</kbd> keystroke
 * and introduces the `underline` attribute in the model which renders to the view as an `<u>` element.
 */ class UnderlineEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'UnderlineEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = this.editor.t;
        // Allow strikethrough attribute on text nodes.
        editor.model.schema.extend('$text', {
            allowAttributes: UNDERLINE$1
        });
        editor.model.schema.setAttributeProperties(UNDERLINE$1, {
            isFormatting: true,
            copyOnEnter: true
        });
        editor.conversion.attributeToElement({
            model: UNDERLINE$1,
            view: 'u',
            upcastAlso: {
                styles: {
                    'text-decoration': 'underline'
                }
            }
        });
        // Create underline command.
        editor.commands.add(UNDERLINE$1, new AttributeCommand(editor, UNDERLINE$1));
        // Set the Ctrl+U keystroke.
        editor.keystrokes.set('CTRL+U', 'underline');
        // Add the information about the keystroke to the accessibility database.
        editor.accessibility.addKeystrokeInfos({
            keystrokes: [
                {
                    label: t('Underline text'),
                    keystroke: 'CTRL+U'
                }
            ]
        });
    }
}
var underlineIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z\"/></svg>";
const UNDERLINE = 'underline';
/**
 * The underline UI feature. It introduces the Underline button.
 */ class UnderlineUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'UnderlineUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.locale.t;
        const createButton = getButtonCreator({
            editor,
            commandName: UNDERLINE,
            plugin: this,
            icon: underlineIcon,
            label: t('Underline'),
            keystroke: 'CTRL+U'
        });
        // Add bold button to feature components.
        editor.ui.componentFactory.add(UNDERLINE, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]));
        editor.ui.componentFactory.add('menuBar:' + UNDERLINE, ()=>createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]));
    }
}
/**
 * The underline feature.
 *
 * For a detailed overview check the {@glink features/basic-styles Basic styles feature} guide
 * and the {@glink api/basic-styles package page}.
 *
 * This is a "glue" plugin which loads the {@link module:basic-styles/underline/underlineediting~UnderlineEditing} and
 * {@link module:basic-styles/underline/underlineui~UnderlineUI} plugins.
 */ class Underline extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            UnderlineEditing,
            UnderlineUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Underline';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-enter/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Enter": (()=>Enter),
    "ShiftEnter": (()=>ShiftEnter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
;
;
;
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module enter/utils
 */ /**
 * Returns attributes that should be preserved on the enter keystroke.
 *
 * Filtering is realized based on `copyOnEnter` attribute property. Read more about attribute properties
 * {@link module:engine/model/schema~Schema#setAttributeProperties here}.
 *
 * @param schema Model's schema.
 * @param allAttributes Attributes to filter.
 */ function* getCopyOnEnterAttributes(schema, allAttributes) {
    for (const attribute of allAttributes){
        if (attribute && schema.getAttributeProperties(attribute[0]).copyOnEnter) {
            yield attribute;
        }
    }
}
/**
 * Enter command used by the {@link module:enter/enter~Enter Enter feature} to handle the <kbd>Enter</kbd> keystroke.
 */ class EnterCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ execute() {
        this.editor.model.change((writer)=>{
            this.enterBlock(writer);
            this.fire('afterExecute', {
                writer
            });
        });
    }
    /**
	 * Splits a block where the document selection is placed, in the way how the <kbd>Enter</kbd> key is expected to work:
	 *
	 * ```
	 * <p>Foo[]bar</p>   ->   <p>Foo</p><p>[]bar</p>
	 * <p>Foobar[]</p>   ->   <p>Foobar</p><p>[]</p>
	 * <p>Fo[ob]ar</p>   ->   <p>Fo</p><p>[]ar</p>
	 * ```
	 *
	 * In some cases, the split will not happen:
	 *
	 * ```
	 * // The selection parent is a limit element:
	 * <figcaption>A[bc]d</figcaption>   ->   <figcaption>A[]d</figcaption>
	 *
	 * // The selection spans over multiple elements:
	 * <h>x[x</h><p>y]y<p>   ->   <h>x</h><p>[]y</p>
	 * ```
	 *
	 * @param writer Writer to use when performing the enter action.
	 * @returns Boolean indicating if the block was split.
	 */ enterBlock(writer) {
        const model = this.editor.model;
        const selection = model.document.selection;
        const schema = model.schema;
        const isSelectionEmpty = selection.isCollapsed;
        const range = selection.getFirstRange();
        const startElement = range.start.parent;
        const endElement = range.end.parent;
        // Don't touch the roots and other limit elements.
        if (schema.isLimit(startElement) || schema.isLimit(endElement)) {
            // Delete the selected content but only if inside a single limit element.
            // Abort, when crossing limit elements boundary (e.g. <limit1>x[x</limit1>donttouchme<limit2>y]y</limit2>).
            // This is an edge case and it's hard to tell what should actually happen because such a selection
            // is not entirely valid.
            if (!isSelectionEmpty && startElement == endElement) {
                model.deleteContent(selection);
            }
            return false;
        }
        if (isSelectionEmpty) {
            const attributesToCopy = getCopyOnEnterAttributes(writer.model.schema, selection.getAttributes());
            splitBlock(writer, range.start);
            writer.setSelectionAttribute(attributesToCopy);
            return true;
        } else {
            const leaveUnmerged = !(range.start.isAtStart && range.end.isAtEnd);
            const isContainedWithinOneElement = startElement == endElement;
            model.deleteContent(selection, {
                leaveUnmerged
            });
            if (leaveUnmerged) {
                // Partially selected elements.
                //
                // <h>x[xx]x</h>		-> <h>x^x</h>			-> <h>x</h><h>^x</h>
                if (isContainedWithinOneElement) {
                    splitBlock(writer, selection.focus);
                    return true;
                } else {
                    writer.setSelection(endElement, 0);
                }
            }
        }
        return false;
    }
}
function splitBlock(writer, splitPos) {
    writer.split(splitPos);
    writer.setSelection(splitPos.parent.nextSibling, 0);
}
const ENTER_EVENT_TYPES = {
    insertParagraph: {
        isSoft: false
    },
    insertLineBreak: {
        isSoft: true
    }
};
/**
 * Enter observer introduces the {@link module:engine/view/document~Document#event:enter `Document#enter`} event.
 */ class EnterObserver extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observer"] {
    /**
	 * @inheritDoc
	 */ constructor(view){
        super(view);
        const doc = this.document;
        let shiftPressed = false;
        doc.on('keydown', (evt, data)=>{
            shiftPressed = data.shiftKey;
        });
        doc.on('beforeinput', (evt, data)=>{
            if (!this.isEnabled) {
                return;
            }
            let inputType = data.inputType;
            // See https://github.com/ckeditor/ckeditor5/issues/13321.
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isSafari && shiftPressed && inputType == 'insertParagraph') {
                inputType = 'insertLineBreak';
            }
            const domEvent = data.domEvent;
            const enterEventSpec = ENTER_EVENT_TYPES[inputType];
            if (!enterEventSpec) {
                return;
            }
            const event = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BubblingEventInfo"](doc, 'enter', data.targetRanges[0]);
            doc.fire(event, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DomEventData"](view, domEvent, {
                isSoft: enterEventSpec.isSoft
            }));
            // Stop `beforeinput` event if `enter` event was stopped.
            // https://github.com/ckeditor/ckeditor5/issues/753
            if (event.stop.called) {
                evt.stop();
            }
        });
    }
    /**
	 * @inheritDoc
	 */ observe() {}
    /**
	 * @inheritDoc
	 */ stopObserving() {}
}
/**
 * This plugin handles the <kbd>Enter</kbd> keystroke (hard line break) in the editor.
 *
 * See also the {@link module:enter/shiftenter~ShiftEnter} plugin.
 *
 * For more information about this feature see the {@glink api/enter package page}.
 */ class Enter extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Enter';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    init() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const t = this.editor.t;
        view.addObserver(EnterObserver);
        editor.commands.add('enter', new EnterCommand(editor));
        this.listenTo(viewDocument, 'enter', (evt, data)=>{
            // When not in composition, we handle the action, so prevent the default one.
            // When in composition, it's the browser who modify the DOM (renderer is disabled).
            if (!viewDocument.isComposing) {
                data.preventDefault();
            }
            // The soft enter key is handled by the ShiftEnter plugin.
            if (data.isSoft) {
                return;
            }
            editor.execute('enter');
            view.scrollToTheSelection();
        }, {
            priority: 'low'
        });
        // Add the information about the keystroke to the accessibility database.
        editor.accessibility.addKeystrokeInfos({
            keystrokes: [
                {
                    label: t('Insert a hard break (a new paragraph)'),
                    keystroke: 'Enter'
                }
            ]
        });
    }
}
/**
 * ShiftEnter command. It is used by the {@link module:enter/shiftenter~ShiftEnter ShiftEnter feature} to handle
 * the <kbd>Shift</kbd>+<kbd>Enter</kbd> keystroke.
 */ class ShiftEnterCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ execute() {
        const model = this.editor.model;
        const doc = model.document;
        model.change((writer)=>{
            softBreakAction(model, writer, doc.selection);
            this.fire('afterExecute', {
                writer
            });
        });
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const doc = model.document;
        this.isEnabled = isEnabled(model.schema, doc.selection);
    }
}
/**
 * Checks whether the ShiftEnter command should be enabled in the specified selection.
 */ function isEnabled(schema, selection) {
    // At this moment it is okay to support single range selections only.
    // But in the future we may need to change that.
    if (selection.rangeCount > 1) {
        return false;
    }
    const anchorPos = selection.anchor;
    // Check whether the break element can be inserted in the current selection anchor.
    if (!anchorPos || !schema.checkChild(anchorPos, 'softBreak')) {
        return false;
    }
    const range = selection.getFirstRange();
    const startElement = range.start.parent;
    const endElement = range.end.parent;
    // Do not modify the content if selection is cross-limit elements.
    if ((isInsideLimitElement(startElement, schema) || isInsideLimitElement(endElement, schema)) && startElement !== endElement) {
        return false;
    }
    return true;
}
/**
 * Creates a break in the way that the <kbd>Shift</kbd>+<kbd>Enter</kbd> keystroke is expected to work.
 */ function softBreakAction(model, writer, selection) {
    const isSelectionEmpty = selection.isCollapsed;
    const range = selection.getFirstRange();
    const startElement = range.start.parent;
    const endElement = range.end.parent;
    const isContainedWithinOneElement = startElement == endElement;
    if (isSelectionEmpty) {
        const attributesToCopy = getCopyOnEnterAttributes(model.schema, selection.getAttributes());
        insertBreak(model, writer, range.end);
        writer.removeSelectionAttribute(selection.getAttributeKeys());
        writer.setSelectionAttribute(attributesToCopy);
    } else {
        const leaveUnmerged = !(range.start.isAtStart && range.end.isAtEnd);
        model.deleteContent(selection, {
            leaveUnmerged
        });
        // Selection within one element:
        //
        // <h>x[xx]x</h>		-> <h>x^x</h>			-> <h>x<br>^x</h>
        if (isContainedWithinOneElement) {
            insertBreak(model, writer, selection.focus);
        } else {
            // Move the selection to the 2nd element (last step of the example above).
            if (leaveUnmerged) {
                writer.setSelection(endElement, 0);
            }
        }
    }
}
function insertBreak(model, writer, position) {
    const breakLineElement = writer.createElement('softBreak');
    model.insertContent(breakLineElement, position);
    writer.setSelection(breakLineElement, 'after');
}
/**
 * Checks whether the specified `element` is a child of the limit element.
 *
 * Checking whether the `<p>` element is inside a limit element:
 *   - `<$root><p>Text.</p></$root> => false`
 *   - `<$root><limitElement><p>Text</p></limitElement></$root> => true`
 */ function isInsideLimitElement(element, schema) {
    // `$root` is a limit element but in this case is an invalid element.
    if (element.is('rootElement')) {
        return false;
    }
    return schema.isLimit(element) || isInsideLimitElement(element.parent, schema);
}
/**
 * This plugin handles the <kbd>Shift</kbd>+<kbd>Enter</kbd> keystroke (soft line break) in the editor.
 *
 * See also the {@link module:enter/enter~Enter} plugin.
 *
 * For more information about this feature see the {@glink api/enter package page}.
 */ class ShiftEnter extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ShiftEnter';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        const conversion = editor.conversion;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const t = this.editor.t;
        // Configure the schema.
        schema.register('softBreak', {
            allowWhere: '$text',
            isInline: true
        });
        // Configure converters.
        conversion.for('upcast').elementToElement({
            model: 'softBreak',
            view: 'br'
        });
        conversion.for('downcast').elementToElement({
            model: 'softBreak',
            view: (modelElement, { writer })=>writer.createEmptyElement('br')
        });
        view.addObserver(EnterObserver);
        editor.commands.add('shiftEnter', new ShiftEnterCommand(editor));
        this.listenTo(viewDocument, 'enter', (evt, data)=>{
            // When not in composition, we handle the action, so prevent the default one.
            // When in composition, it's the browser who modify the DOM (renderer is disabled).
            if (!viewDocument.isComposing) {
                data.preventDefault();
            }
            // The hard enter key is handled by the Enter plugin.
            if (!data.isSoft) {
                return;
            }
            editor.execute('shiftEnter');
            view.scrollToTheSelection();
        }, {
            priority: 'low'
        });
        // Add the information about the keystroke to the accessibility database.
        editor.accessibility.addKeystrokeInfos({
            keystrokes: [
                {
                    label: t('Insert a soft break (a <code>&lt;br&gt;</code> element)'),
                    keystroke: 'Shift+Enter'
                }
            ]
        });
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-block-quote/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "BlockQuote": (()=>BlockQuote),
    "BlockQuoteEditing": (()=>BlockQuoteEditing),
    "BlockQuoteUI": (()=>BlockQuoteUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$enter$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-enter/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-typing/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * The block quote command plugin.
 *
 * @extends module:core/command~Command
 */ class BlockQuoteCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ refresh() {
        this.value = this._getValue();
        this.isEnabled = this._checkEnabled();
    }
    /**
	 * Executes the command. When the command {@link #value is on}, all top-most block quotes within
	 * the selection will be removed. If it is off, all selected blocks will be wrapped with
	 * a block quote.
	 *
	 * @fires execute
	 * @param options Command options.
	 * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply a block quote,
	 * otherwise the command will remove the block quote. If not set, the command will act basing on its current value.
	 */ execute(options = {}) {
        const model = this.editor.model;
        const schema = model.schema;
        const selection = model.document.selection;
        const blocks = Array.from(selection.getSelectedBlocks());
        const value = options.forceValue === undefined ? !this.value : options.forceValue;
        model.change((writer)=>{
            if (!value) {
                this._removeQuote(writer, blocks.filter(findQuote));
            } else {
                const blocksToQuote = blocks.filter((block)=>{
                    // Already quoted blocks needs to be considered while quoting too
                    // in order to reuse their <bQ> elements.
                    return findQuote(block) || checkCanBeQuoted(schema, block);
                });
                this._applyQuote(writer, blocksToQuote);
            }
        });
    }
    /**
	 * Checks the command's {@link #value}.
	 */ _getValue() {
        const selection = this.editor.model.document.selection;
        const firstBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(selection.getSelectedBlocks());
        // In the current implementation, the block quote must be an immediate parent of a block element.
        return !!(firstBlock && findQuote(firstBlock));
    }
    /**
	 * Checks whether the command can be enabled in the current context.
	 *
	 * @returns Whether the command should be enabled.
	 */ _checkEnabled() {
        if (this.value) {
            return true;
        }
        const selection = this.editor.model.document.selection;
        const schema = this.editor.model.schema;
        const firstBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(selection.getSelectedBlocks());
        if (!firstBlock) {
            return false;
        }
        return checkCanBeQuoted(schema, firstBlock);
    }
    /**
	 * Removes the quote from given blocks.
	 *
	 * If blocks which are supposed to be "unquoted" are in the middle of a quote,
	 * start it or end it, then the quote will be split (if needed) and the blocks
	 * will be moved out of it, so other quoted blocks remained quoted.
	 */ _removeQuote(writer, blocks) {
        // Unquote all groups of block. Iterate in the reverse order to not break following ranges.
        getRangesOfBlockGroups(writer, blocks).reverse().forEach((groupRange)=>{
            if (groupRange.start.isAtStart && groupRange.end.isAtEnd) {
                writer.unwrap(groupRange.start.parent);
                return;
            }
            // The group of blocks are at the beginning of an <bQ> so let's move them left (out of the <bQ>).
            if (groupRange.start.isAtStart) {
                const positionBefore = writer.createPositionBefore(groupRange.start.parent);
                writer.move(groupRange, positionBefore);
                return;
            }
            // The blocks are in the middle of an <bQ> so we need to split the <bQ> after the last block
            // so we move the items there.
            if (!groupRange.end.isAtEnd) {
                writer.split(groupRange.end);
            }
            // Now we are sure that groupRange.end.isAtEnd is true, so let's move the blocks right.
            const positionAfter = writer.createPositionAfter(groupRange.end.parent);
            writer.move(groupRange, positionAfter);
        });
    }
    /**
	 * Applies the quote to given blocks.
	 */ _applyQuote(writer, blocks) {
        const quotesToMerge = [];
        // Quote all groups of block. Iterate in the reverse order to not break following ranges.
        getRangesOfBlockGroups(writer, blocks).reverse().forEach((groupRange)=>{
            let quote = findQuote(groupRange.start);
            if (!quote) {
                quote = writer.createElement('blockQuote');
                writer.wrap(groupRange, quote);
            }
            quotesToMerge.push(quote);
        });
        // Merge subsequent <bQ> elements. Reverse the order again because this time we want to go through
        // the <bQ> elements in the source order (due to how merge works – it moves the right element's content
        // to the first element and removes the right one. Since we may need to merge a couple of subsequent `<bQ>` elements
        // we want to keep the reference to the first (furthest left) one.
        quotesToMerge.reverse().reduce((currentQuote, nextQuote)=>{
            if (currentQuote.nextSibling == nextQuote) {
                writer.merge(writer.createPositionAfter(currentQuote));
                return currentQuote;
            }
            return nextQuote;
        });
    }
}
function findQuote(elementOrPosition) {
    return elementOrPosition.parent.name == 'blockQuote' ? elementOrPosition.parent : null;
}
/**
 * Returns a minimal array of ranges containing groups of subsequent blocks.
 *
 * content:         abcdefgh
 * blocks:          [ a, b, d, f, g, h ]
 * output ranges:   [ab]c[d]e[fgh]
 */ function getRangesOfBlockGroups(writer, blocks) {
    let startPosition;
    let i = 0;
    const ranges = [];
    while(i < blocks.length){
        const block = blocks[i];
        const nextBlock = blocks[i + 1];
        if (!startPosition) {
            startPosition = writer.createPositionBefore(block);
        }
        if (!nextBlock || block.nextSibling != nextBlock) {
            ranges.push(writer.createRange(startPosition, writer.createPositionAfter(block)));
            startPosition = null;
        }
        i++;
    }
    return ranges;
}
/**
 * Checks whether <bQ> can wrap the block.
 */ function checkCanBeQuoted(schema, block) {
    // TMP will be replaced with schema.checkWrap().
    const isBQAllowed = schema.checkChild(block.parent, 'blockQuote');
    const isBlockAllowedInBQ = schema.checkChild([
        '$root',
        'blockQuote'
    ], block);
    return isBQAllowed && isBlockAllowedInBQ;
}
/**
 * The block quote editing.
 *
 * Introduces the `'blockQuote'` command and the `'blockQuote'` model element.
 *
 * @extends module:core/plugin~Plugin
 */ class BlockQuoteEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'BlockQuoteEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$enter$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Enter"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Delete"]
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        editor.commands.add('blockQuote', new BlockQuoteCommand(editor));
        schema.register('blockQuote', {
            inheritAllFrom: '$container'
        });
        editor.conversion.elementToElement({
            model: 'blockQuote',
            view: 'blockquote'
        });
        // Postfixer which cleans incorrect model states connected with block quotes.
        editor.model.document.registerPostFixer((writer)=>{
            const changes = editor.model.document.differ.getChanges();
            for (const entry of changes){
                if (entry.type == 'insert') {
                    const element = entry.position.nodeAfter;
                    if (!element) {
                        continue;
                    }
                    if (element.is('element', 'blockQuote') && element.isEmpty) {
                        // Added an empty blockQuote - remove it.
                        writer.remove(element);
                        return true;
                    } else if (element.is('element', 'blockQuote') && !schema.checkChild(entry.position, element)) {
                        // Added a blockQuote in incorrect place. Unwrap it so the content inside is not lost.
                        writer.unwrap(element);
                        return true;
                    } else if (element.is('element')) {
                        // Just added an element. Check that all children meet the scheme rules.
                        const range = writer.createRangeIn(element);
                        for (const child of range.getItems()){
                            if (child.is('element', 'blockQuote') && !schema.checkChild(writer.createPositionBefore(child), child)) {
                                writer.unwrap(child);
                                return true;
                            }
                        }
                    }
                } else if (entry.type == 'remove') {
                    const parent = entry.position.parent;
                    if (parent.is('element', 'blockQuote') && parent.isEmpty) {
                        // Something got removed and now blockQuote is empty. Remove the blockQuote as well.
                        writer.remove(parent);
                        return true;
                    }
                }
            }
            return false;
        });
        const viewDocument = this.editor.editing.view.document;
        const selection = editor.model.document.selection;
        const blockQuoteCommand = editor.commands.get('blockQuote');
        // Overwrite default Enter key behavior.
        // If Enter key is pressed with selection collapsed in empty block inside a quote, break the quote.
        this.listenTo(viewDocument, 'enter', (evt, data)=>{
            if (!selection.isCollapsed || !blockQuoteCommand.value) {
                return;
            }
            const positionParent = selection.getLastPosition().parent;
            if (positionParent.isEmpty) {
                editor.execute('blockQuote');
                editor.editing.view.scrollToTheSelection();
                data.preventDefault();
                evt.stop();
            }
        }, {
            context: 'blockquote'
        });
        // Overwrite default Backspace key behavior.
        // If Backspace key is pressed with selection collapsed in first empty block inside a quote, break the quote.
        this.listenTo(viewDocument, 'delete', (evt, data)=>{
            if (data.direction != 'backward' || !selection.isCollapsed || !blockQuoteCommand.value) {
                return;
            }
            const positionParent = selection.getLastPosition().parent;
            if (positionParent.isEmpty && !positionParent.previousSibling) {
                editor.execute('blockQuote');
                editor.editing.view.scrollToTheSelection();
                data.preventDefault();
                evt.stop();
            }
        }, {
            context: 'blockquote'
        });
    }
}
/**
 * The block quote UI plugin.
 *
 * It introduces the `'blockQuote'` button.
 *
 * @extends module:core/plugin~Plugin
 */ class BlockQuoteUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'BlockQuoteUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.ui.componentFactory.add('blockQuote', ()=>{
            const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
            buttonView.set({
                tooltip: true
            });
            return buttonView;
        });
        editor.ui.componentFactory.add('menuBar:blockQuote', ()=>{
            const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
            buttonView.set({
                role: 'menuitemcheckbox'
            });
            return buttonView;
        });
    }
    /**
	 * Creates a button for block quote command to use either in toolbar or in menu bar.
	 */ _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = editor.commands.get('blockQuote');
        const view = new ButtonClass(editor.locale);
        const t = locale.t;
        view.set({
            label: t('Block quote'),
            icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].quote,
            isToggleable: true
        });
        view.bind('isEnabled').to(command, 'isEnabled');
        view.bind('isOn').to(command, 'value');
        // Execute the command.
        this.listenTo(view, 'execute', ()=>{
            editor.execute('blockQuote');
            editor.editing.view.focus();
        });
        return view;
    }
}
/**
 * The block quote plugin.
 *
 * For more information about this feature check the {@glink api/block-quote package page}.
 *
 * This is a "glue" plugin which loads the {@link module:block-quote/blockquoteediting~BlockQuoteEditing block quote editing feature}
 * and {@link module:block-quote/blockquoteui~BlockQuoteUI block quote UI feature}.
 *
 * @extends module:core/plugin~Plugin
 */ class BlockQuote extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            BlockQuoteEditing,
            BlockQuoteUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'BlockQuote';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-bookmark/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Bookmark": (()=>Bookmark),
    "BookmarkEditing": (()=>BookmarkEditing),
    "BookmarkUI": (()=>BookmarkUI),
    "InsertBookmarkCommand": (()=>InsertBookmarkCommand),
    "UpdateBookmarkCommand": (()=>UpdateBookmarkCommand)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-widget/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * The bookmark form view controller class.
 *
 * See {@link module:bookmark/ui/bookmarkformview~BookmarkFormView}.
 */ class BookmarkFormView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * Tracks information about DOM focus in the form.
	 */ focusTracker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusTracker"]();
    /**
	 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
	 */ keystrokes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeystrokeHandler"]();
    /**
	 * The ID input view.
	 */ idInputView;
    /**
	 * The Submit button view.
	 */ buttonView;
    /**
	 * A collection of form child views in the form.
	 */ children;
    /**
	 * An array of form validators used by {@link #isValid}.
	 */ _validators;
    /**
	 * A collection of views that can be focused in the form.
	 */ _focusables = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewCollection"]();
    /**
	 * Helps cycling over {@link #_focusables} in the form.
	 */ _focusCycler;
    /**
	 * Creates an instance of the {@link module:bookmark/ui/bookmarkformview~BookmarkFormView} class.
	 *
	 * Also see {@link #render}.
	 *
	 * @param locale The localization services instance.
	 * @param validators  Form validators used by {@link #isValid}.
	 */ constructor(locale, validators){
        super(locale);
        const t = locale.t;
        this._validators = validators;
        this.idInputView = this._createIdInput();
        this.buttonView = this._createButton(t('Insert'), 'ck-button-action ck-button-bold');
        this.buttonView.type = 'submit';
        this.children = this._createViewChildren();
        this._focusCycler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusCycler"]({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
                // Navigate form fields backwards using the Shift + Tab keystroke.
                focusPrevious: 'shift + tab',
                // Navigate form fields forwards using the Tab key.
                focusNext: 'tab'
            }
        });
        const classList = [
            'ck',
            'ck-bookmark-view'
        ];
        this.setTemplate({
            tag: 'form',
            attributes: {
                class: classList,
                // https://github.com/ckeditor/ckeditor5-link/issues/90
                tabindex: '-1'
            },
            children: this.children
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["submitHandler"])({
            view: this
        });
        const childViews = [
            this.idInputView,
            this.buttonView
        ];
        childViews.forEach((v)=>{
            // Register the view as focusable.
            this._focusables.add(v);
            // Register the view in the focus tracker.
            this.focusTracker.add(v.element);
        });
        // Start listening for the keystrokes coming from #element.
        this.keystrokes.listenTo(this.element);
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
    }
    /**
	 * Focuses the fist {@link #_focusables} in the form.
	 */ focus() {
        this._focusCycler.focusFirst();
    }
    /**
	 * Validates the form and returns `false` when some fields are invalid.
	 */ isValid() {
        this.resetFormStatus();
        for (const validator of this._validators){
            const errorText = validator(this);
            // One error per field is enough.
            if (errorText) {
                // Apply updated error.
                this.idInputView.errorText = errorText;
                return false;
            }
        }
        return true;
    }
    /**
	 * Cleans up the supplementary error and information text of the {@link #idInputView}
	 * bringing them back to the state when the form has been displayed for the first time.
	 *
	 * See {@link #isValid}.
	 */ resetFormStatus() {
        this.idInputView.errorText = null;
    }
    /**
	 * Creates header and form view.
	 */ _createViewChildren() {
        const children = this.createCollection();
        const t = this.t;
        children.add(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FormHeaderView"](this.locale, {
            label: t('Bookmark')
        }));
        children.add(this._createFormContentView());
        return children;
    }
    /**
	 * Creates form content view with input and button.
	 */ _createFormContentView() {
        const view = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"](this.locale);
        const children = this.createCollection();
        const classList = [
            'ck',
            'ck-bookmark-form',
            'ck-responsive-form'
        ];
        children.add(this.idInputView);
        children.add(this.buttonView);
        view.setTemplate({
            tag: 'div',
            attributes: {
                class: classList
            },
            children
        });
        return view;
    }
    /**
	 * Creates a labeled input view.
	 *
	 * @returns Labeled field view instance.
	 */ _createIdInput() {
        const t = this.locale.t;
        const labeledInput = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LabeledFieldView"](this.locale, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLabeledInputText"]);
        labeledInput.label = t('Bookmark name');
        labeledInput.infoText = t('Enter the bookmark name without spaces.');
        return labeledInput;
    }
    /**
	 * Creates a button view.
	 *
	 * @param label The button label.
	 * @param className The additional button CSS class name.
	 * @returns The button view instance.
	 */ _createButton(label, className) {
        const button = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](this.locale);
        button.set({
            label,
            withText: true
        });
        button.extendTemplate({
            attributes: {
                class: className
            }
        });
        return button;
    }
    /**
	 * The native DOM `value` of the {@link #idInputView} element.
	 *
	 * **Note**: Do not confuse it with the {@link module:ui/inputtext/inputtextview~InputTextView#value}
	 * which works one way only and may not represent the actual state of the component in the DOM.
	 */ get id() {
        const { element } = this.idInputView.fieldView;
        if (!element) {
            return null;
        }
        return element.value.trim();
    }
}
/**
 * The bookmark actions view class. This view displays the bookmark preview, allows
 * removing or editing the bookmark.
 */ class BookmarkActionsView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * Tracks information about DOM focus in the actions.
	 */ focusTracker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusTracker"]();
    /**
	 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
	 */ keystrokes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeystrokeHandler"]();
    /**
	 * The bookmark preview view.
	 */ bookmarkPreviewView;
    /**
	 * The remove button view.
	 */ removeButtonView;
    /**
	 * The edit bookmark button view.
	 */ editButtonView;
    /**
	 * A collection of views that can be focused in the view.
	 */ _focusables = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewCollection"]();
    /**
	 * Helps cycling over {@link #_focusables} in the view.
	 */ _focusCycler;
    /**
	 * @inheritDoc
	 */ constructor(locale){
        super(locale);
        const t = locale.t;
        this.bookmarkPreviewView = this._createBookmarkPreviewView();
        this.removeButtonView = this._createButton(t('Remove bookmark'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].remove, 'remove', this.bookmarkPreviewView);
        this.editButtonView = this._createButton(t('Edit bookmark'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].pencil, 'edit', this.bookmarkPreviewView);
        this.set('id', undefined);
        this._focusCycler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusCycler"]({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
                // Navigate fields backwards using the Shift + Tab keystroke.
                focusPrevious: 'shift + tab',
                // Navigate fields forwards using the Tab key.
                focusNext: 'tab'
            }
        });
        this.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-bookmark-actions',
                    'ck-responsive-form'
                ],
                // https://github.com/ckeditor/ckeditor5-link/issues/90
                tabindex: '-1'
            },
            children: [
                this.bookmarkPreviewView,
                this.editButtonView,
                this.removeButtonView
            ]
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        const childViews = [
            this.editButtonView,
            this.removeButtonView
        ];
        childViews.forEach((v)=>{
            // Register the view as focusable.
            this._focusables.add(v);
            // Register the view in the focus tracker.
            this.focusTracker.add(v.element);
        });
        // Start listening for the keystrokes coming from #element.
        this.keystrokes.listenTo(this.element);
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
    }
    /**
	 * Focuses the fist {@link #_focusables} in the actions.
	 */ focus() {
        this._focusCycler.focusFirst();
    }
    /**
	 * Creates a button view.
	 *
	 * @param label The button label.
	 * @param icon The button icon.
	 * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
	 * @param additionalLabel An additional label outside the button.
	 * @returns The button view instance.
	 */ _createButton(label, icon, eventName, additionalLabel) {
        const button = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](this.locale);
        button.set({
            label,
            icon,
            tooltip: true
        });
        button.delegate('execute').to(this, eventName);
        // Since button label `id` is bound to the `ariaLabelledBy` property
        // we need to modify this binding to include only the first ID token
        // as this button will be labeled by multiple labels.
        button.labelView.unbind('id');
        button.labelView.bind('id').to(button, 'ariaLabelledBy', (ariaLabelledBy)=>{
            return getFirstToken(ariaLabelledBy);
        });
        button.ariaLabelledBy = `${button.ariaLabelledBy} ${additionalLabel.id}`;
        return button;
    }
    /**
	 * Creates a bookmark name preview label.
	 *
	 * @returns The label view instance.
	 */ _createBookmarkPreviewView() {
        const label = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LabelView"](this.locale);
        label.extendTemplate({
            attributes: {
                class: [
                    'ck',
                    'ck-bookmark-actions__preview'
                ]
            }
        });
        // Bind label text with the bookmark ID.
        label.bind('text').to(this, 'id');
        return label;
    }
}
/**
 * Returns the first token from space separated token list.
 */ function getFirstToken(tokenList) {
    return tokenList.split(' ')[0];
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module bookmark/utils
 */ /**
 * Returns `true` if the bookmark id is valid; otherwise, returns `false`.
 */ function isBookmarkIdValid(id) {
    if (!id || typeof id !== 'string') {
        return false;
    }
    if (/\s/.test(id)) {
        return false;
    }
    return true;
}
/**
 * The insert bookmark command.
 *
 * The command is registered by {@link module:bookmark/bookmarkediting~BookmarkEditing} as `'insertBookmark'`.
 *
 * To insert a bookmark element at place where is the current collapsed selection or where is the beginning of document selection,
 * execute the command passing the bookmark id as a parameter:
 *
 * ```ts
 * editor.execute( 'insertBookmark', { bookmarkId: 'foo_bar' } );
 * ```
 */ class InsertBookmarkCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const position = this._getPositionToInsertBookmark(selection);
        this.isEnabled = !!position;
    }
    /**
	 * Executes the command.
	 *
	 * @fires execute
	 * @param options Command options.
	 * @param options.bookmarkId The value of the `bookmarkId` attribute.
	 */ execute(options) {
        if (!options) {
            return;
        }
        const { bookmarkId } = options;
        if (!isBookmarkIdValid(bookmarkId)) {
            /**
			 * Insert bookmark command can be executed only with a valid name.
			 *
			 * A valid bookmark name must be a non-empty string and must not contain any spaces.
			 *
			 * @error insert-bookmark-command-executed-with-invalid-name
			 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('insert-bookmark-command-executed-with-invalid-name');
            return;
        }
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        model.change((writer)=>{
            let position = this._getPositionToInsertBookmark(selection);
            const isBookmarkAllowed = model.schema.checkChild(position, 'bookmark');
            // If the position does not allow for `bookmark` but allows for a `paragraph`
            // then insert a `paragraph` then we will insert a `bookmark` inside.
            if (!isBookmarkAllowed) {
                const newPosition = editor.execute('insertParagraph', {
                    position
                });
                if (!newPosition) {
                    return;
                }
                position = newPosition;
            }
            const bookmarkElement = writer.createElement('bookmark', {
                ...Object.fromEntries(selection.getAttributes()),
                bookmarkId
            });
            model.insertObject(bookmarkElement, position, null, {
                setSelection: 'on'
            });
        });
    }
    /**
	 * Returns the position where the bookmark can be inserted. And if it is not possible to insert a bookmark,
	 * check if it is possible to insert a paragraph.
	 */ _getPositionToInsertBookmark(selection) {
        const model = this.editor.model;
        const schema = model.schema;
        const firstRange = selection.getFirstRange();
        const startPosition = firstRange.start;
        // Return position if it is allowed to insert bookmark or if it is allowed to insert paragraph.
        if (isBookmarkAllowed(startPosition, schema)) {
            return startPosition;
        }
        for (const { previousPosition, item } of firstRange){
            // When the table cell is selected (from the outside) we look for the first paragraph-like element inside.
            if (item.is('element') && schema.checkChild(item, '$text') && isBookmarkAllowed(item, schema)) {
                return model.createPositionAt(item, 0);
            }
            if (isBookmarkAllowed(previousPosition, schema)) {
                return previousPosition;
            }
        }
        return null;
    }
}
/**
 * Verify if the given position allows for bookmark insertion. Verify if auto-paragraphing could help.
 */ function isBookmarkAllowed(position, schema) {
    if (schema.checkChild(position, 'bookmark')) {
        return true;
    }
    if (!schema.checkChild(position, 'paragraph')) {
        return false;
    }
    return schema.checkChild('paragraph', 'bookmark');
}
/**
 * The update bookmark command.
 *
 * The command is registered by {@link module:bookmark/bookmarkediting~BookmarkEditing} as `'updateBookmark'`.
 *
 * To update the `bookmarkId` of current selected bookmark element, execute the command passing the bookmark id as a parameter:
 *
 * ```ts
 * editor.execute( 'updateBookmark', { bookmarkId: 'newId' } );
 * ```
 */ class UpdateBookmarkCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedBookmark = getSelectedBookmark(selection);
        this.isEnabled = !!selectedBookmark;
        this.value = selectedBookmark ? selectedBookmark.getAttribute('bookmarkId') : undefined;
    }
    /**
	 * Executes the command.
	 *
	 * @fires execute
	 * @param options Command options.
	 * @param options.bookmarkId The new value of the `bookmarkId` attribute to set.
	 */ execute(options) {
        if (!options) {
            return;
        }
        const { bookmarkId } = options;
        if (!isBookmarkIdValid(bookmarkId)) {
            /**
			 * Update bookmark command can be executed only with a valid name.
			 *
			 * A valid bookmark name must be a non-empty string and must not contain any spaces.
			 *
			 * @error update-bookmark-command-executed-with-invalid-name
			 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('update-bookmark-command-executed-with-invalid-name');
            return;
        }
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedBookmark = getSelectedBookmark(selection);
        if (selectedBookmark) {
            model.change((writer)=>{
                writer.setAttribute('bookmarkId', bookmarkId, selectedBookmark);
            });
        }
    }
}
/**
 * Returns the selected `bookmark` element in the model, if any.
 */ function getSelectedBookmark(selection) {
    const element = selection.getSelectedElement();
    if (!!element && element.is('element', 'bookmark')) {
        return element;
    }
    return null;
}
/**
 * The bookmark editing plugin.
 */ class BookmarkEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * A collection of bookmarks elements in the document.
	 */ _bookmarkElements = new Map();
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'BookmarkEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const { editor } = this;
        this._defineSchema();
        this._defineConverters();
        editor.commands.add('insertBookmark', new InsertBookmarkCommand(editor));
        editor.commands.add('updateBookmark', new UpdateBookmarkCommand(editor));
        this.listenTo(editor.model.document, 'change:data', ()=>{
            this._trackBookmarkElements();
        });
    }
    /**
	 * Returns the model element for the given bookmark ID if it exists.
	 */ getElementForBookmarkId(bookmarkId) {
        for (const [element, id] of this._bookmarkElements){
            if (id == bookmarkId) {
                return element;
            }
        }
        return null;
    }
    /**
	 * Defines the schema for the bookmark feature.
	 */ _defineSchema() {
        const schema = this.editor.model.schema;
        schema.register('bookmark', {
            inheritAllFrom: '$inlineObject',
            allowAttributes: 'bookmarkId',
            disallowAttributes: [
                'linkHref',
                'htmlA'
            ]
        });
    }
    /**
	 * Defines the converters for the bookmark feature.
	 */ _defineConverters() {
        const { editor } = this;
        const { conversion, t } = editor;
        editor.data.htmlProcessor.domConverter.registerInlineObjectMatcher((element)=>upcastMatcher(element));
        // Register an inline object matcher so that bookmarks <a>s are correctly recognized as inline elements in editing pipeline.
        // This prevents converting spaces around bookmarks to `&nbsp;`s.
        editor.editing.view.domConverter.registerInlineObjectMatcher((element)=>upcastMatcher(element, false));
        conversion.for('dataDowncast').elementToElement({
            model: {
                name: 'bookmark',
                attributes: [
                    'bookmarkId'
                ]
            },
            view: (modelElement, { writer })=>{
                const emptyElement = writer.createEmptyElement('a', {
                    'id': modelElement.getAttribute('bookmarkId')
                });
                // `getFillerOffset` is not needed to set here, because `emptyElement` has already covered it.
                return emptyElement;
            }
        });
        conversion.for('editingDowncast').elementToElement({
            model: {
                name: 'bookmark',
                attributes: [
                    'bookmarkId'
                ]
            },
            view: (modelElement, { writer })=>{
                const id = modelElement.getAttribute('bookmarkId');
                const containerElement = writer.createContainerElement('a', {
                    id,
                    class: 'ck-bookmark'
                }, [
                    this._createBookmarkUIElement(writer)
                ]);
                this._bookmarkElements.set(modelElement, id);
                // `getFillerOffset` is not needed to set here, because `toWidget` has already covered it.
                const labelCreator = ()=>`${id} ${t('bookmark widget')}`;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toWidget"])(containerElement, writer, {
                    label: labelCreator
                });
            }
        });
        conversion.for('upcast').add((dispatcher)=>dispatcher.on('element:a', dataViewModelAnchorInsertion(editor)));
    }
    /**
	 * Creates a UI element for the `bookmark` representation in editing view.
	 */ _createBookmarkUIElement(writer) {
        return writer.createUIElement('span', {
            class: 'ck-bookmark__icon'
        }, function(domDocument) {
            const domElement = this.toDomElement(domDocument);
            const icon = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IconView"]();
            icon.set({
                content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].bookmarkInline,
                isColorInherited: false
            });
            icon.render();
            domElement.appendChild(icon.element);
            return domElement;
        });
    }
    /**
	 * Tracking the added or removed bookmark elements.
	 */ _trackBookmarkElements() {
        this._bookmarkElements.forEach((id, element)=>{
            if (element.root.rootName === '$graveyard') {
                this._bookmarkElements.delete(element);
            }
        });
    }
}
/**
 * A helper function to match an `anchor` element which must contain `id` or `name` attribute but without `href` attribute,
 * also when `expectEmpty` is set to `true` but the element is not empty matcher should not match any element.
 *
 * @param element The element to be checked.
 * @param expectEmpty Default set to `true`, when set to `false` matcher expects that `anchor` is not empty;
 * in editing pipeline it's not empty because it contains the `UIElement`.
 */ function upcastMatcher(element, expectEmpty = true) {
    const isAnchorElement = element.name === 'a';
    if (!isAnchorElement) {
        return null;
    }
    if (expectEmpty && !element.isEmpty) {
        return null;
    }
    const hasIdAttribute = element.hasAttribute('id');
    const hasNameAttribute = element.hasAttribute('name');
    const hasHrefAttribute = element.hasAttribute('href');
    if (hasIdAttribute && !hasHrefAttribute) {
        return {
            name: true,
            attributes: [
                'id'
            ]
        };
    }
    if (hasNameAttribute && !hasHrefAttribute) {
        return {
            name: true,
            attributes: [
                'name'
            ]
        };
    }
    return null;
}
/**
 * A view-to-model converter that handles converting pointed or wrapped anchors with `id` and/or `name` attributes.
 *
 * @returns Returns a conversion callback.
 */ function dataViewModelAnchorInsertion(editor) {
    return (evt, data, conversionApi)=>{
        const viewItem = data.viewItem;
        const match = upcastMatcher(viewItem, false);
        if (!match || !conversionApi.consumable.test(viewItem, match)) {
            return;
        }
        const enableNonEmptyAnchorConversion = isEnabledNonEmptyAnchorConversion(editor);
        if (!enableNonEmptyAnchorConversion && !viewItem.isEmpty) {
            return;
        }
        const modelWriter = conversionApi.writer;
        const anchorId = viewItem.getAttribute('id');
        const anchorName = viewItem.getAttribute('name');
        const bookmarkId = anchorId || anchorName;
        const bookmark = modelWriter.createElement('bookmark', {
            bookmarkId
        });
        if (!conversionApi.safeInsert(bookmark, data.modelCursor)) {
            return;
        }
        conversionApi.consumable.consume(viewItem, match);
        if (anchorId === anchorName) {
            conversionApi.consumable.consume(viewItem, {
                attributes: [
                    'name'
                ]
            });
        }
        conversionApi.updateConversionResult(bookmark, data);
        // Convert children uses the result of `bookmark` insertion to convert the `anchor` content
        // after the bookmark element (not inside it).
        const { modelCursor, modelRange } = conversionApi.convertChildren(viewItem, data.modelCursor);
        data.modelCursor = modelCursor;
        data.modelRange = modelWriter.createRange(data.modelRange.start, modelRange.end);
    };
}
/**
 * Normalize the bookmark configuration option `enableNonEmptyAnchorConversion`.
 */ function isEnabledNonEmptyAnchorConversion(editor) {
    const enableNonEmptyAnchorConversion = editor.config.get('bookmark.enableNonEmptyAnchorConversion');
    // When not defined, option `enableNonEmptyAnchorConversion` by default is set to `true`.
    return enableNonEmptyAnchorConversion !== undefined ? enableNonEmptyAnchorConversion : true;
}
const VISUAL_SELECTION_MARKER_NAME = 'bookmark-ui';
/**
 * The UI plugin of the bookmark feature.
 *
 * It registers the `'bookmark'` UI button in the editor's {@link module:ui/componentfactory~ComponentFactory component factory}
 * which inserts the `bookmark` element upon selection.
 */ class BookmarkUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * The actions view displayed inside of the balloon.
	 */ actionsView = null;
    /**
	 * The form view displayed inside the balloon.
	 */ formView = null;
    /**
	 * The contextual balloon plugin instance.
	 */ _balloon;
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            BookmarkEditing,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ContextualBalloon"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'BookmarkUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.editing.view.addObserver(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClickObserver"]);
        this._balloon = editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ContextualBalloon"]);
        // Create toolbar buttons.
        this._createToolbarBookmarkButton();
        this._enableBalloonActivators();
        // Renders a fake visual selection marker on an expanded selection.
        editor.conversion.for('editingDowncast').markerToHighlight({
            model: VISUAL_SELECTION_MARKER_NAME,
            view: {
                classes: [
                    'ck-fake-bookmark-selection'
                ]
            }
        });
        // Renders a fake visual selection marker on a collapsed selection.
        editor.conversion.for('editingDowncast').markerToElement({
            model: VISUAL_SELECTION_MARKER_NAME,
            view: (data, { writer })=>{
                if (!data.markerRange.isCollapsed) {
                    return null;
                }
                const markerElement = writer.createUIElement('span');
                writer.addClass([
                    'ck-fake-bookmark-selection',
                    'ck-fake-bookmark-selection_collapsed'
                ], markerElement);
                return markerElement;
            }
        });
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        // Destroy created UI components as they are not automatically destroyed (see ckeditor5#1341).
        if (this.formView) {
            this.formView.destroy();
        }
        if (this.actionsView) {
            this.actionsView.destroy();
        }
    }
    /**
	 * Creates views.
	 */ _createViews() {
        this.actionsView = this._createActionsView();
        this.formView = this._createFormView();
        // Attach lifecycle actions to the the balloon.
        this._enableUserBalloonInteractions();
    }
    /**
	 * Creates the {@link module:bookmark/ui/bookmarkactionsview~BookmarkActionsView} instance.
	 */ _createActionsView() {
        const editor = this.editor;
        const actionsView = new BookmarkActionsView(editor.locale);
        const updateBookmarkCommand = editor.commands.get('updateBookmark');
        const deleteCommand = editor.commands.get('delete');
        actionsView.bind('id').to(updateBookmarkCommand, 'value');
        actionsView.editButtonView.bind('isEnabled').to(updateBookmarkCommand);
        actionsView.removeButtonView.bind('isEnabled').to(deleteCommand);
        // Display edit form view after clicking on the "Edit" button.
        this.listenTo(actionsView, 'edit', ()=>{
            this._addFormView();
        });
        // Execute remove command after clicking on the "Remove" button.
        this.listenTo(actionsView, 'remove', ()=>{
            this._hideUI();
            editor.execute('delete');
        });
        // Close the panel on esc key press when the **actions have focus**.
        actionsView.keystrokes.set('Esc', (data, cancel)=>{
            this._hideUI();
            cancel();
        });
        return actionsView;
    }
    /**
	 * Creates the {@link module:bookmark/ui/bookmarkformview~BookmarkFormView} instance.
	 */ _createFormView() {
        const editor = this.editor;
        const locale = editor.locale;
        const insertBookmarkCommand = editor.commands.get('insertBookmark');
        const updateBookmarkCommand = editor.commands.get('updateBookmark');
        const commands = [
            insertBookmarkCommand,
            updateBookmarkCommand
        ];
        const formView = new ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CssTransitionDisablerMixin"])(BookmarkFormView))(locale, getFormValidators(editor));
        formView.idInputView.fieldView.bind('value').to(updateBookmarkCommand, 'value');
        // Form elements should be read-only when corresponding commands are disabled.
        formView.idInputView.bind('isEnabled').toMany(commands, 'isEnabled', (...areEnabled)=>areEnabled.some((isEnabled)=>isEnabled));
        // Disable the "save" button if the command is disabled.
        formView.buttonView.bind('isEnabled').toMany(commands, 'isEnabled', (...areEnabled)=>areEnabled.some((isEnabled)=>isEnabled));
        // Execute link command after clicking the "Save" button.
        this.listenTo(formView, 'submit', ()=>{
            if (formView.isValid()) {
                const value = formView.id;
                if (this._getSelectedBookmarkElement()) {
                    editor.execute('updateBookmark', {
                        bookmarkId: value
                    });
                } else {
                    editor.execute('insertBookmark', {
                        bookmarkId: value
                    });
                }
                this._closeFormView();
            }
        });
        // Update balloon position when form error changes.
        this.listenTo(formView.idInputView, 'change:errorText', ()=>{
            editor.ui.update();
        });
        // Close the panel on esc key press when the **form has focus**.
        formView.keystrokes.set('Esc', (data, cancel)=>{
            this._closeFormView();
            cancel();
        });
        return formView;
    }
    /**
	 * Creates a toolbar Bookmark button. Clicking this button will show
	 * a {@link #_balloon} attached to the selection.
	 */ _createToolbarBookmarkButton() {
        const editor = this.editor;
        editor.ui.componentFactory.add('bookmark', ()=>{
            const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
            buttonView.set({
                tooltip: true
            });
            return buttonView;
        });
        editor.ui.componentFactory.add('menuBar:bookmark', ()=>{
            return this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
        });
    }
    /**
	 * Creates a button for `bookmark` command to use either in toolbar or in menu bar.
	 */ _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const view = new ButtonClass(locale);
        const insertCommand = editor.commands.get('insertBookmark');
        const updateCommand = editor.commands.get('updateBookmark');
        const t = locale.t;
        view.set({
            label: t('Bookmark'),
            icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].bookmark
        });
        // Execute the command.
        this.listenTo(view, 'execute', ()=>this._showUI(true));
        view.bind('isEnabled').toMany([
            insertCommand,
            updateCommand
        ], 'isEnabled', (...areEnabled)=>areEnabled.some((isEnabled)=>isEnabled));
        view.bind('isOn').to(updateCommand, 'value', (value)=>!!value);
        return view;
    }
    /**
	 * Attaches actions that control whether the balloon panel containing the
	 * {@link #formView} should be displayed.
	 */ _enableBalloonActivators() {
        const editor = this.editor;
        const viewDocument = editor.editing.view.document;
        // Handle click on view document and show panel when selection is placed inside the bookmark element.
        // Keep panel open until selection will be inside the same bookmark element.
        this.listenTo(viewDocument, 'click', ()=>{
            const bookmark = this._getSelectedBookmarkElement();
            if (bookmark) {
                // Then show panel but keep focus inside editor editable.
                this._showUI();
            }
        });
    }
    /**
	 * Attaches actions that control whether the balloon panel containing the
	 * {@link #formView} is visible or not.
	 */ _enableUserBalloonInteractions() {
        // Focus the form if the balloon is visible and the Tab key has been pressed.
        this.editor.keystrokes.set('Tab', (data, cancel)=>{
            if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) {
                this.actionsView.focus();
                cancel();
            }
        }, {
            // Use the high priority because the bookmark UI navigation is more important
            // than other feature's actions, e.g. list indentation.
            priority: 'high'
        });
        // Close the panel on the Esc key press when the editable has focus and the balloon is visible.
        this.editor.keystrokes.set('Esc', (data, cancel)=>{
            if (this._isUIVisible) {
                this._hideUI();
                cancel();
            }
        });
        // Close on click outside of balloon panel element.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clickOutsideHandler"])({
            emitter: this.formView,
            activator: ()=>this._isUIInPanel,
            contextElements: ()=>[
                    this._balloon.view.element
                ],
            callback: ()=>this._hideUI()
        });
    }
    /**
	 * Updates the button label. If bookmark is selected label is set to 'Update' otherwise
	 * it is 'Insert'.
	 */ _updateFormButtonLabel(isBookmarkSelected) {
        const t = this.editor.locale.t;
        this.formView.buttonView.label = isBookmarkSelected ? t('Update') : t('Insert');
    }
    /**
	 * Adds the {@link #actionsView} to the {@link #_balloon}.
	 *
	 * @internal
	 */ _addActionsView() {
        if (!this.actionsView) {
            this._createViews();
        }
        if (this._areActionsInPanel) {
            return;
        }
        this._balloon.add({
            view: this.actionsView,
            position: this._getBalloonPositionData()
        });
    }
    /**
	 * Adds the {@link #formView} to the {@link #_balloon}.
	 */ _addFormView() {
        if (!this.formView) {
            this._createViews();
        }
        if (this._isFormInPanel) {
            return;
        }
        const editor = this.editor;
        const updateBookmarkCommand = editor.commands.get('updateBookmark');
        this.formView.disableCssTransitions();
        this.formView.resetFormStatus();
        this._balloon.add({
            view: this.formView,
            position: this._getBalloonPositionData()
        });
        this.formView.idInputView.fieldView.value = updateBookmarkCommand.value || '';
        // Select input when form view is currently visible.
        if (this._balloon.visibleView === this.formView) {
            this.formView.idInputView.fieldView.select();
        }
        this.formView.enableCssTransitions();
    }
    /**
	 * Closes the form view. Decides whether the balloon should be hidden completely.
	 */ _closeFormView() {
        const updateBookmarkCommand = this.editor.commands.get('updateBookmark');
        if (updateBookmarkCommand.value !== undefined) {
            this._removeFormView();
        } else {
            this._hideUI();
        }
    }
    /**
	 * Removes the {@link #formView} from the {@link #_balloon}.
	 */ _removeFormView() {
        if (this._isFormInPanel) {
            // Blur the input element before removing it from DOM to prevent issues in some browsers.
            // See https://github.com/ckeditor/ckeditor5/issues/1501.
            this.formView.buttonView.focus();
            // Reset the ID field to update the state of the submit button.
            this.formView.idInputView.fieldView.reset();
            this._balloon.remove(this.formView);
            // Because the form has an input which has focus, the focus must be brought back
            // to the editor. Otherwise, it would be lost.
            this.editor.editing.view.focus();
            this._hideFakeVisualSelection();
        }
    }
    /**
	 * Shows the correct UI type. It is either {@link #formView} or {@link #actionsView}.
	 */ _showUI(forceVisible = false) {
        if (!this.formView) {
            this._createViews();
        }
        // When there's no bookmark under the selection, go straight to the editing UI.
        if (!this._getSelectedBookmarkElement()) {
            // Show visual selection on a text without a bookmark when the contextual balloon is displayed.
            this._showFakeVisualSelection();
            this._addActionsView();
            // Be sure panel with bookmark is visible.
            if (forceVisible) {
                this._balloon.showStack('main');
            }
            this._addFormView();
        } else {
            // Go to the editing UI if actions are already visible.
            if (this._areActionsVisible) {
                this._addFormView();
            } else {
                this._addActionsView();
            }
            // Be sure panel with bookmark is visible.
            if (forceVisible) {
                this._balloon.showStack('main');
            }
        }
        // Begin responding to ui#update once the UI is added.
        this._startUpdatingUI();
    }
    /**
	 * Removes the {@link #formView} from the {@link #_balloon}.
	 *
	 * See {@link #_addFormView}, {@link #_addActionsView}.
	 */ _hideUI() {
        if (!this._isUIInPanel) {
            return;
        }
        const editor = this.editor;
        this.stopListening(editor.ui, 'update');
        this.stopListening(this._balloon, 'change:visibleView');
        // Make sure the focus always gets back to the editable _before_ removing the focused form view.
        // Doing otherwise causes issues in some browsers. See https://github.com/ckeditor/ckeditor5-link/issues/193.
        editor.editing.view.focus();
        // Remove form first because it's on top of the stack.
        this._removeFormView();
        // Then remove the actions view because it's beneath the form.
        this._balloon.remove(this.actionsView);
        this._hideFakeVisualSelection();
    }
    /**
	 * Makes the UI react to the {@link module:ui/editorui/editorui~EditorUI#event:update} event to
	 * reposition itself when the editor UI should be refreshed.
	 *
	 * See: {@link #_hideUI} to learn when the UI stops reacting to the `update` event.
	 */ _startUpdatingUI() {
        const editor = this.editor;
        const viewDocument = editor.editing.view.document;
        let prevSelectedBookmark = this._getSelectedBookmarkElement();
        let prevSelectionParent = getSelectionParent();
        this._updateFormButtonLabel(!!prevSelectedBookmark);
        const update = ()=>{
            const selectedBookmark = this._getSelectedBookmarkElement();
            const selectionParent = getSelectionParent();
            // Hide the panel if:
            //
            // * the selection went out of the EXISTING bookmark element. E.g. user moved the caret out
            //   of the bookmark,
            // * the selection went to a different parent when creating a NEW bookmark. E.g. someone
            //   else modified the document.
            // * the selection has expanded (e.g. displaying bookmark actions then pressing SHIFT+Right arrow).
            //
            if (prevSelectedBookmark && !selectedBookmark || !prevSelectedBookmark && selectionParent !== prevSelectionParent) {
                this._hideUI();
            } else if (this._isUIVisible) {
                // If still in a bookmark element, simply update the position of the balloon.
                // If there was no bookmark (e.g. inserting one), the balloon must be moved
                // to the new position in the editing view (a new native DOM range).
                this._balloon.updatePosition(this._getBalloonPositionData());
            }
            this._updateFormButtonLabel(!!prevSelectedBookmark);
            prevSelectedBookmark = selectedBookmark;
            prevSelectionParent = selectionParent;
        };
        function getSelectionParent() {
            return viewDocument.selection.focus.getAncestors().reverse().find((node)=>node.is('element'));
        }
        this.listenTo(editor.ui, 'update', update);
        this.listenTo(this._balloon, 'change:visibleView', update);
    }
    /**
	 * Returns `true` when {@link #formView} is in the {@link #_balloon}.
	 */ get _isFormInPanel() {
        return !!this.formView && this._balloon.hasView(this.formView);
    }
    /**
	 * Returns `true` when {@link #actionsView} is in the {@link #_balloon}.
	 */ get _areActionsInPanel() {
        return !!this.actionsView && this._balloon.hasView(this.actionsView);
    }
    /**
	 * Returns `true` when {@link #actionsView} is in the {@link #_balloon} and it is
	 * currently visible.
	 */ get _areActionsVisible() {
        return !!this.actionsView && this._balloon.visibleView === this.actionsView;
    }
    /**
	 * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon}.
	 */ get _isUIInPanel() {
        return this._isFormInPanel || this._areActionsInPanel;
    }
    /**
	 * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon} and it is
	 * currently visible.
	 */ get _isUIVisible() {
        const visibleView = this._balloon.visibleView;
        return !!this.formView && visibleView == this.formView || this._areActionsVisible;
    }
    /**
	 * Returns positioning options for the {@link #_balloon}. They control the way the balloon is attached
	 * to the target element or selection.
	 */ _getBalloonPositionData() {
        const view = this.editor.editing.view;
        const model = this.editor.model;
        let target;
        const bookmarkElement = this._getSelectedBookmarkElement();
        if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
            // There are cases when we highlight selection using a marker (#7705, #4721).
            const markerViewElements = Array.from(this.editor.editing.mapper.markerNameToElements(VISUAL_SELECTION_MARKER_NAME));
            const newRange = view.createRange(view.createPositionBefore(markerViewElements[0]), view.createPositionAfter(markerViewElements[markerViewElements.length - 1]));
            target = view.domConverter.viewRangeToDom(newRange);
        } else if (bookmarkElement) {
            target = ()=>{
                const mapper = this.editor.editing.mapper;
                const domConverter = view.domConverter;
                const viewElement = mapper.toViewElement(bookmarkElement);
                return domConverter.mapViewToDom(viewElement);
            };
        }
        return target && {
            target
        };
    }
    /**
	 * Returns the bookmark {@link module:engine/view/attributeelement~AttributeElement} under
	 * the {@link module:engine/view/document~Document editing view's} selection or `null`
	 * if there is none.
	 */ _getSelectedBookmarkElement() {
        const selection = this.editor.model.document.selection;
        const element = selection.getSelectedElement();
        if (element && element.is('element', 'bookmark')) {
            return element;
        }
        return null;
    }
    /**
	 * Displays a fake visual selection when the contextual balloon is displayed.
	 *
	 * This adds a 'bookmark-ui' marker into the document that is rendered as a highlight on selected text fragment.
	 */ _showFakeVisualSelection() {
        const model = this.editor.model;
        model.change((writer)=>{
            const range = model.document.selection.getFirstRange();
            if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
                writer.updateMarker(VISUAL_SELECTION_MARKER_NAME, {
                    range
                });
            } else {
                if (range.start.isAtEnd) {
                    const startPosition = range.start.getLastMatchingPosition(({ item })=>!model.schema.isContent(item), {
                        boundaries: range
                    });
                    writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
                        usingOperation: false,
                        affectsData: false,
                        range: writer.createRange(startPosition, range.end)
                    });
                } else {
                    writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
                        usingOperation: false,
                        affectsData: false,
                        range
                    });
                }
            }
        });
    }
    /**
	 * Hides the fake visual selection created in {@link #_showFakeVisualSelection}.
	 */ _hideFakeVisualSelection() {
        const model = this.editor.model;
        if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
            model.change((writer)=>{
                writer.removeMarker(VISUAL_SELECTION_MARKER_NAME);
            });
        }
    }
}
/**
 * Returns bookmark form validation callbacks.
 */ function getFormValidators(editor) {
    const { t } = editor;
    const bookmarkEditing = editor.plugins.get(BookmarkEditing);
    return [
        (form)=>{
            if (!form.id) {
                return t('Bookmark must not be empty.');
            }
        },
        (form)=>{
            if (form.id && /\s/.test(form.id)) {
                return t('Bookmark name cannot contain space characters.');
            }
        },
        (form)=>{
            const selectedElement = editor.model.document.selection.getSelectedElement();
            const existingBookmarkForId = bookmarkEditing.getElementForBookmarkId(form.id);
            // Accept change of bookmark ID if no real change is happening (edit -> submit, without changes).
            if (selectedElement === existingBookmarkForId) {
                return;
            }
            if (existingBookmarkForId) {
                return t('Bookmark name already exists.');
            }
        }
    ];
}
/**
 * The bookmark feature.
 *
 * For a detailed overview, check the {@glink features/bookmarks Bookmarks} feature guide.
 */ class Bookmark extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Bookmark';
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            BookmarkEditing,
            BookmarkUI,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Widget"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-ckbox/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "CKBox": (()=>CKBox),
    "CKBoxEditing": (()=>CKBoxEditing),
    "CKBoxImageEdit": (()=>CKBoxImageEdit),
    "CKBoxImageEditEditing": (()=>CKBoxImageEditEditing),
    "CKBoxImageEditUI": (()=>CKBoxImageEditUI),
    "CKBoxUI": (()=>CKBoxUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$upload$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-upload/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/isEqual.js [app-client] (ecmascript) <export default as isEqual>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$blurhash$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/blurhash/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
/**
 * Introduces UI components for the `CKBox` plugin.
 *
 * The plugin introduces two UI components to the {@link module:ui/componentfactory~ComponentFactory UI component factory}:
 *
 * * the `'ckbox'` toolbar button,
 * * the `'menuBar:ckbox'` menu bar component, which is by default added to the `'Insert'` menu.
 *
 * It also integrates with the `insertImage` toolbar component and `menuBar:insertImage` menu component.
 */ class CKBoxUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CKBoxUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        const editor = this.editor;
        // Do not register the `ckbox` button if the command does not exist.
        // This might happen when CKBox library is not loaded on the page.
        if (!editor.commands.get('ckbox')) {
            return;
        }
        editor.ui.componentFactory.add('ckbox', ()=>this._createFileToolbarButton());
        editor.ui.componentFactory.add('menuBar:ckbox', ()=>this._createFileMenuBarButton());
        if (editor.plugins.has('ImageInsertUI')) {
            editor.plugins.get('ImageInsertUI').registerIntegration({
                name: 'assetManager',
                observable: ()=>editor.commands.get('ckbox'),
                buttonViewCreator: ()=>this._createImageToolbarButton(),
                formViewCreator: ()=>this._createImageDropdownButton(),
                menuBarButtonViewCreator: (isOnly)=>this._createImageMenuBarButton(isOnly ? 'insertOnly' : 'insertNested')
            });
        }
    }
    /**
	 * Creates the base for various kinds of the button component provided by this feature.
	 */ _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const view = new ButtonClass(locale);
        const command = editor.commands.get('ckbox');
        view.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled');
        view.on('execute', ()=>{
            editor.execute('ckbox');
        });
        return view;
    }
    /**
	 * Creates a simple toolbar button for files management, with an icon and a tooltip.
	 */ _createFileToolbarButton() {
        const t = this.editor.locale.t;
        const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
        button.icon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].browseFiles;
        button.label = t('Open file manager');
        button.tooltip = true;
        return button;
    }
    /**
	 * Creates a simple toolbar button for images management, with an icon and a tooltip.
	 */ _createImageToolbarButton() {
        const t = this.editor.locale.t;
        const imageInsertUI = this.editor.plugins.get('ImageInsertUI');
        const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
        button.icon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].imageAssetManager;
        button.bind('label').to(imageInsertUI, 'isImageSelected', (isImageSelected)=>isImageSelected ? t('Replace image with file manager') : t('Insert image with file manager'));
        button.tooltip = true;
        return button;
    }
    /**
	 * Creates a button for images management for the dropdown view, with an icon, text and no tooltip.
	 */ _createImageDropdownButton() {
        const t = this.editor.locale.t;
        const imageInsertUI = this.editor.plugins.get('ImageInsertUI');
        const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
        button.icon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].imageAssetManager;
        button.withText = true;
        button.bind('label').to(imageInsertUI, 'isImageSelected', (isImageSelected)=>isImageSelected ? t('Replace with file manager') : t('Insert with file manager'));
        button.on('execute', ()=>{
            imageInsertUI.dropdownView.isOpen = false;
        });
        return button;
    }
    /**
	 * Creates a button for files management for the menu bar.
	 */ _createFileMenuBarButton() {
        const t = this.editor.locale.t;
        const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
        button.icon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].browseFiles;
        button.withText = true;
        button.label = t('File');
        return button;
    }
    /**
	 * Creates a button for images management for the menu bar.
	 */ _createImageMenuBarButton(type) {
        // Use t() stored in a variable with a different name to reuse existing translations from another package.
        const translateVariableKey = this.editor.locale.t;
        const t = this.editor.locale.t;
        const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
        button.icon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].imageAssetManager;
        button.withText = true;
        switch(type){
            case 'insertOnly':
                button.label = translateVariableKey('Image');
                break;
            case 'insertNested':
                button.label = t('With file manager');
                break;
        }
        return button;
    }
}
/**
 * Converts image source set provided by the CKBox into an object containing:
 * - responsive URLs for the "webp" image format,
 * - one fallback URL for browsers that do not support the "webp" format.
 */ function getImageUrls(imageUrls) {
    const responsiveUrls = [];
    let maxWidth = 0;
    for(const key in imageUrls){
        const width = parseInt(key, 10);
        if (!isNaN(width)) {
            if (width > maxWidth) {
                maxWidth = width;
            }
            responsiveUrls.push(`${imageUrls[key]} ${key}w`);
        }
    }
    const imageSources = [
        {
            srcset: responsiveUrls.join(','),
            sizes: `(max-width: ${maxWidth}px) 100vw, ${maxWidth}px`,
            type: 'image/webp'
        }
    ];
    return {
        imageFallbackUrl: imageUrls.default,
        imageSources
    };
}
/**
 * Returns a workspace id to use for communication with the CKBox service.
 *
 * @param defaultWorkspaceId The default workspace to use taken from editor config.
 */ function getWorkspaceId(token, defaultWorkspaceId) {
    const [, binaryTokenPayload] = token.value.split('.');
    const payload = JSON.parse(atob(binaryTokenPayload));
    const workspaces = payload.auth && payload.auth.ckbox && payload.auth.ckbox.workspaces || [
        payload.aud
    ];
    if (!defaultWorkspaceId) {
        return workspaces[0];
    }
    const role = payload.auth && payload.auth.ckbox && payload.auth.ckbox.role;
    if (role == 'superadmin' || workspaces.includes(defaultWorkspaceId)) {
        return defaultWorkspaceId;
    }
    return null;
}
/**
 * Default resolution for decoding blurhash values.
 * Relatively small values must be used in order to ensure acceptable performance.
 */ const BLUR_RESOLUTION = 32;
/**
 * Generates an image data URL from its `blurhash` representation.
 */ function blurHashToDataUrl(hash) {
    if (!hash) {
        return;
    }
    try {
        const resolutionInPx = `${BLUR_RESOLUTION}px`;
        const canvas = document.createElement('canvas');
        canvas.setAttribute('width', resolutionInPx);
        canvas.setAttribute('height', resolutionInPx);
        const ctx = canvas.getContext('2d');
        /* istanbul ignore next -- @preserve */ if (!ctx) {
            return;
        }
        const imageData = ctx.createImageData(BLUR_RESOLUTION, BLUR_RESOLUTION);
        const decoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$blurhash$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(hash, BLUR_RESOLUTION, BLUR_RESOLUTION);
        imageData.data.set(decoded);
        ctx.putImageData(imageData, 0, 0);
        return canvas.toDataURL();
    } catch (e) {
        return undefined;
    }
}
/**
 * Sends the HTTP request.
 *
 * @internal
 * @param config.url the URL where the request will be sent.
 * @param config.method The HTTP method.
 * @param config.data Additional data to send.
 * @param config.onUploadProgress A callback informing about the upload progress.
 */ function sendHttpRequest({ url, method = 'GET', data, onUploadProgress, signal, authorization }) {
    const xhr = new XMLHttpRequest();
    xhr.open(method, url.toString());
    xhr.setRequestHeader('Authorization', authorization);
    xhr.setRequestHeader('CKBox-Version', 'CKEditor 5');
    xhr.responseType = 'json';
    // The callback is attached to the `signal#abort` event.
    const abortCallback = ()=>{
        xhr.abort();
    };
    return new Promise((resolve, reject)=>{
        signal.throwIfAborted();
        signal.addEventListener('abort', abortCallback);
        xhr.addEventListener('loadstart', ()=>{
            signal.addEventListener('abort', abortCallback);
        });
        xhr.addEventListener('loadend', ()=>{
            signal.removeEventListener('abort', abortCallback);
        });
        xhr.addEventListener('error', ()=>{
            reject();
        });
        xhr.addEventListener('abort', ()=>{
            reject();
        });
        xhr.addEventListener('load', ()=>{
            const response = xhr.response;
            if (!response || response.statusCode >= 400) {
                return reject(response && response.message);
            }
            resolve(response);
        });
        /* istanbul ignore else -- @preserve */ if (onUploadProgress) {
            xhr.upload.addEventListener('progress', (evt)=>{
                onUploadProgress(evt);
            });
        }
        // Send the request.
        xhr.send(data);
    });
}
const MIME_TO_EXTENSION = {
    'image/gif': 'gif',
    'image/jpeg': 'jpg',
    'image/png': 'png',
    'image/webp': 'webp',
    'image/bmp': 'bmp',
    'image/tiff': 'tiff'
};
/**
 * Returns an extension a typical file in the specified `mimeType` format would have.
 */ function convertMimeTypeToExtension(mimeType) {
    return MIME_TO_EXTENSION[mimeType];
}
/**
 * Tries to fetch the given `url` and returns 'content-type' of the response.
 */ async function getContentTypeOfUrl(url, options) {
    try {
        const response = await fetch(url, {
            method: 'HEAD',
            cache: 'force-cache',
            ...options
        });
        if (!response.ok) {
            return '';
        }
        return response.headers.get('content-type') || '';
    } catch  {
        return '';
    }
}
/**
 * Returns an extension from the given value.
 */ function getFileExtension(file) {
    const fileName = file.name;
    const extensionRegExp = /\.(?<ext>[^.]+)$/;
    const match = fileName.match(extensionRegExp);
    return match.groups.ext.toLowerCase();
}
// Defines the waiting time (in milliseconds) for inserting the chosen asset into the model. The chosen asset is temporarily stored in the
// `CKBoxCommand#_chosenAssets` and it is removed from there automatically after this time. See `CKBoxCommand#_chosenAssets` for more
// details.
const ASSET_INSERTION_WAIT_TIMEOUT = 1000;
/**
 * The CKBox command. It is used by the {@link module:ckbox/ckboxediting~CKBoxEditing CKBox editing feature} to open the CKBox file manager.
 * The file manager allows inserting an image or a link to a file into the editor content.
 *
 * ```ts
 * editor.execute( 'ckbox' );
 * ```
 *
 * **Note:** This command uses other features to perform the following tasks:
 * - To insert images it uses the {@link module:image/image/insertimagecommand~InsertImageCommand 'insertImage'} command from the
 * {@link module:image/image~Image Image feature}.
 * - To insert links to other files it uses the {@link module:link/linkcommand~LinkCommand 'link'} command from the
 * {@link module:link/link~Link Link feature}.
 */ class CKBoxCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * A set of all chosen assets. They are stored temporarily and they are automatically removed 1 second after being chosen.
	 * Chosen assets have to be "remembered" for a while to be able to map the given asset with the element inserted into the model.
	 * This association map is then used to set the ID on the model element.
	 *
	 * All chosen assets are automatically removed after the timeout, because (theoretically) it may happen that they will never be
	 * inserted into the model, even if the {@link module:link/linkcommand~LinkCommand `'link'`} command or the
	 * {@link module:image/image/insertimagecommand~InsertImageCommand `'insertImage'`} command is enabled. Such a case may arise when
	 * another plugin blocks the command execution. Then, in order not to keep the chosen (but not inserted) assets forever, we delete
	 * them automatically to prevent memory leakage. The 1 second timeout is enough to insert the asset into the model and extract the
	 * ID from the chosen asset.
	 *
	 * The assets are stored only if
	 * the {@link module:ckbox/ckboxconfig~CKBoxConfig#ignoreDataId `config.ckbox.ignoreDataId`} option is set to `false` (by default).
	 *
	 * @internal
	 */ _chosenAssets = new Set();
    /**
	 * The DOM element that acts as a mounting point for the CKBox dialog.
	 */ _wrapper = null;
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        this._initListeners();
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        this.value = this._getValue();
        this.isEnabled = this._checkEnabled();
    }
    /**
	 * @inheritDoc
	 */ execute() {
        this.fire('ckbox:open');
    }
    /**
	 * Indicates if the CKBox dialog is already opened.
	 *
	 * @protected
	 * @returns {Boolean}
	 */ _getValue() {
        return this._wrapper !== null;
    }
    /**
	 * Checks whether the command can be enabled in the current context.
	 */ _checkEnabled() {
        const imageCommand = this.editor.commands.get('insertImage');
        const linkCommand = this.editor.commands.get('link');
        if (!imageCommand.isEnabled && !linkCommand.isEnabled) {
            return false;
        }
        return true;
    }
    /**
	 * Creates the options object for the CKBox dialog.
	 *
	 * @returns The object with properties:
	 * - theme The theme for CKBox dialog.
	 * - language The language for CKBox dialog.
	 * - tokenUrl The token endpoint URL.
	 * - serviceOrigin The base URL of the API service.
	 * - forceDemoLabel Whether to force "Powered by CKBox" link.
	 * - assets.onChoose The callback function invoked after choosing the assets.
	 * - dialog.onClose The callback function invoked after closing the CKBox dialog.
	 * - dialog.width The dialog width in pixels.
	 * - dialog.height The dialog height in pixels.
	 * - categories.icons Allows setting custom icons for categories.
	 * - view.openLastView Sets if the last view visited by the user will be reopened
	 * on the next startup.
	 * - view.startupFolderId Sets the ID of the folder that will be opened on startup.
	 * - view.startupCategoryId Sets the ID of the category that will be opened on startup.
	 * - view.hideMaximizeButton Sets whether to hide the ‘Maximize’ button.
	 * - view.componentsHideTimeout Sets timeout after which upload components are hidden
	 * after completed upload.
	 * - view.dialogMinimizeTimeout Sets timeout after which upload dialog is minimized
	 * after completed upload.
	 */ _prepareOptions() {
        const editor = this.editor;
        const ckboxConfig = editor.config.get('ckbox');
        const dialog = ckboxConfig.dialog;
        const categories = ckboxConfig.categories;
        const view = ckboxConfig.view;
        const upload = ckboxConfig.upload;
        return {
            theme: ckboxConfig.theme,
            language: ckboxConfig.language,
            tokenUrl: ckboxConfig.tokenUrl,
            serviceOrigin: ckboxConfig.serviceOrigin,
            forceDemoLabel: ckboxConfig.forceDemoLabel,
            choosableFileExtensions: ckboxConfig.choosableFileExtensions,
            assets: {
                onChoose: (assets)=>this.fire('ckbox:choose', assets)
            },
            dialog: {
                onClose: ()=>this.fire('ckbox:close'),
                width: dialog && dialog.width,
                height: dialog && dialog.height
            },
            categories: categories && {
                icons: categories.icons
            },
            view: view && {
                openLastView: view.openLastView,
                startupFolderId: view.startupFolderId,
                startupCategoryId: view.startupCategoryId,
                hideMaximizeButton: view.hideMaximizeButton
            },
            upload: upload && {
                componentsHideTimeout: upload.componentsHideTimeout,
                dialogMinimizeTimeout: upload.dialogMinimizeTimeout
            }
        };
    }
    /**
	 * Initializes various event listeners for the `ckbox:*` events, because all functionality of the `ckbox` command is event-based.
	 */ _initListeners() {
        const editor = this.editor;
        const model = editor.model;
        const shouldInsertDataId = !editor.config.get('ckbox.ignoreDataId');
        const downloadableFilesConfig = editor.config.get('ckbox.downloadableFiles');
        // Refresh the command after firing the `ckbox:*` event.
        this.on('ckbox', ()=>{
            this.refresh();
        }, {
            priority: 'low'
        });
        // Handle opening of the CKBox dialog.
        this.on('ckbox:open', ()=>{
            if (!this.isEnabled || this.value) {
                return;
            }
            this._wrapper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(document, 'div', {
                class: 'ck ckbox-wrapper'
            });
            document.body.appendChild(this._wrapper);
            window.CKBox.mount(this._wrapper, this._prepareOptions());
        });
        // Handle closing of the CKBox dialog.
        this.on('ckbox:close', ()=>{
            if (!this.value) {
                return;
            }
            this._wrapper.remove();
            this._wrapper = null;
            editor.editing.view.focus();
        });
        // Handle choosing the assets.
        this.on('ckbox:choose', (evt, assets)=>{
            if (!this.isEnabled) {
                return;
            }
            const imageCommand = editor.commands.get('insertImage');
            const linkCommand = editor.commands.get('link');
            const assetsToProcess = prepareAssets({
                assets,
                downloadableFilesConfig,
                isImageAllowed: imageCommand.isEnabled,
                isLinkAllowed: linkCommand.isEnabled
            });
            const assetsCount = assetsToProcess.length;
            if (assetsCount === 0) {
                return;
            }
            // All assets are inserted in one undo step.
            model.change((writer)=>{
                for (const asset of assetsToProcess){
                    const isLastAsset = asset === assetsToProcess[assetsCount - 1];
                    const isSingleAsset = assetsCount === 1;
                    this._insertAsset(asset, isLastAsset, writer, isSingleAsset);
                    // If asset ID must be set for the inserted model element, store the asset temporarily and remove it automatically
                    // after the timeout.
                    if (shouldInsertDataId) {
                        setTimeout(()=>this._chosenAssets.delete(asset), ASSET_INSERTION_WAIT_TIMEOUT);
                        this._chosenAssets.add(asset);
                    }
                }
            });
            editor.editing.view.focus();
        });
        // Clean up after the editor is destroyed.
        this.listenTo(editor, 'destroy', ()=>{
            this.fire('ckbox:close');
            this._chosenAssets.clear();
        });
    }
    /**
	 * Inserts the asset into the model.
	 *
	 * @param asset The asset to be inserted.
	 * @param isLastAsset Indicates if the current asset is the last one from the chosen set.
	 * @param writer An instance of the model writer.
	 * @param isSingleAsset It's true when only one asset is processed.
	 */ _insertAsset(asset, isLastAsset, writer, isSingleAsset) {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        // Remove the `linkHref` attribute to not affect the asset to be inserted.
        writer.removeSelectionAttribute('linkHref');
        if (asset.type === 'image') {
            this._insertImage(asset);
        } else {
            this._insertLink(asset, writer, isSingleAsset);
        }
        // Except for the last chosen asset, move the selection to the end of the current range to avoid overwriting other, already
        // inserted assets.
        if (!isLastAsset) {
            writer.setSelection(selection.getLastPosition());
        }
    }
    /**
	 * Inserts the image by calling the `insertImage` command.
	 *
	 * @param asset The asset to be inserted.
	 */ _insertImage(asset) {
        const editor = this.editor;
        const { imageFallbackUrl, imageSources, imageTextAlternative, imageWidth, imageHeight, imagePlaceholder } = asset.attributes;
        editor.execute('insertImage', {
            source: {
                src: imageFallbackUrl,
                sources: imageSources,
                alt: imageTextAlternative,
                width: imageWidth,
                height: imageHeight,
                ...imagePlaceholder ? {
                    placeholder: imagePlaceholder
                } : null
            }
        });
    }
    /**
	 * Inserts the link to the asset by calling the `link` command.
	 *
	 * @param asset The asset to be inserted.
	 * @param writer An instance of the model writer.
	 * @param isSingleAsset It's true when only one asset is processed.
	 */ _insertLink(asset, writer, isSingleAsset) {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const { linkName, linkHref } = asset.attributes;
        // If the selection is collapsed, insert the asset name as the link label and select it.
        if (selection.isCollapsed) {
            const selectionAttributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toMap"])(selection.getAttributes());
            const textNode = writer.createText(linkName, selectionAttributes);
            if (!isSingleAsset) {
                const selectionLastPosition = selection.getLastPosition();
                const parentElement = selectionLastPosition.parent;
                // Insert new `paragraph` when selection is not in an empty `paragraph`.
                if (!(parentElement.name === 'paragraph' && parentElement.isEmpty)) {
                    editor.execute('insertParagraph', {
                        position: selectionLastPosition
                    });
                }
                const range = model.insertContent(textNode);
                writer.setSelection(range);
                editor.execute('link', linkHref);
                return;
            }
            const range = model.insertContent(textNode);
            writer.setSelection(range);
        }
        editor.execute('link', linkHref);
    }
}
/**
 * Parses the chosen assets into the internal data format. Filters out chosen assets that are not allowed.
 */ function prepareAssets({ downloadableFilesConfig, assets, isImageAllowed, isLinkAllowed }) {
    return assets.map((asset)=>isImage(asset) ? {
            id: asset.data.id,
            type: 'image',
            attributes: prepareImageAssetAttributes(asset)
        } : {
            id: asset.data.id,
            type: 'link',
            attributes: prepareLinkAssetAttributes(asset, downloadableFilesConfig)
        }).filter((asset)=>asset.type === 'image' ? isImageAllowed : isLinkAllowed);
}
/**
 * Parses the assets attributes into the internal data format.
 *
 * @internal
 */ function prepareImageAssetAttributes(asset) {
    const { imageFallbackUrl, imageSources } = getImageUrls(asset.data.imageUrls);
    const { description, width, height, blurHash } = asset.data.metadata;
    const imagePlaceholder = blurHashToDataUrl(blurHash);
    return {
        imageFallbackUrl,
        imageSources,
        imageTextAlternative: description || '',
        imageWidth: width,
        imageHeight: height,
        ...imagePlaceholder ? {
            imagePlaceholder
        } : null
    };
}
/**
 * Parses the assets attributes into the internal data format.
 *
 * @param asset The asset to prepare the attributes for.
 * @param config The CKBox download asset configuration.
 */ function prepareLinkAssetAttributes(asset, config) {
    return {
        linkName: asset.data.name,
        linkHref: getAssetUrl(asset, config)
    };
}
/**
 * Checks whether the asset is an image.
 */ function isImage(asset) {
    const metadata = asset.data.metadata;
    if (!metadata) {
        return false;
    }
    return metadata.width && metadata.height;
}
/**
 * Creates the URL for the asset.
 *
 * @param asset The asset to create the URL for.
 * @param config The CKBox download asset configuration.
 */ function getAssetUrl(asset, config) {
    const url = new URL(asset.data.url);
    if (isDownloadableAsset(asset, config)) {
        url.searchParams.set('download', 'true');
    }
    return url.toString();
}
/**
 * Determines if download should be enabled for given asset based on configuration.
 *
 * @param asset The asset to check.
 * @param config The CKBox download asset configuration.
 */ function isDownloadableAsset(asset, config) {
    if (typeof config === 'function') {
        return config(asset);
    }
    return true;
}
const DEFAULT_CKBOX_THEME_NAME = 'lark';
/**
 * The CKBox utilities plugin.
 */ class CKBoxUtils extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * CKEditor Cloud Services access token.
	 */ _token;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CKBoxUtils';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            'CloudServices'
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const hasConfiguration = !!editor.config.get('ckbox');
        const isLibraryLoaded = !!window.CKBox;
        // Proceed with plugin initialization only when the integrator intentionally wants to use it, i.e. when the `config.ckbox` exists or
        // the CKBox JavaScript library is loaded.
        if (!hasConfiguration && !isLibraryLoaded) {
            return;
        }
        editor.config.define('ckbox', {
            serviceOrigin: 'https://api.ckbox.io',
            defaultUploadCategories: null,
            ignoreDataId: false,
            language: editor.locale.uiLanguage,
            theme: DEFAULT_CKBOX_THEME_NAME,
            tokenUrl: editor.config.get('cloudServices.tokenUrl')
        });
        const cloudServices = editor.plugins.get('CloudServices');
        const cloudServicesTokenUrl = editor.config.get('cloudServices.tokenUrl');
        const ckboxTokenUrl = editor.config.get('ckbox.tokenUrl');
        if (!ckboxTokenUrl) {
            /**
			 * The {@link module:ckbox/ckboxconfig~CKBoxConfig#tokenUrl `config.ckbox.tokenUrl`} or the
			 * {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig#tokenUrl `config.cloudServices.tokenUrl`}
			 * configuration is required for the CKBox plugin.
			 *
			 * ```ts
			 * ClassicEditor.create( document.createElement( 'div' ), {
			 * 	ckbox: {
			 * 		tokenUrl: "YOUR_TOKEN_URL"
			 * 		// ...
			 * 	}
			 * 	// ...
			 * } );
			 * ```
			 *
			 * @error ckbox-plugin-missing-token-url
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('ckbox-plugin-missing-token-url', this);
        }
        if (ckboxTokenUrl == cloudServicesTokenUrl) {
            this._token = Promise.resolve(cloudServices.token);
        } else {
            this._token = cloudServices.registerTokenUrl(ckboxTokenUrl);
        }
    }
    /**
	 * Returns a token used by the CKBox plugin for communication with the CKBox service.
	 */ getToken() {
        return this._token;
    }
    /**
	 * The ID of workspace to use when uploading an image.
	 */ async getWorkspaceId() {
        const t = this.editor.t;
        const cannotAccessDefaultWorkspaceError = t('Cannot access default workspace.');
        const defaultWorkspaceId = this.editor.config.get('ckbox.defaultUploadWorkspaceId');
        const workspaceId = getWorkspaceId(await this._token, defaultWorkspaceId);
        if (workspaceId == null) {
            /**
			 * The user is not authorized to access the workspace defined in  the`ckbox.defaultUploadWorkspaceId` configuration.
			 *
			 * @error ckbox-access-default-workspace-error
			 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logError"])('ckbox-access-default-workspace-error');
            throw cannotAccessDefaultWorkspaceError;
        }
        return workspaceId;
    }
    /**
	 * Resolves a promise with an object containing a category with which the uploaded file is associated or an error code.
	 */ async getCategoryIdForFile(fileOrUrl, options) {
        const t = this.editor.t;
        const cannotFindCategoryError = t('Cannot determine a category for the uploaded file.');
        const defaultCategories = this.editor.config.get('ckbox.defaultUploadCategories');
        const allCategoriesPromise = this._getAvailableCategories(options);
        const extension = typeof fileOrUrl == 'string' ? convertMimeTypeToExtension(await getContentTypeOfUrl(fileOrUrl, options)) : getFileExtension(fileOrUrl);
        const allCategories = await allCategoriesPromise;
        // Couldn't fetch all categories. Perhaps the authorization token is invalid.
        if (!allCategories) {
            throw cannotFindCategoryError;
        }
        // If a user specifies the plugin configuration, find the first category that accepts the uploaded file.
        if (defaultCategories) {
            const userCategory = Object.keys(defaultCategories).find((category)=>{
                return defaultCategories[category].find((e)=>e.toLowerCase() == extension);
            });
            // If found, return its ID if the category exists on the server side.
            if (userCategory) {
                const serverCategory = allCategories.find((category)=>category.id === userCategory || category.name === userCategory);
                if (!serverCategory) {
                    throw cannotFindCategoryError;
                }
                return serverCategory.id;
            }
        }
        // Otherwise, find the first category that accepts the uploaded file and returns its ID.
        const category = allCategories.find((category)=>category.extensions.find((e)=>e.toLowerCase() == extension));
        if (!category) {
            throw cannotFindCategoryError;
        }
        return category.id;
    }
    /**
	 * Resolves a promise with an array containing available categories with which the uploaded file can be associated.
	 *
	 * If the API returns limited results, the method will collect all items.
	 */ async _getAvailableCategories(options) {
        const ITEMS_PER_REQUEST = 50;
        const editor = this.editor;
        const token = this._token;
        const { signal } = options;
        const serviceOrigin = editor.config.get('ckbox.serviceOrigin');
        const workspaceId = await this.getWorkspaceId();
        try {
            const result = [];
            let offset = 0;
            let remainingItems;
            do {
                const data = await fetchCategories(offset);
                result.push(...data.items);
                remainingItems = data.totalCount - (offset + ITEMS_PER_REQUEST);
                offset += ITEMS_PER_REQUEST;
            }while (remainingItems > 0)
            return result;
        } catch  {
            signal.throwIfAborted();
            /**
			 * Fetching a list of available categories with which an uploaded file can be associated failed.
			 *
			 * @error ckbox-fetch-category-http-error
			 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logError"])('ckbox-fetch-category-http-error');
            return undefined;
        }
        async function fetchCategories(offset) {
            const categoryUrl = new URL('categories', serviceOrigin);
            categoryUrl.searchParams.set('limit', String(ITEMS_PER_REQUEST));
            categoryUrl.searchParams.set('offset', String(offset));
            categoryUrl.searchParams.set('workspaceId', workspaceId);
            return sendHttpRequest({
                url: categoryUrl,
                signal,
                authorization: (await token).value
            });
        }
    }
}
/**
 * A plugin that enables file uploads in CKEditor 5 using the CKBox server–side connector.
 * See the {@glink features/file-management/ckbox CKBox file manager integration} guide to learn how to configure
 * and use this feature as well as find out more about the full integration with the file manager
 * provided by the {@link module:ckbox/ckbox~CKBox} plugin.
 *
 * Check out the {@glink features/images/image-upload/image-upload Image upload overview} guide to learn about
 * other ways to upload images into CKEditor 5.
 */ class CKBoxUploadAdapter extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            'ImageUploadEditing',
            'ImageUploadProgress',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$upload$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileRepository"],
            CKBoxEditing
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CKBoxUploadAdapter';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ async afterInit() {
        const editor = this.editor;
        const hasConfiguration = !!editor.config.get('ckbox');
        const isLibraryLoaded = !!window.CKBox;
        // Editor supports only one upload adapter. Register the CKBox upload adapter (and potentially overwrite other one) only when the
        // integrator intentionally wants to use the CKBox plugin, i.e. when the `config.ckbox` exists or the CKBox JavaScript library is
        // loaded.
        if (!hasConfiguration && !isLibraryLoaded) {
            return;
        }
        const fileRepository = editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$upload$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileRepository"]);
        const ckboxUtils = editor.plugins.get(CKBoxUtils);
        fileRepository.createUploadAdapter = (loader)=>new Adapter(loader, editor, ckboxUtils);
        const shouldInsertDataId = !editor.config.get('ckbox.ignoreDataId');
        const imageUploadEditing = editor.plugins.get('ImageUploadEditing');
        // Mark uploaded assets with the `ckboxImageId` attribute. Its value represents an ID in CKBox.
        if (shouldInsertDataId) {
            imageUploadEditing.on('uploadComplete', (evt, { imageElement, data })=>{
                editor.model.change((writer)=>{
                    writer.setAttribute('ckboxImageId', data.ckboxImageId, imageElement);
                });
            });
        }
    }
}
/**
 * Upload adapter for CKBox.
 */ class Adapter {
    /**
	 * FileLoader instance to use during the upload.
	 */ loader;
    /**
	 * CKEditor Cloud Services access token.
	 */ token;
    /**
	 * The editor instance.
	 */ editor;
    /**
	 * The abort controller for aborting asynchronous processes.
	 */ controller;
    /**
	 * The base URL where all requests should be sent.
	 */ serviceOrigin;
    /**
	 * The reference to CKBoxUtils plugin.
	 */ ckboxUtils;
    /**
	 * Creates a new adapter instance.
	 */ constructor(loader, editor, ckboxUtils){
        this.loader = loader;
        this.token = ckboxUtils.getToken();
        this.ckboxUtils = ckboxUtils;
        this.editor = editor;
        this.controller = new AbortController();
        this.serviceOrigin = editor.config.get('ckbox.serviceOrigin');
    }
    /**
	 * Starts the upload process.
	 *
	 * @see module:upload/filerepository~UploadAdapter#upload
	 */ async upload() {
        const ckboxUtils = this.ckboxUtils;
        const t = this.editor.t;
        const file = await this.loader.file;
        const category = await ckboxUtils.getCategoryIdForFile(file, {
            signal: this.controller.signal
        });
        const uploadUrl = new URL('assets', this.serviceOrigin);
        const formData = new FormData();
        uploadUrl.searchParams.set('workspaceId', await ckboxUtils.getWorkspaceId());
        formData.append('categoryId', category);
        formData.append('file', file);
        const requestConfig = {
            method: 'POST',
            url: uploadUrl,
            data: formData,
            onUploadProgress: (evt)=>{
                /* istanbul ignore else -- @preserve */ if (evt.lengthComputable) {
                    this.loader.uploadTotal = evt.total;
                    this.loader.uploaded = evt.loaded;
                }
            },
            signal: this.controller.signal,
            authorization: (await this.token).value
        };
        return sendHttpRequest(requestConfig).then(async (data)=>{
            const imageUrls = getImageUrls(data.imageUrls);
            return {
                ckboxImageId: data.id,
                default: imageUrls.imageFallbackUrl,
                sources: imageUrls.imageSources
            };
        }).catch(()=>{
            const genericError = t('Cannot upload file:') + ` ${file.name}.`;
            return Promise.reject(genericError);
        });
    }
    /**
	 * Aborts the upload process.
	 *
	 * @see module:upload/filerepository~UploadAdapter#abort
	 */ abort() {
        this.controller.abort();
    }
}
const COMMAND_FORCE_DISABLE_ID = 'NoPermission';
/**
 * The CKBox editing feature. It introduces the {@link module:ckbox/ckboxcommand~CKBoxCommand CKBox command} and
 * {@link module:ckbox/ckboxuploadadapter~CKBoxUploadAdapter CKBox upload adapter}.
 */ class CKBoxEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CKBoxEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            'LinkEditing',
            'PictureEditing',
            CKBoxUploadAdapter,
            CKBoxUtils
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        if (!this._shouldBeInitialised()) {
            return;
        }
        this._checkImagePlugins();
        // Registering the `ckbox` command makes sense only if the CKBox library is loaded, as the `ckbox` command opens the CKBox dialog.
        if (isLibraryLoaded()) {
            editor.commands.add('ckbox', new CKBoxCommand(editor));
        }
        // Promise is not handled intentionally. Errors should be displayed in console if there are so.
        isUploadPermissionGranted(editor).then((isCreateAssetAllowed)=>{
            if (!isCreateAssetAllowed) {
                this._blockImageCommands();
            }
        });
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        const editor = this.editor;
        if (!this._shouldBeInitialised()) {
            return;
        }
        // Extending the schema, registering converters and applying fixers only make sense if the configuration option to assign
        // the assets ID with the model elements is enabled.
        if (!editor.config.get('ckbox.ignoreDataId')) {
            this._initSchema();
            this._initConversion();
            this._initFixers();
        }
    }
    /**
	 * Returns true only when the integrator intentionally wants to use the plugin, i.e. when the `config.ckbox` exists or
	 * the CKBox JavaScript library is loaded.
	 */ _shouldBeInitialised() {
        const editor = this.editor;
        const hasConfiguration = !!editor.config.get('ckbox');
        return hasConfiguration || isLibraryLoaded();
    }
    /**
	 * Blocks `uploadImage` and `ckboxImageEdit` commands.
	 */ _blockImageCommands() {
        const editor = this.editor;
        const uploadImageCommand = editor.commands.get('uploadImage');
        const imageEditingCommand = editor.commands.get('ckboxImageEdit');
        if (uploadImageCommand) {
            uploadImageCommand.isAccessAllowed = false;
            uploadImageCommand.forceDisabled(COMMAND_FORCE_DISABLE_ID);
        }
        if (imageEditingCommand) {
            imageEditingCommand.forceDisabled(COMMAND_FORCE_DISABLE_ID);
        }
    }
    /**
	 * Checks if at least one image plugin is loaded.
	 */ _checkImagePlugins() {
        const editor = this.editor;
        if (!editor.plugins.has('ImageBlockEditing') && !editor.plugins.has('ImageInlineEditing')) {
            /**
			 * The CKBox feature requires one of the following plugins to be loaded to work correctly:
			 *
			 * * {@link module:image/imageblock~ImageBlock},
			 * * {@link module:image/imageinline~ImageInline},
			 * * {@link module:image/image~Image} (loads both `ImageBlock` and `ImageInline`)
			 *
			 * Please make sure your editor configuration is correct.
			 *
			 * @error ckbox-plugin-image-feature-missing
			 * @param {module:core/editor/editor~Editor} editor
			 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logError"])('ckbox-plugin-image-feature-missing', editor);
        }
    }
    /**
	 * Extends the schema to allow the `ckboxImageId` and `ckboxLinkId` attributes for links and images.
	 */ _initSchema() {
        const editor = this.editor;
        const schema = editor.model.schema;
        schema.extend('$text', {
            allowAttributes: 'ckboxLinkId'
        });
        if (schema.isRegistered('imageBlock')) {
            schema.extend('imageBlock', {
                allowAttributes: [
                    'ckboxImageId',
                    'ckboxLinkId'
                ]
            });
        }
        if (schema.isRegistered('imageInline')) {
            schema.extend('imageInline', {
                allowAttributes: [
                    'ckboxImageId',
                    'ckboxLinkId'
                ]
            });
        }
        schema.addAttributeCheck((context)=>{
            // Don't allow `ckboxLinkId` on elements which do not have `linkHref` attribute.
            if (!context.last.getAttribute('linkHref')) {
                return false;
            }
        }, 'ckboxLinkId');
    }
    /**
	 * Configures the upcast and downcast conversions for the `ckboxImageId` and `ckboxLinkId` attributes.
	 */ _initConversion() {
        const editor = this.editor;
        // Convert `ckboxLinkId` => `data-ckbox-resource-id`.
        editor.conversion.for('downcast').add((dispatcher)=>{
            // Due to custom converters for linked block images, handle the `ckboxLinkId` attribute manually.
            dispatcher.on('attribute:ckboxLinkId:imageBlock', (evt, data, conversionApi)=>{
                const { writer, mapper, consumable } = conversionApi;
                if (!consumable.consume(data.item, evt.name)) {
                    return;
                }
                const viewFigure = mapper.toViewElement(data.item);
                const linkInImage = [
                    ...viewFigure.getChildren()
                ].find((child)=>child.name === 'a');
                // No link inside an image - no conversion needed.
                if (!linkInImage) {
                    return;
                }
                if (data.item.hasAttribute('ckboxLinkId')) {
                    writer.setAttribute('data-ckbox-resource-id', data.item.getAttribute('ckboxLinkId'), linkInImage);
                } else {
                    writer.removeAttribute('data-ckbox-resource-id', linkInImage);
                }
            }, {
                priority: 'low'
            });
            dispatcher.on('attribute:ckboxLinkId', (evt, data, conversionApi)=>{
                const { writer, mapper, consumable } = conversionApi;
                if (!consumable.consume(data.item, evt.name)) {
                    return;
                }
                // Remove the previous attribute value if it was applied.
                if (data.attributeOldValue) {
                    const viewElement = createLinkElement(writer, data.attributeOldValue);
                    writer.unwrap(mapper.toViewRange(data.range), viewElement);
                }
                // Add the new attribute value if specified in a model element.
                if (data.attributeNewValue) {
                    const viewElement = createLinkElement(writer, data.attributeNewValue);
                    if (data.item.is('selection')) {
                        const viewSelection = writer.document.selection;
                        writer.wrap(viewSelection.getFirstRange(), viewElement);
                    } else {
                        writer.wrap(mapper.toViewRange(data.range), viewElement);
                    }
                }
            }, {
                priority: 'low'
            });
        });
        // Convert `data-ckbox-resource-id` => `ckboxLinkId`.
        //
        // The helper conversion does not handle all cases, so take care of the `data-ckbox-resource-id` attribute manually for images
        // and links.
        editor.conversion.for('upcast').add((dispatcher)=>{
            dispatcher.on('element:a', (evt, data, conversionApi)=>{
                const { writer, consumable } = conversionApi;
                // Upcast the `data-ckbox-resource-id` attribute only for valid link elements.
                if (!data.viewItem.getAttribute('href')) {
                    return;
                }
                const consumableAttributes = {
                    attributes: [
                        'data-ckbox-resource-id'
                    ]
                };
                if (!consumable.consume(data.viewItem, consumableAttributes)) {
                    return;
                }
                const attributeValue = data.viewItem.getAttribute('data-ckbox-resource-id');
                // Missing the `data-ckbox-resource-id` attribute.
                if (!attributeValue) {
                    return;
                }
                if (data.modelRange) {
                    // If the `<a>` element contains more than single children (e.g. a linked image), set the `ckboxLinkId` for each
                    // allowed child.
                    for (let item of data.modelRange.getItems()){
                        if (item.is('$textProxy')) {
                            item = item.textNode;
                        }
                        // Do not copy the `ckboxLinkId` attribute when wrapping an element in a block element, e.g. when
                        // auto-paragraphing.
                        if (shouldUpcastAttributeForNode(item)) {
                            writer.setAttribute('ckboxLinkId', attributeValue, item);
                        }
                    }
                } else {
                    // Otherwise, just set the `ckboxLinkId` for the model element.
                    const modelElement = data.modelCursor.nodeBefore || data.modelCursor.parent;
                    writer.setAttribute('ckboxLinkId', attributeValue, modelElement);
                }
            }, {
                priority: 'low'
            });
        });
        // Convert `ckboxImageId` => `data-ckbox-resource-id`.
        editor.conversion.for('downcast').attributeToAttribute({
            model: 'ckboxImageId',
            view: 'data-ckbox-resource-id'
        });
        // Convert `data-ckbox-resource-id` => `ckboxImageId`.
        editor.conversion.for('upcast').elementToAttribute({
            model: {
                key: 'ckboxImageId',
                value: (viewElement)=>viewElement.getAttribute('data-ckbox-resource-id')
            },
            view: {
                attributes: {
                    'data-ckbox-resource-id': /[\s\S]+/
                }
            }
        });
        const replaceImageSourceCommand = editor.commands.get('replaceImageSource');
        if (replaceImageSourceCommand) {
            this.listenTo(replaceImageSourceCommand, 'cleanupImage', (_, [writer, image])=>{
                writer.removeAttribute('ckboxImageId', image);
            });
        }
    }
    /**
	 * Registers post-fixers that add or remove the `ckboxLinkId` and `ckboxImageId` attributes.
	 */ _initFixers() {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        // Registers the post-fixer to sync the asset ID with the model elements.
        model.document.registerPostFixer(syncDataIdPostFixer(editor));
        // Registers the post-fixer to remove the `ckboxLinkId` attribute from the model selection.
        model.document.registerPostFixer(injectSelectionPostFixer(selection));
    }
}
/**
 * A post-fixer that synchronizes the asset ID with the model element.
 */ function syncDataIdPostFixer(editor) {
    return (writer)=>{
        let changed = false;
        const model = editor.model;
        const ckboxCommand = editor.commands.get('ckbox');
        // The ID from chosen assets are stored in the `CKBoxCommand#_chosenAssets`. If there is no command, it makes no sense to check
        // for changes in the model.
        if (!ckboxCommand) {
            return changed;
        }
        for (const entry of model.document.differ.getChanges()){
            if (entry.type !== 'insert' && entry.type !== 'attribute') {
                continue;
            }
            const range = entry.type === 'insert' ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"](entry.position, entry.position.getShiftedBy(entry.length)) : entry.range;
            const isLinkHrefAttributeRemoval = entry.type === 'attribute' && entry.attributeKey === 'linkHref' && entry.attributeNewValue === null;
            for (const item of range.getItems()){
                // If the `linkHref` attribute has been removed, sync the change with the `ckboxLinkId` attribute.
                if (isLinkHrefAttributeRemoval && item.hasAttribute('ckboxLinkId')) {
                    writer.removeAttribute('ckboxLinkId', item);
                    changed = true;
                    continue;
                }
                // Otherwise, the change concerns either a new model element or an attribute change. Try to find the assets for the modified
                // model element.
                const assets = findAssetsForItem(item, ckboxCommand._chosenAssets);
                for (const asset of assets){
                    const attributeName = asset.type === 'image' ? 'ckboxImageId' : 'ckboxLinkId';
                    if (asset.id === item.getAttribute(attributeName)) {
                        continue;
                    }
                    writer.setAttribute(attributeName, asset.id, item);
                    changed = true;
                }
            }
        }
        return changed;
    };
}
/**
 * A post-fixer that removes the `ckboxLinkId` from the selection if it does not represent a link anymore.
 */ function injectSelectionPostFixer(selection) {
    return (writer)=>{
        const shouldRemoveLinkIdAttribute = !selection.hasAttribute('linkHref') && selection.hasAttribute('ckboxLinkId');
        if (shouldRemoveLinkIdAttribute) {
            writer.removeSelectionAttribute('ckboxLinkId');
            return true;
        }
        return false;
    };
}
/**
 * Tries to find the asset that is associated with the model element by comparing the attributes:
 * - the image fallback URL with the `src` attribute for images,
 * - the link URL with the `href` attribute for links.
 *
 * For any model element, zero, one or more than one asset can be found (e.g. a linked image may be associated with the link asset and the
 * image asset).
 */ function findAssetsForItem(item, assets) {
    const isImageElement = item.is('element', 'imageInline') || item.is('element', 'imageBlock');
    const isLinkElement = item.hasAttribute('linkHref');
    return [
        ...assets
    ].filter((asset)=>{
        if (asset.type === 'image' && isImageElement) {
            return asset.attributes.imageFallbackUrl === item.getAttribute('src');
        }
        if (asset.type === 'link' && isLinkElement) {
            return asset.attributes.linkHref === item.getAttribute('linkHref');
        }
    });
}
/**
 * Creates view link element with the requested ID.
 */ function createLinkElement(writer, id) {
    // Priority equal 5 is needed to merge adjacent `<a>` elements together.
    const viewElement = writer.createAttributeElement('a', {
        'data-ckbox-resource-id': id
    }, {
        priority: 5
    });
    writer.setCustomProperty('link', true, viewElement);
    return viewElement;
}
/**
 * Checks if the model element may have the `ckboxLinkId` attribute.
 */ function shouldUpcastAttributeForNode(node) {
    if (node.is('$text')) {
        return true;
    }
    if (node.is('element', 'imageInline') || node.is('element', 'imageBlock')) {
        return true;
    }
    return false;
}
/**
 * Returns true if the CKBox library is loaded, false otherwise.
 */ function isLibraryLoaded() {
    return !!window.CKBox;
}
/**
 * Checks is access allowed to upload assets.
 */ async function isUploadPermissionGranted(editor) {
    const ckboxUtils = editor.plugins.get(CKBoxUtils);
    const origin = editor.config.get('ckbox.serviceOrigin');
    const url = new URL('permissions', origin);
    const { value } = await ckboxUtils.getToken();
    const response = await sendHttpRequest({
        url,
        authorization: value,
        signal: new AbortController().signal // Aborting is unnecessary.
    });
    return Object.values(response).some((category)=>category['asset:create']);
}
/**
 * The CKBox feature, a bridge between the CKEditor 5 WYSIWYG editor and the CKBox file manager and uploader.
 *
 * This is a "glue" plugin which enables:
 *
 * * {@link module:ckbox/ckboxediting~CKBoxEditing},
 * * {@link module:ckbox/ckboxui~CKBoxUI},
 *
 * See the {@glink features/file-management/ckbox CKBox integration} guide to learn how to configure and use this feature.
 *
 * Check out the {@glink features/images/image-upload/image-upload Image upload} guide to learn about other ways to upload
 * images into CKEditor 5.
 */ class CKBox extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CKBox';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            CKBoxEditing,
            CKBoxUI
        ];
    }
}
/**
 * @internal
 */ function createEditabilityChecker(allowExternalImagesEditing) {
    const checkUrl = createUrlChecker(allowExternalImagesEditing);
    return (element)=>{
        const isImageElement = element.is('element', 'imageInline') || element.is('element', 'imageBlock');
        if (!isImageElement) {
            return false;
        }
        if (element.hasAttribute('ckboxImageId')) {
            return true;
        }
        if (element.hasAttribute('src')) {
            return checkUrl(element.getAttribute('src'));
        }
        return false;
    };
}
function createUrlChecker(allowExternalImagesEditing) {
    if (Array.isArray(allowExternalImagesEditing)) {
        const urlMatchers = allowExternalImagesEditing.map(createUrlChecker);
        return (src)=>urlMatchers.some((matcher)=>matcher(src));
    }
    if (allowExternalImagesEditing == 'origin') {
        const origin = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window.location.origin;
        return (src)=>new URL(src, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document.baseURI).origin == origin;
    }
    if (typeof allowExternalImagesEditing == 'function') {
        return allowExternalImagesEditing;
    }
    if (allowExternalImagesEditing instanceof RegExp) {
        return (src)=>!!(src.match(allowExternalImagesEditing) || src.replace(/^https?:\/\//, '').match(allowExternalImagesEditing));
    }
    return ()=>false;
}
/**
 * The CKBox edit image command.
 *
 * Opens the CKBox dialog for editing the image.
 */ class CKBoxImageEditCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * The DOM element that acts as a mounting point for the CKBox Edit Image dialog.
	 */ _wrapper = null;
    /**
	 * The states of image processing in progress.
	 */ _processInProgress = new Set();
    /**
	 * Determines if the element can be edited.
	 */ _canEdit;
    /**
	 * A wrapper function to prepare mount options. Ensures that at most one preparation is in-flight.
	 */ _prepareOptions;
    /**
	* CKBox's onClose function runs before the final cleanup, potentially causing
	* page layout changes after it finishes. To address this, we use a setTimeout hack
	* to ensure that floating elements on the page maintain their correct position.
	*
	* See: https://github.com/ckeditor/ckeditor5/issues/16153.
	*/ _updateUiDelayed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["delay"])(()=>this.editor.ui.update(), 0);
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        this.value = false;
        this._canEdit = createEditabilityChecker(editor.config.get('ckbox.allowExternalImagesEditing'));
        this._prepareOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abortableDebounce"])((signal, state)=>this._prepareOptionsAbortable(signal, state));
        this._prepareListeners();
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        const editor = this.editor;
        this.value = this._getValue();
        const selectedElement = editor.model.document.selection.getSelectedElement();
        this.isEnabled = !!selectedElement && this._canEdit(selectedElement) && !this._checkIfElementIsBeingProcessed(selectedElement);
    }
    /**
	 * Opens the CKBox Image Editor dialog for editing the image.
	 */ execute() {
        if (this._getValue()) {
            return;
        }
        const wrapper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(document, 'div', {
            class: 'ck ckbox-wrapper'
        });
        this._wrapper = wrapper;
        this.value = true;
        document.body.appendChild(this._wrapper);
        const imageElement = this.editor.model.document.selection.getSelectedElement();
        const processingState = {
            element: imageElement,
            controller: new AbortController()
        };
        this._prepareOptions(processingState).then((options)=>window.CKBox.mountImageEditor(wrapper, options), (error)=>{
            const editor = this.editor;
            const t = editor.t;
            const notification = editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Notification"]);
            notification.showWarning(t('Failed to determine category of edited image.'), {
                namespace: 'ckbox'
            });
            console.error(error);
            this._handleImageEditorClose();
        });
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        this._handleImageEditorClose();
        this._prepareOptions.abort();
        this._updateUiDelayed.cancel();
        for (const state of this._processInProgress.values()){
            state.controller.abort();
        }
        super.destroy();
    }
    /**
	 * Indicates if the CKBox Image Editor dialog is already opened.
	 */ _getValue() {
        return this._wrapper !== null;
    }
    /**
	 * Creates the options object for the CKBox Image Editor dialog.
	 */ async _prepareOptionsAbortable(signal, state) {
        const editor = this.editor;
        const ckboxConfig = editor.config.get('ckbox');
        const ckboxUtils = editor.plugins.get(CKBoxUtils);
        const { element } = state;
        let imageMountOptions;
        const ckboxImageId = element.getAttribute('ckboxImageId');
        if (ckboxImageId) {
            imageMountOptions = {
                assetId: ckboxImageId
            };
        } else {
            const imageUrl = new URL(element.getAttribute('src'), document.baseURI).href;
            const uploadCategoryId = await ckboxUtils.getCategoryIdForFile(imageUrl, {
                signal
            });
            imageMountOptions = {
                imageUrl,
                uploadCategoryId
            };
        }
        return {
            ...imageMountOptions,
            imageEditing: {
                allowOverwrite: false
            },
            tokenUrl: ckboxConfig.tokenUrl,
            ...ckboxConfig.serviceOrigin && {
                serviceOrigin: ckboxConfig.serviceOrigin
            },
            onClose: ()=>this._handleImageEditorClose(),
            onSave: (asset)=>this._handleImageEditorSave(state, asset)
        };
    }
    /**
	 * Initializes event lister for an event of removing an image.
	 */ _prepareListeners() {
        // Abort editing processing when the image has been removed.
        this.listenTo(this.editor.model.document, 'change:data', ()=>{
            const processingStates = this._getProcessingStatesOfDeletedImages();
            processingStates.forEach((processingState)=>{
                processingState.controller.abort();
            });
        });
    }
    /**
	 * Gets processing states of images that have been deleted in the mean time.
	 */ _getProcessingStatesOfDeletedImages() {
        const states = [];
        for (const state of this._processInProgress.values()){
            if (state.element.root.rootName == '$graveyard') {
                states.push(state);
            }
        }
        return states;
    }
    _checkIfElementIsBeingProcessed(selectedElement) {
        for (const { element } of this._processInProgress){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"])(element, selectedElement)) {
                return true;
            }
        }
        return false;
    }
    /**
	 * Closes the CKBox Image Editor dialog.
	 */ _handleImageEditorClose() {
        if (!this._wrapper) {
            return;
        }
        this._wrapper.remove();
        this._wrapper = null;
        this.editor.editing.view.focus();
        this._updateUiDelayed();
        this.refresh();
    }
    /**
	 * Save edited image. In case server respond with "success" replace with edited image,
	 * otherwise show notification error.
	 */ _handleImageEditorSave(state, asset) {
        const t = this.editor.locale.t;
        const notification = this.editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Notification"]);
        const pendingActions = this.editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PendingActions"]);
        const action = pendingActions.add(t('Processing the edited image.'));
        this._processInProgress.add(state);
        this._showImageProcessingIndicator(state.element, asset);
        this.refresh();
        this._waitForAssetProcessed(asset.data.id, state.controller.signal).then((asset)=>{
            this._replaceImage(state.element, asset);
        }, (error)=>{
            // Remove processing indicator. It was added only to ViewElement.
            this.editor.editing.reconvertItem(state.element);
            if (state.controller.signal.aborted) {
                return;
            }
            if (!error || error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]) {
                notification.showWarning(t('Server failed to process the image.'), {
                    namespace: 'ckbox'
                });
            } else {
                console.error(error);
            }
        }).finally(()=>{
            this._processInProgress.delete(state);
            pendingActions.remove(action);
            this.refresh();
        });
    }
    /**
	 * Get asset's status on server. If server responds with "success" status then
	 * image is already proceeded and ready for saving.
	 */ async _getAssetStatusFromServer(id, signal) {
        const ckboxUtils = this.editor.plugins.get(CKBoxUtils);
        const url = new URL('assets/' + id, this.editor.config.get('ckbox.serviceOrigin'));
        const response = await sendHttpRequest({
            url,
            signal,
            authorization: (await ckboxUtils.getToken()).value
        });
        const status = response.metadata.metadataProcessingStatus;
        if (!status || status == 'queued') {
            /**
			 * Image has not been processed yet.
			 *
			 * @error ckbox-image-not-processed
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('ckbox-image-not-processed');
        }
        return {
            data: {
                ...response
            }
        };
    }
    /**
	 * Waits for an asset to be processed.
	 * It retries retrieving asset status from the server in case of failure.
	 */ async _waitForAssetProcessed(id, signal) {
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["retry"])(()=>this._getAssetStatusFromServer(id, signal), {
            signal,
            maxAttempts: 5
        });
        if (result.data.metadata.metadataProcessingStatus != 'success') {
            /**
			 * The image processing failed.
			 *
			 * @error ckbox-image-processing-failed
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('ckbox-image-processing-failed');
        }
        return result;
    }
    /**
	 * Shows processing indicator while image is processing.
	 *
	 * @param asset Data about certain asset.
	 */ _showImageProcessingIndicator(element, asset) {
        const editor = this.editor;
        editor.editing.view.change((writer)=>{
            const imageElementView = editor.editing.mapper.toViewElement(element);
            const imageUtils = this.editor.plugins.get('ImageUtils');
            const img = imageUtils.findViewImgElement(imageElementView);
            writer.removeStyle('aspect-ratio', img);
            writer.setAttribute('width', asset.data.metadata.width, img);
            writer.setAttribute('height', asset.data.metadata.height, img);
            writer.setStyle('width', `${asset.data.metadata.width}px`, img);
            writer.setStyle('height', `${asset.data.metadata.height}px`, img);
            writer.addClass('image-processing', imageElementView);
        });
    }
    /**
	 * Replace the edited image with the new one.
	 */ _replaceImage(element, asset) {
        const editor = this.editor;
        const { imageFallbackUrl, imageSources, imageWidth, imageHeight, imagePlaceholder } = prepareImageAssetAttributes(asset);
        const previousSelectionRanges = Array.from(editor.model.document.selection.getRanges());
        editor.model.change((writer)=>{
            writer.setSelection(element, 'on');
            editor.execute('insertImage', {
                imageType: element.is('element', 'imageInline') ? 'imageInline' : null,
                source: {
                    src: imageFallbackUrl,
                    sources: imageSources,
                    width: imageWidth,
                    height: imageHeight,
                    ...imagePlaceholder ? {
                        placeholder: imagePlaceholder
                    } : null,
                    ...element.hasAttribute('alt') ? {
                        alt: element.getAttribute('alt')
                    } : null
                }
            });
            const previousChildren = element.getChildren();
            element = editor.model.document.selection.getSelectedElement();
            for (const child of previousChildren){
                writer.append(writer.cloneElement(child), element);
            }
            writer.setAttribute('ckboxImageId', asset.data.id, element);
            writer.setSelection(previousSelectionRanges);
        });
    }
}
/**
 * The CKBox image edit editing plugin.
 */ class CKBoxImageEditEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CKBoxImageEditEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            CKBoxEditing,
            CKBoxUtils,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PendingActions"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Notification"],
            'ImageUtils',
            'ImageEditing'
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const { editor } = this;
        editor.commands.add('ckboxImageEdit', new CKBoxImageEditCommand(editor));
    }
}
var ckboxImageEditIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037H5.06l5.058-5.078L6.617 9.15a.696.696 0 0 0-.957-.033L1.5 13.6V2.5h15v4.354a3.478 3.478 0 0 1 1.5.049V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.147 2.147 0 0 0-2.049 1.992 2.14 2.14 0 0 0 1.28 2.096 2.13 2.13 0 0 0 2.642-3.11 2.129 2.129 0 0 0-1.873-.978ZM8.089 17.635v2.388h2.389l7.046-7.046-2.39-2.39-7.045 7.048Zm11.282-6.507a.637.637 0 0 0 .139-.692.603.603 0 0 0-.139-.205l-1.49-1.488a.63.63 0 0 0-.899 0l-1.166 1.163 2.39 2.39 1.165-1.168Z\"/></svg>";
/**
 * The UI plugin of the CKBox image edit feature.
 *
 * It registers the `'ckboxImageEdit'` UI button in the editor's {@link module:ui/componentfactory~ComponentFactory component factory}
 * that allows you to open the CKBox dialog and edit the image.
 */ class CKBoxImageEditUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CKBoxImageEditUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.ui.componentFactory.add('ckboxImageEdit', (locale)=>{
            const command = editor.commands.get('ckboxImageEdit');
            const uploadImageCommand = editor.commands.get('uploadImage');
            const view = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](locale);
            const t = locale.t;
            view.set({
                icon: ckboxImageEditIcon,
                tooltip: true
            });
            view.bind('label').to(uploadImageCommand, 'isAccessAllowed', (isAccessAllowed)=>isAccessAllowed ? t('Edit image') : t('You have no image editing permissions.'));
            view.bind('isOn').to(command, 'value', command, 'isEnabled', (value, isEnabled)=>value && isEnabled);
            view.bind('isEnabled').to(command);
            // Execute the command.
            this.listenTo(view, 'execute', ()=>{
                editor.execute('ckboxImageEdit');
                editor.editing.view.focus();
            });
            return view;
        });
    }
}
/**
 * The CKBox image edit feature.
 */ class CKBoxImageEdit extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CKBoxImageEdit';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            CKBoxImageEditEditing,
            CKBoxImageEditUI
        ];
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-ckfinder/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "CKFinder": (()=>CKFinder),
    "CKFinderEditing": (()=>CKFinderEditing),
    "CKFinderUI": (()=>CKFinderUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
;
;
;
/**
 * Introduces UI components for `CKFinder` plugin.
 *
 * The plugin introduces two UI components to the {@link module:ui/componentfactory~ComponentFactory UI component factory}:
 *
 * * the `'ckfinder'` toolbar button,
 * * the `'menuBar:ckfinder'` menu bar component, which is by default added to the `'Insert'` menu.
 *
 * It also integrates with the `insertImage` toolbar component and `menuBar:insertImage` menu component.
 */ class CKFinderUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CKFinderUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.ui.componentFactory.add('ckfinder', ()=>this._createFileToolbarButton());
        editor.ui.componentFactory.add('menuBar:ckfinder', ()=>this._createFileMenuBarButton());
        if (editor.plugins.has('ImageInsertUI')) {
            editor.plugins.get('ImageInsertUI').registerIntegration({
                name: 'assetManager',
                observable: ()=>editor.commands.get('ckfinder'),
                buttonViewCreator: ()=>this._createImageToolbarButton(),
                formViewCreator: ()=>this._createImageDropdownButton(),
                menuBarButtonViewCreator: (isOnly)=>this._createImageMenuBarButton(isOnly ? 'insertOnly' : 'insertNested')
            });
        }
    }
    /**
	 * Creates the base for various kinds of the button component provided by this feature.
	 */ _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const view = new ButtonClass(locale);
        const command = editor.commands.get('ckfinder');
        view.bind('isEnabled').to(command);
        view.on('execute', ()=>{
            editor.execute('ckfinder');
            editor.editing.view.focus();
        });
        return view;
    }
    /**
	 * Creates a simple toolbar button for files management, with an icon and a tooltip.
	 */ _createFileToolbarButton() {
        const t = this.editor.locale.t;
        const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
        button.icon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].browseFiles;
        button.label = t('Insert image or file');
        button.tooltip = true;
        return button;
    }
    /**
	 * Creates a simple toolbar button for images management, with an icon and a tooltip.
	 */ _createImageToolbarButton() {
        const t = this.editor.locale.t;
        const imageInsertUI = this.editor.plugins.get('ImageInsertUI');
        const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
        button.icon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].imageAssetManager;
        button.bind('label').to(imageInsertUI, 'isImageSelected', (isImageSelected)=>isImageSelected ? t('Replace image with file manager') : t('Insert image with file manager'));
        button.tooltip = true;
        return button;
    }
    /**
	 * Creates a button for images management for the dropdown view, with an icon, text and no tooltip.
	 */ _createImageDropdownButton() {
        const t = this.editor.locale.t;
        const imageInsertUI = this.editor.plugins.get('ImageInsertUI');
        const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
        button.icon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].imageAssetManager;
        button.withText = true;
        button.bind('label').to(imageInsertUI, 'isImageSelected', (isImageSelected)=>isImageSelected ? t('Replace with file manager') : t('Insert with file manager'));
        button.on('execute', ()=>{
            imageInsertUI.dropdownView.isOpen = false;
        });
        return button;
    }
    /**
	 * Creates a button for files management for the menu bar.
	 */ _createFileMenuBarButton() {
        const t = this.editor.locale.t;
        const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
        button.icon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].browseFiles;
        button.withText = true;
        button.label = t('File');
        return button;
    }
    /**
	 * Creates a button for images management for the menu bar.
	 */ _createImageMenuBarButton(type) {
        // Use t() stored in a variable with a different name to reuse existing translations from another package.
        const translateVariableKey = this.editor.locale.t;
        const t = this.editor.locale.t;
        const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
        button.icon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].imageAssetManager;
        button.withText = true;
        switch(type){
            case 'insertOnly':
                button.label = translateVariableKey('Image');
                break;
            case 'insertNested':
                button.label = t('With file manager');
                break;
        }
        return button;
    }
}
/**
 * The CKFinder command. It is used by the {@link module:ckfinder/ckfinderediting~CKFinderEditing CKFinder editing feature}
 * to open the CKFinder file manager to insert an image or a link to a file into the editor content.
 *
 * ```ts
 * editor.execute( 'ckfinder' );
 * ```
 *
 * **Note:** This command uses other features to perform tasks:
 * - To insert images the {@link module:image/image/insertimagecommand~InsertImageCommand 'insertImage'} command
 * from the {@link module:image/image~Image Image feature}.
 * - To insert links to files the {@link module:link/linkcommand~LinkCommand 'link'} command
 * from the {@link module:link/link~Link Link feature}.
 */ class CKFinderCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        // The CKFinder command does not affect data by itself.
        this.affectsData = false;
        // Remove default document listener to lower its priority.
        this.stopListening(this.editor.model.document, 'change');
        // Lower this command listener priority to be sure that refresh() will be called after link & image refresh.
        this.listenTo(this.editor.model.document, 'change', ()=>this.refresh(), {
            priority: 'low'
        });
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        const imageCommand = this.editor.commands.get('insertImage');
        const linkCommand = this.editor.commands.get('link');
        // The CKFinder command is enabled when one of image or link command is enabled.
        this.isEnabled = imageCommand.isEnabled || linkCommand.isEnabled;
    }
    /**
	 * @inheritDoc
	 */ execute() {
        const editor = this.editor;
        const openerMethod = this.editor.config.get('ckfinder.openerMethod') || 'modal';
        if (openerMethod != 'popup' && openerMethod != 'modal') {
            /**
			 * The `ckfinder.openerMethod` must be one of: "popup" or "modal".
			 *
			 * @error ckfinder-unknown-openermethod
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('ckfinder-unknown-openermethod', editor);
        }
        const options = this.editor.config.get('ckfinder.options') || {};
        options.chooseFiles = true;
        // Cache the user-defined onInit method
        const originalOnInit = options.onInit;
        // Pass the lang code to the CKFinder if not defined by user.
        if (!options.language) {
            options.language = editor.locale.uiLanguage;
        }
        // The onInit method allows to extend CKFinder's behavior. It is used to attach event listeners to file choosing related events.
        options.onInit = (finder)=>{
            // Call original options.onInit if it was defined by user.
            if (originalOnInit) {
                originalOnInit(finder);
            }
            finder.on('files:choose', (evt)=>{
                const files = evt.data.files.toArray();
                // Insert links
                const links = files.filter((file)=>!file.isImage());
                const images = files.filter((file)=>file.isImage());
                for (const linkFile of links){
                    editor.execute('link', linkFile.getUrl());
                }
                const imagesUrls = [];
                for (const image of images){
                    const url = image.getUrl();
                    imagesUrls.push(url ? url : finder.request('file:getProxyUrl', {
                        file: image
                    }));
                }
                if (imagesUrls.length) {
                    insertImages(editor, imagesUrls);
                }
            });
            finder.on('file:choose:resizedImage', (evt)=>{
                const resizedUrl = evt.data.resizedUrl;
                if (!resizedUrl) {
                    const notification = editor.plugins.get('Notification');
                    const t = editor.locale.t;
                    notification.showWarning(t('Could not obtain resized image URL.'), {
                        title: t('Selecting resized image failed'),
                        namespace: 'ckfinder'
                    });
                    return;
                }
                insertImages(editor, [
                    resizedUrl
                ]);
            });
        };
        window.CKFinder[openerMethod](options);
    }
}
function insertImages(editor, urls) {
    const imageCommand = editor.commands.get('insertImage');
    // Check if inserting an image is actually possible - it might be possible to only insert a link.
    if (!imageCommand.isEnabled) {
        const notification = editor.plugins.get('Notification');
        const t = editor.locale.t;
        notification.showWarning(t('Could not insert image at the current position.'), {
            title: t('Inserting image failed'),
            namespace: 'ckfinder'
        });
        return;
    }
    editor.execute('insertImage', {
        source: urls
    });
}
/**
 * The CKFinder editing feature. It introduces the {@link module:ckfinder/ckfindercommand~CKFinderCommand CKFinder command}.
 */ class CKFinderEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CKFinderEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Notification"],
            'LinkEditing'
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        if (!editor.plugins.has('ImageBlockEditing') && !editor.plugins.has('ImageInlineEditing')) {
            /**
			 * CKFinder requires at least one plugin providing support for images loaded in the editor. Please
			 * make sure either:
			 *
			 * * {@link module:image/image~Image} (which loads both types of images),
			 * * or {@link module:image/imageblock~ImageBlock},
			 * * or {@link module:image/imageinline~ImageInline}.
			 *
			 * is loaded in your editor configuration.
			 *
			 * @error ckfinder-missing-image-plugin
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('ckfinder-missing-image-plugin', editor);
        }
        editor.commands.add('ckfinder', new CKFinderCommand(editor));
    }
}
/**
 * The CKFinder feature, a bridge between the CKEditor 5 WYSIWYG editor and the
 * [CKFinder](https://ckeditor.com/ckfinder) file manager and uploader.
 *
 * This is a "glue" plugin which enables:
 *
 * * {@link module:ckfinder/ckfinderediting~CKFinderEditing},
 * * {@link module:ckfinder/ckfinderui~CKFinderUI},
 * * {@link module:adapter-ckfinder/uploadadapter~CKFinderUploadAdapter}.
 *
 * See the {@glink features/file-management/ckfinder "CKFinder integration" guide} to learn how to configure
 * and use this feature.
 *
 * Check out the {@glink features/images/image-upload/image-upload comprehensive "Image upload" guide} to learn about
 * other ways to upload images into CKEditor 5.
 */ class CKFinder extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CKFinder';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            'Link',
            'CKFinderUploadAdapter',
            CKFinderEditing,
            CKFinderUI
        ];
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-clipboard/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Clipboard": (()=>Clipboard),
    "ClipboardMarkersUtils": (()=>ClipboardMarkersUtils),
    "ClipboardPipeline": (()=>ClipboardPipeline),
    "DragDrop": (()=>DragDrop),
    "DragDropBlockToolbar": (()=>DragDropBlockToolbar),
    "DragDropTarget": (()=>DragDropTarget),
    "PastePlainText": (()=>PastePlainText),
    "plainTextToHtml": (()=>plainTextToHtml),
    "viewToPlainText": (()=>viewToPlainText)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-widget/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$mapValues$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__mapValues$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/mapValues.js [app-client] (ecmascript) <export default as mapValues>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/throttle.js [app-client] (ecmascript) <export default as throttle>");
;
;
;
;
;
;
/**
 * Clipboard events observer.
 *
 * Fires the following events:
 *
 * * {@link module:engine/view/document~Document#event:clipboardInput},
 * * {@link module:engine/view/document~Document#event:paste},
 * * {@link module:engine/view/document~Document#event:copy},
 * * {@link module:engine/view/document~Document#event:cut},
 * * {@link module:engine/view/document~Document#event:drop},
 * * {@link module:engine/view/document~Document#event:dragover},
 * * {@link module:engine/view/document~Document#event:dragging},
 * * {@link module:engine/view/document~Document#event:dragstart},
 * * {@link module:engine/view/document~Document#event:dragend},
 * * {@link module:engine/view/document~Document#event:dragenter},
 * * {@link module:engine/view/document~Document#event:dragleave}.
 *
 * **Note**: This observer is not available by default (ckeditor5-engine does not add it on its own).
 * To make it available, it needs to be added to {@link module:engine/view/document~Document} by using
 * the {@link module:engine/view/view~View#addObserver `View#addObserver()`} method. Alternatively, you can load the
 * {@link module:clipboard/clipboard~Clipboard} plugin which adds this observer automatically (because it uses it).
 */ class ClipboardObserver extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DomEventObserver"] {
    domEventType = [
        'paste',
        'copy',
        'cut',
        'drop',
        'dragover',
        'dragstart',
        'dragend',
        'dragenter',
        'dragleave'
    ];
    constructor(view){
        super(view);
        const viewDocument = this.document;
        this.listenTo(viewDocument, 'paste', handleInput('clipboardInput'), {
            priority: 'low'
        });
        this.listenTo(viewDocument, 'drop', handleInput('clipboardInput'), {
            priority: 'low'
        });
        this.listenTo(viewDocument, 'dragover', handleInput('dragging'), {
            priority: 'low'
        });
        function handleInput(type) {
            return (evt, data)=>{
                data.preventDefault();
                const targetRanges = data.dropRange ? [
                    data.dropRange
                ] : null;
                const eventInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventInfo"](viewDocument, type);
                viewDocument.fire(eventInfo, {
                    dataTransfer: data.dataTransfer,
                    method: evt.name,
                    targetRanges,
                    target: data.target,
                    domEvent: data.domEvent
                });
                // If CKEditor handled the input, do not bubble the original event any further.
                // This helps external integrations recognize that fact and act accordingly.
                // https://github.com/ckeditor/ckeditor5-upload/issues/92
                if (eventInfo.stop.called) {
                    data.stopPropagation();
                }
            };
        }
    }
    onDomEvent(domEvent) {
        const nativeDataTransfer = 'clipboardData' in domEvent ? domEvent.clipboardData : domEvent.dataTransfer;
        const cacheFiles = domEvent.type == 'drop' || domEvent.type == 'paste';
        const evtData = {
            dataTransfer: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTransfer"](nativeDataTransfer, {
                cacheFiles
            })
        };
        if (domEvent.type == 'drop' || domEvent.type == 'dragover') {
            const domRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRangeFromMouseEvent"])(domEvent);
            evtData.dropRange = domRange && this.view.domConverter.domRangeToView(domRange);
        }
        this.fire(domEvent.type, domEvent, evtData);
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module clipboard/utils/plaintexttohtml
 */ /**
 * Converts plain text to its HTML-ized version.
 *
 * @param text The plain text to convert.
 * @returns HTML generated from the plain text.
 */ function plainTextToHtml(text) {
    text = text // Encode &.
    .replace(/&/g, '&amp;') // Encode <>.
    .replace(/</g, '&lt;').replace(/>/g, '&gt;') // Creates a paragraph for each double line break.
    .replace(/\r?\n\r?\n/g, '</p><p>') // Creates a line break for each single line break.
    .replace(/\r?\n/g, '<br>') // Replace tabs with four spaces.
    .replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;') // Preserve trailing spaces (only the first and last one – the rest is handled below).
    .replace(/^\s/, '&nbsp;').replace(/\s$/, '&nbsp;') // Preserve other subsequent spaces now.
    .replace(/\s\s/g, ' &nbsp;');
    if (text.includes('</p><p>') || text.includes('<br>')) {
        // If we created paragraphs above, add the trailing ones.
        text = `<p>${text}</p>`;
    }
    // TODO:
    // * What about '\nfoo' vs ' foo'?
    return text;
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module clipboard/utils/normalizeclipboarddata
 */ /**
 * Removes some popular browser quirks out of the clipboard data (HTML).
 * Removes all HTML comments. These are considered an internal thing and it makes little sense if they leak into the editor data.
 *
 * @param data The HTML data to normalize.
 * @returns Normalized HTML.
 */ function normalizeClipboardData(data) {
    return data.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (fullMatch, spaces)=>{
        // Handle the most popular and problematic case when even a single space becomes an nbsp;.
        // Decode those to normal spaces. Read more in https://github.com/ckeditor/ckeditor5-clipboard/issues/2.
        if (spaces.length == 1) {
            return ' ';
        }
        return spaces;
    }) // Remove all HTML comments.
    .replace(/<!--[\s\S]*?-->/g, '');
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module clipboard/utils/viewtoplaintext
 */ // Elements which should not have empty-line padding.
// Most `view.ContainerElement` want to be separate by new-line, but some are creating one structure
// together (like `<li>`) so it is better to separate them by only one "\n".
const smallPaddingElements = [
    'figcaption',
    'li'
];
const listElements = [
    'ol',
    'ul'
];
/**
 * Converts {@link module:engine/view/item~Item view item} and all of its children to plain text.
 *
 * @param converter The converter instance.
 * @param viewItem View item to convert.
 * @returns Plain text representation of `viewItem`.
 */ function viewToPlainText(converter, viewItem) {
    if (viewItem.is('$text') || viewItem.is('$textProxy')) {
        return viewItem.data;
    }
    if (viewItem.is('element', 'img') && viewItem.hasAttribute('alt')) {
        return viewItem.getAttribute('alt');
    }
    if (viewItem.is('element', 'br')) {
        return '\n'; // Convert soft breaks to single line break (#8045).
    }
    /**
	 * Item is a document fragment, attribute element or container element. It doesn't
	 * have it's own text value, so we need to convert its children elements.
	 */ let text = '';
    let prev = null;
    for (const child of viewItem.getChildren()){
        text += newLinePadding(child, prev) + viewToPlainText(converter, child);
        prev = child;
    }
    // If item is a raw element, the only way to get its content is to render it and read the text directly from DOM.
    if (viewItem.is('rawElement')) {
        const tempElement = document.createElement('div');
        viewItem.render(tempElement, converter);
        text += domElementToPlainText(tempElement);
    }
    return text;
}
/**
 * Recursively converts DOM element and all of its children to plain text.
 */ function domElementToPlainText(element) {
    let text = '';
    if (element.nodeType === Node.TEXT_NODE) {
        return element.textContent;
    } else if (element.tagName === 'BR') {
        return '\n';
    }
    for (const child of element.childNodes){
        text += domElementToPlainText(child);
    }
    return text;
}
/**
 * Returns new line padding to prefix the given elements with.
 */ function newLinePadding(element, previous) {
    if (!previous) {
        // Don't add padding to first elements in a level.
        return '';
    }
    if (element.is('element', 'li') && !element.isEmpty && element.getChild(0).is('containerElement')) {
        // Separate document list items with empty lines.
        return '\n\n';
    }
    if (listElements.includes(element.name) && listElements.includes(previous.name)) {
        /**
		 * Because `<ul>` and `<ol>` are AttributeElements, two consecutive lists will not have any padding between
		 * them (see the `if` statement below). To fix this, we need to make an exception for this case.
		 */ return '\n\n';
    }
    if (!element.is('containerElement') && !previous.is('containerElement')) {
        // Don't add padding between non-container elements.
        return '';
    }
    if (smallPaddingElements.includes(element.name) || smallPaddingElements.includes(previous.name)) {
        // Add small padding between selected container elements.
        return '\n';
    }
    // Do not add padding around the elements that won't be rendered.
    if (element.is('element') && element.getCustomProperty('dataPipeline:transparentRendering') || previous.is('element') && previous.getCustomProperty('dataPipeline:transparentRendering')) {
        return '';
    }
    // Add empty lines between container elements.
    return '\n\n';
}
/**
 * Part of the clipboard logic. Responsible for collecting markers from selected fragments
 * and restoring them with proper positions in pasted elements.
 *
 * @internal
 */ class ClipboardMarkersUtils extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * Map of marker names that can be copied.
	 *
	 * @internal
	 */ _markersToCopy = new Map();
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ClipboardMarkersUtils';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * Registers marker name as copyable in clipboard pipeline.
	 *
	 * @param markerName Name of marker that can be copied.
	 * @param config Configuration that describes what can be performed on specified marker.
	 * @internal
	 */ _registerMarkerToCopy(markerName, config) {
        this._markersToCopy.set(markerName, config);
    }
    /**
	 * Performs copy markers on provided selection and paste it to fragment returned from `getCopiedFragment`.
	 *
	 * 	1. Picks all markers in provided selection.
	 * 	2. Inserts fake markers to document.
	 * 	3. Gets copied selection fragment from document.
	 * 	4. Removes fake elements from fragment and document.
	 * 	5. Inserts markers in the place of removed fake markers.
	 *
	 * Due to selection modification, when inserting items, `getCopiedFragment` must *always* operate on `writer.model.document.selection'.
	 * Do not use any other custom selection object within callback, as this will lead to out-of-bounds exceptions in rare scenarios.
	 *
	 * @param action Type of clipboard action.
	 * @param writer An instance of the model writer.
	 * @param selection Selection to be checked.
	 * @param getCopiedFragment	Callback that performs copy of selection and returns it as fragment.
	 * @internal
	 */ _copySelectedFragmentWithMarkers(action, selection, getCopiedFragment = (writer)=>writer.model.getSelectedContent(writer.model.document.selection)) {
        return this.editor.model.change((writer)=>{
            const oldSelection = writer.model.document.selection;
            // In some scenarios, such like in drag & drop, passed `selection` parameter is not actually
            // the same `selection` as the `writer.model.document.selection` which means that `_insertFakeMarkersToSelection`
            // is not affecting passed `selection` `start` and `end` positions but rather modifies `writer.model.document.selection`.
            //
            // It is critical due to fact that when we have selection that starts [ 0, 0 ] and ends at [ 1, 0 ]
            // and after inserting fake marker it will point to such marker instead of new widget position at start: [ 1, 0 ] end: [2, 0 ].
            // `writer.insert` modifies only original `writer.model.document.selection`.
            writer.setSelection(selection);
            const sourceSelectionInsertedMarkers = this._insertFakeMarkersIntoSelection(writer, writer.model.document.selection, action);
            const fragment = getCopiedFragment(writer);
            const fakeMarkersRangesInsideRange = this._removeFakeMarkersInsideElement(writer, fragment);
            // <fake-marker> [Foo] Bar</fake-marker>
            //      ^                    ^
            // In `_insertFakeMarkersIntoSelection` call we inserted fake marker just before first element.
            // The problem is that the first element can be start position of selection so insertion fake-marker
            // before such element shifts selection (so selection that was at [0, 0] now is at [0, 1]).
            // It means that inserted fake-marker is no longer present inside such selection and is orphaned.
            // This function checks special case of such problem. Markers that are orphaned at the start position
            // and end position in the same time. Basically it means that they overlaps whole element.
            for (const [markerName, elements] of Object.entries(sourceSelectionInsertedMarkers)){
                fakeMarkersRangesInsideRange[markerName] ||= writer.createRangeIn(fragment);
                for (const element of elements){
                    writer.remove(element);
                }
            }
            fragment.markers.clear();
            for (const [markerName, range] of Object.entries(fakeMarkersRangesInsideRange)){
                fragment.markers.set(markerName, range);
            }
            // Revert back selection to previous one.
            writer.setSelection(oldSelection);
            return fragment;
        });
    }
    /**
	 * Performs paste of markers on already pasted element.
	 *
	 * 	1. Inserts fake markers that are present in fragment element (such fragment will be processed in `getPastedDocumentElement`).
	 * 	2. Calls `getPastedDocumentElement` and gets element that is inserted into root model.
	 * 	3. Removes all fake markers present in transformed element.
	 * 	4. Inserts new markers with removed fake markers ranges into pasted fragment.
	 *
	 * There are multiple edge cases that have to be considered before calling this function:
	 *
	 * 	* `markers` are inserted into the same element that must be later transformed inside `getPastedDocumentElement`.
	 * 	* Fake marker elements inside `getPastedDocumentElement` can be cloned, but their ranges cannot overlap.
	 * 	* If `duplicateOnPaste` is `true` in marker config then associated marker ID is regenerated before pasting.
	 *
	 * @param action Type of clipboard action.
	 * @param markers Object that maps marker name to corresponding range.
	 * @param getPastedDocumentElement Getter used to get target markers element.
	 * @internal
	 */ _pasteMarkersIntoTransformedElement(markers, getPastedDocumentElement) {
        const pasteMarkers = this._getPasteMarkersFromRangeMap(markers);
        return this.editor.model.change((writer)=>{
            // Inserts fake markers into source fragment / element that is later transformed inside `getPastedDocumentElement`.
            const sourceFragmentFakeMarkers = this._insertFakeMarkersElements(writer, pasteMarkers);
            // Modifies document fragment (for example, cloning table cells) and then inserts it into the document.
            const transformedElement = getPastedDocumentElement(writer);
            // Removes markers in pasted and transformed fragment in root document.
            const removedFakeMarkers = this._removeFakeMarkersInsideElement(writer, transformedElement);
            // Cleans up fake markers inserted into source fragment (that one before transformation which is not pasted).
            for (const element of Object.values(sourceFragmentFakeMarkers).flat()){
                writer.remove(element);
            }
            // Inserts to root document fake markers.
            for (const [markerName, range] of Object.entries(removedFakeMarkers)){
                if (!writer.model.markers.has(markerName)) {
                    writer.addMarker(markerName, {
                        usingOperation: true,
                        affectsData: true,
                        range
                    });
                }
            }
            return transformedElement;
        });
    }
    /**
	 * Pastes document fragment with markers to document.
	 * If `duplicateOnPaste` is `true` in marker config then associated markers IDs
	 * are regenerated before pasting to avoid markers duplications in content.
	 *
	 * @param fragment Document fragment that should contain already processed by pipeline markers.
	 * @internal
	 */ _pasteFragmentWithMarkers(fragment) {
        const pasteMarkers = this._getPasteMarkersFromRangeMap(fragment.markers);
        fragment.markers.clear();
        for (const copyableMarker of pasteMarkers){
            fragment.markers.set(copyableMarker.name, copyableMarker.range);
        }
        return this.editor.model.insertContent(fragment);
    }
    /**
	 * In some situations we have to perform copy on selected fragment with certain markers. This function allows to temporarily bypass
	 * restrictions on markers that we want to copy.
	 *
	 * This function executes `executor()` callback. For the duration of the callback, if the clipboard pipeline is used to copy
	 * content, markers with the specified name will be copied to the clipboard as well.
	 *
	 * @param markerName Which markers should be copied.
	 * @param executor Callback executed.
	 * @param config Optional configuration flags used to copy (such like partial copy flag).
	 * @internal
	 */ _forceMarkersCopy(markerName, executor, config = {
        allowedActions: 'all',
        copyPartiallySelected: true,
        duplicateOnPaste: true
    }) {
        const before = this._markersToCopy.get(markerName);
        this._markersToCopy.set(markerName, config);
        executor();
        if (before) {
            this._markersToCopy.set(markerName, before);
        } else {
            this._markersToCopy.delete(markerName);
        }
    }
    /**
	 * Checks if marker can be copied.
	 *
	 * @param markerName Name of checked marker.
	 * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
	 * @internal
	 */ _isMarkerCopyable(markerName, action) {
        const config = this._getMarkerClipboardConfig(markerName);
        if (!config) {
            return false;
        }
        // If there is no action provided then only presence of marker is checked.
        if (!action) {
            return true;
        }
        const { allowedActions } = config;
        return allowedActions === 'all' || allowedActions.includes(action);
    }
    /**
	 * Checks if marker has any clipboard copy behavior configuration.
	 *
	 * @param markerName Name of checked marker.
	 */ _hasMarkerConfiguration(markerName) {
        return !!this._getMarkerClipboardConfig(markerName);
    }
    /**
	 * Returns marker's configuration flags passed during registration.
	 *
	 * @param markerName Name of marker that should be returned.
	 * @internal
	 */ _getMarkerClipboardConfig(markerName) {
        const [markerNamePrefix] = markerName.split(':');
        return this._markersToCopy.get(markerNamePrefix) || null;
    }
    /**
	 * First step of copying markers. It looks for markers intersecting with given selection and inserts `$marker` elements
	 * at positions where document markers start or end. This way `$marker` elements can be easily copied together with
	 * the rest of the content of the selection.
	 *
	 * @param writer An instance of the model writer.
	 * @param selection Selection to be checked.
	 * @param action Type of clipboard action.
	 */ _insertFakeMarkersIntoSelection(writer, selection, action) {
        const copyableMarkers = this._getCopyableMarkersFromSelection(writer, selection, action);
        return this._insertFakeMarkersElements(writer, copyableMarkers);
    }
    /**
	 * Returns array of markers that can be copied in specified selection.
	 *
	 * If marker cannot be copied partially (according to `copyPartiallySelected` configuration flag) and
	 * is not present entirely in any selection range then it will be skipped.
	 *
	 * @param writer An instance of the model writer.
	 * @param selection  Selection which will be checked.
	 * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
	 */ _getCopyableMarkersFromSelection(writer, selection, action) {
        const selectionRanges = Array.from(selection.getRanges());
        // Picks all markers in provided ranges. Ensures that there are no duplications if
        // there are multiple ranges that intersects with the same marker.
        const markersInRanges = new Set(selectionRanges.flatMap((selectionRange)=>Array.from(writer.model.markers.getMarkersIntersectingRange(selectionRange))));
        const isSelectionMarkerCopyable = (marker)=>{
            // Check if marker exists in configuration and provided action can be performed on it.
            const isCopyable = this._isMarkerCopyable(marker.name, action);
            if (!isCopyable) {
                return false;
            }
            // Checks if configuration disallows to copy marker only if part of its content is selected.
            //
            // Example:
            // 	<marker-a> Hello [ World ] </marker-a>
            //						^ selection
            //
            // In this scenario `marker-a` won't be copied because selection doesn't overlap its content entirely.
            const { copyPartiallySelected } = this._getMarkerClipboardConfig(marker.name);
            if (!copyPartiallySelected) {
                const markerRange = marker.getRange();
                return selectionRanges.some((selectionRange)=>selectionRange.containsRange(markerRange, true));
            }
            return true;
        };
        return Array.from(markersInRanges).filter(isSelectionMarkerCopyable).map((copyableMarker)=>{
            // During `dragstart` event original marker is still present in tree.
            // It is removed after the clipboard drop event, so none of the copied markers are inserted at the end.
            // It happens because there already markers with specified `marker.name` when clipboard is trying to insert data
            // and it aborts inserting.
            const name = action === 'dragstart' ? this._getUniqueMarkerName(copyableMarker.name) : copyableMarker.name;
            return {
                name,
                range: copyableMarker.getRange()
            };
        });
    }
    /**
	 * Picks all markers from markers map that can be pasted.
	 * If `duplicateOnPaste` is `true`, it regenerates their IDs to ensure uniqueness.
	 * If marker is not registered, it will be kept in the array anyway.
	 *
	 * @param markers Object that maps marker name to corresponding range.
	 * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
	 */ _getPasteMarkersFromRangeMap(markers, action = null) {
        const { model } = this.editor;
        const entries = markers instanceof Map ? Array.from(markers.entries()) : Object.entries(markers);
        return entries.flatMap(([markerName, range])=>{
            if (!this._hasMarkerConfiguration(markerName)) {
                return [
                    {
                        name: markerName,
                        range
                    }
                ];
            }
            if (this._isMarkerCopyable(markerName, action)) {
                const copyMarkerConfig = this._getMarkerClipboardConfig(markerName);
                const isInGraveyard = model.markers.has(markerName) && model.markers.get(markerName).getRange().root.rootName === '$graveyard';
                if (copyMarkerConfig.duplicateOnPaste || isInGraveyard) {
                    markerName = this._getUniqueMarkerName(markerName);
                }
                return [
                    {
                        name: markerName,
                        range
                    }
                ];
            }
            return [];
        });
    }
    /**
	 * Inserts specified array of fake markers elements to document and assigns them `type` and `name` attributes.
	 * Fake markers elements are used to calculate position of markers on pasted fragment that were transformed during
	 * steps between copy and paste.
	 *
	 * @param writer An instance of the model writer.
	 * @param markers Array of markers that will be inserted.
	 */ _insertFakeMarkersElements(writer, markers) {
        const mappedMarkers = {};
        const sortedMarkers = markers.flatMap((marker)=>{
            const { start, end } = marker.range;
            return [
                {
                    position: start,
                    marker,
                    type: 'start'
                },
                {
                    position: end,
                    marker,
                    type: 'end'
                }
            ];
        }) // Markers position is sorted backwards to ensure that the insertion of fake markers will not change
        // the position of the next markers.
        .sort(({ position: posA }, { position: posB })=>posA.isBefore(posB) ? 1 : -1);
        for (const { position, marker, type } of sortedMarkers){
            const fakeMarker = writer.createElement('$marker', {
                'data-name': marker.name,
                'data-type': type
            });
            if (!mappedMarkers[marker.name]) {
                mappedMarkers[marker.name] = [];
            }
            mappedMarkers[marker.name].push(fakeMarker);
            writer.insert(fakeMarker, position);
        }
        return mappedMarkers;
    }
    /**
	 * Removes all `$marker` elements from the given document fragment.
	 *
	 * Returns an object where keys are marker names, and values are ranges corresponding to positions
	 * where `$marker` elements were inserted.
	 *
	 * If the document fragment had only one `$marker` element for given marker (start or end) the other boundary is set automatically
	 * (to the end or start of the document fragment, respectively).
	 *
	 * @param writer An instance of the model writer.
	 * @param rootElement The element to be checked.
	 */ _removeFakeMarkersInsideElement(writer, rootElement) {
        const fakeMarkersElements = this._getAllFakeMarkersFromElement(writer, rootElement);
        const fakeMarkersRanges = fakeMarkersElements.reduce((acc, fakeMarker)=>{
            const position = fakeMarker.markerElement && writer.createPositionBefore(fakeMarker.markerElement);
            let prevFakeMarker = acc[fakeMarker.name];
            // Handle scenario when tables clone cells with the same fake node. Example:
            //
            // <cell><fake-marker-a></cell> <cell><fake-marker-a></cell> <cell><fake-marker-a></cell>
            //                                          ^ cloned                    ^ cloned
            //
            // The easiest way to bypass this issue is to rename already existing in map nodes and
            // set them new unique name.
            let skipAssign = false;
            if (prevFakeMarker && prevFakeMarker.start && prevFakeMarker.end) {
                const config = this._getMarkerClipboardConfig(fakeMarker.name);
                if (config.duplicateOnPaste) {
                    acc[this._getUniqueMarkerName(fakeMarker.name)] = acc[fakeMarker.name];
                } else {
                    skipAssign = true;
                }
                prevFakeMarker = null;
            }
            if (!skipAssign) {
                acc[fakeMarker.name] = {
                    ...prevFakeMarker,
                    [fakeMarker.type]: position
                };
            }
            if (fakeMarker.markerElement) {
                writer.remove(fakeMarker.markerElement);
            }
            return acc;
        }, {});
        // We cannot construct ranges directly in previous reduce because element ranges can overlap.
        // In other words lets assume we have such scenario:
        // <fake-marker-start /> <paragraph /> <fake-marker-2-start /> <fake-marker-end /> <fake-marker-2-end />
        //
        // We have to remove `fake-marker-start` firstly and then remove `fake-marker-2-start`.
        // Removal of `fake-marker-2-start` affects `fake-marker-end` position so we cannot create
        // connection between `fake-marker-start` and `fake-marker-end` without iterating whole set firstly.
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$mapValues$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__mapValues$3e$__["mapValues"])(fakeMarkersRanges, (range)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"](range.start || writer.createPositionFromPath(rootElement, [
                0
            ]), range.end || writer.createPositionAt(rootElement, 'end')));
    }
    /**
	 * Returns array that contains list of fake markers with corresponding `$marker` elements.
	 *
	 * For each marker, there can be two `$marker` elements or only one (if the document fragment contained
	 * only the beginning or only the end of a marker).
	 *
	 * @param writer An instance of the model writer.
	 * @param rootElement The element to be checked.
	 */ _getAllFakeMarkersFromElement(writer, rootElement) {
        const foundFakeMarkers = Array.from(writer.createRangeIn(rootElement)).flatMap(({ item })=>{
            if (!item.is('element', '$marker')) {
                return [];
            }
            const name = item.getAttribute('data-name');
            const type = item.getAttribute('data-type');
            return [
                {
                    markerElement: item,
                    name,
                    type
                }
            ];
        });
        const prependFakeMarkers = [];
        const appendFakeMarkers = [];
        for (const fakeMarker of foundFakeMarkers){
            if (fakeMarker.type === 'end') {
                // <fake-marker> [ phrase</fake-marker> phrase ]
                //   ^
                // Handle case when marker is just before start of selection.
                // Only end marker is inside selection.
                const hasMatchingStartMarker = foundFakeMarkers.some((otherFakeMarker)=>otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === 'start');
                if (!hasMatchingStartMarker) {
                    prependFakeMarkers.push({
                        markerElement: null,
                        name: fakeMarker.name,
                        type: 'start'
                    });
                }
            }
            if (fakeMarker.type === 'start') {
                // [<fake-marker>phrase]</fake-marker>
                //                           ^
                // Handle case when fake marker is after selection.
                // Only start marker is inside selection.
                const hasMatchingEndMarker = foundFakeMarkers.some((otherFakeMarker)=>otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === 'end');
                if (!hasMatchingEndMarker) {
                    appendFakeMarkers.unshift({
                        markerElement: null,
                        name: fakeMarker.name,
                        type: 'end'
                    });
                }
            }
        }
        return [
            ...prependFakeMarkers,
            ...foundFakeMarkers,
            ...appendFakeMarkers
        ];
    }
    /**
	 * When copy of markers occurs we have to make sure that pasted markers have different names
	 * than source markers. This functions helps with assigning unique part to marker name to
	 * prevent duplicated markers error.
	 *
	 * @param name Name of marker
	 */ _getUniqueMarkerName(name) {
        const parts = name.split(':');
        const newId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])().substring(1, 6);
        // It looks like the marker already is UID marker so in this scenario just swap
        // last part of marker name and assign new UID.
        //
        // example: comment:{ threadId }:{ id } => comment:{ threadId }:{ newId }
        if (parts.length === 3) {
            return `${parts.slice(0, 2).join(':')}:${newId}`;
        }
        // Assign new segment to marker name with id.
        //
        // example: comment => comment:{ newId }
        return `${parts.join(':')}:${newId}`;
    }
}
// Input pipeline events overview:
//
//              ┌──────────────────────┐          ┌──────────────────────┐
//              │     view.Document    │          │     view.Document    │
//              │         paste        │          │         drop         │
//              └───────────┬──────────┘          └───────────┬──────────┘
//                          │                                 │
//                          └────────────────┌────────────────┘
//                                           │
//                                 ┌─────────V────────┐
//                                 │   view.Document  │   Retrieves text/html or text/plain from data.dataTransfer
//                                 │  clipboardInput  │   and processes it to view.DocumentFragment.
//                                 └─────────┬────────┘
//                                           │
//                               ┌───────────V───────────┐
//                               │   ClipboardPipeline   │   Converts view.DocumentFragment to model.DocumentFragment.
//                               │  inputTransformation  │
//                               └───────────┬───────────┘
//                                           │
//                                ┌──────────V──────────┐
//                                │  ClipboardPipeline  │   Calls model.insertContent().
//                                │   contentInsertion  │
//                                └─────────────────────┘
//
//
// Output pipeline events overview:
//
//              ┌──────────────────────┐          ┌──────────────────────┐
//              │     view.Document    │          │     view.Document    │   Retrieves the selected model.DocumentFragment
//              │         copy         │          │          cut         │   and fires the `outputTransformation` event.
//              └───────────┬──────────┘          └───────────┬──────────┘
//                          │                                 │
//                          └────────────────┌────────────────┘
//                                           │
//                               ┌───────────V───────────┐
//                               │   ClipboardPipeline   │   Processes model.DocumentFragment and converts it to
//                               │  outputTransformation │   view.DocumentFragment.
//                               └───────────┬───────────┘
//                                           │
//                                 ┌─────────V────────┐
//                                 │   view.Document  │   Processes view.DocumentFragment to text/html and text/plain
//                                 │  clipboardOutput │   and stores the results in data.dataTransfer.
//                                 └──────────────────┘
//
/**
 * The clipboard pipeline feature. It is responsible for intercepting the `paste` and `drop` events and
 * passing the pasted content through a series of events in order to insert it into the editor's content.
 * It also handles the `cut` and `copy` events to fill the native clipboard with the serialized editor's data.
 *
 * # Input pipeline
 *
 * The behavior of the default handlers (all at a `low` priority):
 *
 * ## Event: `paste` or `drop`
 *
 * 1. Translates the event data.
 * 2. Fires the {@link module:engine/view/document~Document#event:clipboardInput `view.Document#clipboardInput`} event.
 *
 * ## Event: `view.Document#clipboardInput`
 *
 * 1. If the `data.content` event field is already set (by some listener on a higher priority), it takes this content and fires the event
 *    from the last point.
 * 2. Otherwise, it retrieves `text/html` or `text/plain` from `data.dataTransfer`.
 * 3. Normalizes the raw data by applying simple filters on string data.
 * 4. Processes the raw data to {@link module:engine/view/documentfragment~DocumentFragment `view.DocumentFragment`} with the
 *    {@link module:engine/controller/datacontroller~DataController#htmlProcessor `DataController#htmlProcessor`}.
 * 5. Fires the {@link module:clipboard/clipboardpipeline~ClipboardPipeline#event:inputTransformation
 *   `ClipboardPipeline#inputTransformation`} event with the view document fragment in the `data.content` event field.
 *
 * ## Event: `ClipboardPipeline#inputTransformation`
 *
 * 1. Converts {@link module:engine/view/documentfragment~DocumentFragment `view.DocumentFragment`} from the `data.content` field to
 *    {@link module:engine/model/documentfragment~DocumentFragment `model.DocumentFragment`}.
 * 2. Fires the {@link module:clipboard/clipboardpipeline~ClipboardPipeline#event:contentInsertion `ClipboardPipeline#contentInsertion`}
 *    event with the model document fragment in the `data.content` event field.
 *    **Note**: The `ClipboardPipeline#contentInsertion` event is fired within a model change block to allow other handlers
 *    to run in the same block without post-fixers called in between (i.e., the selection post-fixer).
 *
 * ## Event: `ClipboardPipeline#contentInsertion`
 *
 * 1. Calls {@link module:engine/model/model~Model#insertContent `model.insertContent()`} to insert `data.content`
 *    at the current selection position.
 *
 * # Output pipeline
 *
 * The behavior of the default handlers (all at a `low` priority):
 *
 * ## Event: `copy`, `cut` or `dragstart`
 *
 * 1. Retrieves the selected {@link module:engine/model/documentfragment~DocumentFragment `model.DocumentFragment`} by calling
 *    {@link module:engine/model/model~Model#getSelectedContent `model#getSelectedContent()`}.
 * 2. Converts the model document fragment to {@link module:engine/view/documentfragment~DocumentFragment `view.DocumentFragment`}.
 * 3. Fires the {@link module:engine/view/document~Document#event:clipboardOutput `view.Document#clipboardOutput`} event
 *    with the view document fragment in the `data.content` event field.
 *
 * ## Event: `view.Document#clipboardOutput`
 *
 * 1. Processes `data.content` to HTML and plain text with the
 *    {@link module:engine/controller/datacontroller~DataController#htmlProcessor `DataController#htmlProcessor`}.
 * 2. Updates the `data.dataTransfer` data for `text/html` and `text/plain` with the processed data.
 * 3. For the `cut` method, calls {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}
 *    on the current selection.
 *
 * Read more about the clipboard integration in the {@glink framework/deep-dive/clipboard clipboard deep-dive} guide.
 */ class ClipboardPipeline extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ClipboardPipeline';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            ClipboardMarkersUtils
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const view = editor.editing.view;
        view.addObserver(ClipboardObserver);
        this._setupPasteDrop();
        this._setupCopyCut();
    }
    /**
	 * Fires Clipboard `'outputTransformation'` event for given parameters.
	 *
	 * @internal
	 */ _fireOutputTransformationEvent(dataTransfer, selection, method) {
        const clipboardMarkersUtils = this.editor.plugins.get('ClipboardMarkersUtils');
        this.editor.model.enqueueChange({
            isUndoable: method === 'cut'
        }, ()=>{
            const documentFragment = clipboardMarkersUtils._copySelectedFragmentWithMarkers(method, selection);
            this.fire('outputTransformation', {
                dataTransfer,
                content: documentFragment,
                method
            });
        });
    }
    /**
	 * The clipboard paste pipeline.
	 */ _setupPasteDrop() {
        const editor = this.editor;
        const model = editor.model;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const clipboardMarkersUtils = this.editor.plugins.get('ClipboardMarkersUtils');
        // Pasting is disabled when selection is in non-editable place.
        // Dropping is disabled in drag and drop handler.
        this.listenTo(viewDocument, 'clipboardInput', (evt, data)=>{
            if (data.method == 'paste' && !editor.model.canEditAt(editor.model.document.selection)) {
                evt.stop();
            }
        }, {
            priority: 'highest'
        });
        this.listenTo(viewDocument, 'clipboardInput', (evt, data)=>{
            const dataTransfer = data.dataTransfer;
            let content;
            // Some feature could already inject content in the higher priority event handler (i.e., codeBlock).
            if (data.content) {
                content = data.content;
            } else {
                let contentData = '';
                if (dataTransfer.getData('text/html')) {
                    contentData = normalizeClipboardData(dataTransfer.getData('text/html'));
                } else if (dataTransfer.getData('text/plain')) {
                    contentData = plainTextToHtml(dataTransfer.getData('text/plain'));
                }
                content = this.editor.data.htmlProcessor.toView(contentData);
            }
            const eventInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventInfo"](this, 'inputTransformation');
            const sourceEditorId = dataTransfer.getData('application/ckeditor5-editor-id') || null;
            this.fire(eventInfo, {
                content,
                dataTransfer,
                sourceEditorId,
                targetRanges: data.targetRanges,
                method: data.method
            });
            // If CKEditor handled the input, do not bubble the original event any further.
            // This helps external integrations recognize this fact and act accordingly.
            // https://github.com/ckeditor/ckeditor5-upload/issues/92
            if (eventInfo.stop.called) {
                evt.stop();
            }
            view.scrollToTheSelection();
        }, {
            priority: 'low'
        });
        this.listenTo(this, 'inputTransformation', (evt, data)=>{
            if (data.content.isEmpty) {
                return;
            }
            const dataController = this.editor.data;
            // Convert the pasted content into a model document fragment.
            // The conversion is contextual, but in this case an "all allowed" context is needed
            // and for that we use the $clipboardHolder item.
            const modelFragment = dataController.toModel(data.content, '$clipboardHolder');
            if (modelFragment.childCount == 0) {
                return;
            }
            evt.stop();
            // Fire content insertion event in a single change block to allow other handlers to run in the same block
            // without post-fixers called in between (i.e., the selection post-fixer).
            model.change(()=>{
                this.fire('contentInsertion', {
                    content: modelFragment,
                    method: data.method,
                    sourceEditorId: data.sourceEditorId,
                    dataTransfer: data.dataTransfer,
                    targetRanges: data.targetRanges
                });
            });
        }, {
            priority: 'low'
        });
        this.listenTo(this, 'contentInsertion', (evt, data)=>{
            data.resultRange = clipboardMarkersUtils._pasteFragmentWithMarkers(data.content);
        }, {
            priority: 'low'
        });
    }
    /**
	 * The clipboard copy/cut pipeline.
	 */ _setupCopyCut() {
        const editor = this.editor;
        const modelDocument = editor.model.document;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const onCopyCut = (evt, data)=>{
            const dataTransfer = data.dataTransfer;
            data.preventDefault();
            this._fireOutputTransformationEvent(dataTransfer, modelDocument.selection, evt.name);
        };
        this.listenTo(viewDocument, 'copy', onCopyCut, {
            priority: 'low'
        });
        this.listenTo(viewDocument, 'cut', (evt, data)=>{
            // Cutting is disabled when selection is in non-editable place.
            // See: https://github.com/ckeditor/ckeditor5-clipboard/issues/26.
            if (!editor.model.canEditAt(editor.model.document.selection)) {
                data.preventDefault();
            } else {
                onCopyCut(evt, data);
            }
        }, {
            priority: 'low'
        });
        this.listenTo(this, 'outputTransformation', (evt, data)=>{
            const content = editor.data.toView(data.content, {
                isClipboardPipeline: true
            });
            viewDocument.fire('clipboardOutput', {
                dataTransfer: data.dataTransfer,
                content,
                method: data.method
            });
        }, {
            priority: 'low'
        });
        this.listenTo(viewDocument, 'clipboardOutput', (evt, data)=>{
            if (!data.content.isEmpty) {
                data.dataTransfer.setData('text/html', this.editor.data.htmlProcessor.toData(data.content));
                data.dataTransfer.setData('text/plain', viewToPlainText(editor.data.htmlProcessor.domConverter, data.content));
                data.dataTransfer.setData('application/ckeditor5-editor-id', this.editor.id);
            }
            if (data.method == 'cut') {
                editor.model.deleteContent(modelDocument.selection);
            }
        }, {
            priority: 'low'
        });
    }
}
const toPx = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUnit"])('px');
/**
 * The horizontal drop target line view.
 */ class LineView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * @inheritDoc
	 */ constructor(){
        super();
        const bind = this.bindTemplate;
        this.set({
            isVisible: false,
            left: null,
            top: null,
            width: null
        });
        this.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-clipboard-drop-target-line',
                    bind.if('isVisible', 'ck-hidden', (value)=>!value)
                ],
                style: {
                    left: bind.to('left', (left)=>toPx(left)),
                    top: bind.to('top', (top)=>toPx(top)),
                    width: bind.to('width', (width)=>toPx(width))
                }
            }
        });
    }
}
/**
 * Part of the Drag and Drop handling. Responsible for finding and displaying the drop target.
 *
 * @internal
 */ class DragDropTarget extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * A delayed callback removing the drop marker.
	 *
	 * @internal
	 */ removeDropMarkerDelayed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["delay"])(()=>this.removeDropMarker(), 40);
    /**
	 * A throttled callback updating the drop marker.
	 */ _updateDropMarkerThrottled = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])((targetRange)=>this._updateDropMarker(targetRange), 40);
    /**
	 * A throttled callback reconverting the drop parker.
	 */ _reconvertMarkerThrottled = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])(()=>{
        if (this.editor.model.markers.has('drop-target')) {
            this.editor.editing.reconvertMarker('drop-target');
        }
    }, 0);
    /**
	 * The horizontal drop target line view.
	 */ _dropTargetLineView = new LineView();
    /**
	 * DOM Emitter.
	 */ _domEmitter = new ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DomEmitterMixin"])())();
    /**
	 * Map of document scrollable elements.
	 */ _scrollables = new Map();
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'DragDropTarget';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        this._setupDropMarker();
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        this._domEmitter.stopListening();
        for (const { resizeObserver } of this._scrollables.values()){
            resizeObserver.destroy();
        }
        this._updateDropMarkerThrottled.cancel();
        this.removeDropMarkerDelayed.cancel();
        this._reconvertMarkerThrottled.cancel();
        return super.destroy();
    }
    /**
	 * Finds the drop target range and updates the drop marker.
	 *
	 * @internal
	 */ updateDropMarker(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
        this.removeDropMarkerDelayed.cancel();
        const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);
        /* istanbul ignore next -- @preserve */ if (!targetRange) {
            return;
        }
        if (draggedRange && draggedRange.containsRange(targetRange)) {
            // Target range is inside the dragged range.
            return this.removeDropMarker();
        }
        this._updateDropMarkerThrottled(targetRange);
    }
    /**
	 * Finds the final drop target range.
	 *
	 * @internal
	 */ getFinalDropRange(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
        const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);
        // The dragging markers must be removed after searching for the target range because sometimes
        // the target lands on the marker itself.
        this.removeDropMarker();
        return targetRange;
    }
    /**
	 * Removes the drop target marker.
	 *
	 * @internal
	 */ removeDropMarker() {
        const model = this.editor.model;
        this.removeDropMarkerDelayed.cancel();
        this._updateDropMarkerThrottled.cancel();
        this._dropTargetLineView.isVisible = false;
        if (model.markers.has('drop-target')) {
            model.change((writer)=>{
                writer.removeMarker('drop-target');
            });
        }
    }
    /**
	 * Creates downcast conversion for the drop target marker.
	 */ _setupDropMarker() {
        const editor = this.editor;
        editor.ui.view.body.add(this._dropTargetLineView);
        // Drop marker conversion for hovering over widgets.
        editor.conversion.for('editingDowncast').markerToHighlight({
            model: 'drop-target',
            view: {
                classes: [
                    'ck-clipboard-drop-target-range'
                ]
            }
        });
        // Drop marker conversion for in text and block drop target.
        editor.conversion.for('editingDowncast').markerToElement({
            model: 'drop-target',
            view: (data, { writer })=>{
                // Inline drop.
                if (editor.model.schema.checkChild(data.markerRange.start, '$text')) {
                    this._dropTargetLineView.isVisible = false;
                    return this._createDropTargetPosition(writer);
                } else {
                    if (data.markerRange.isCollapsed) {
                        this._updateDropTargetLine(data.markerRange);
                    } else {
                        this._dropTargetLineView.isVisible = false;
                    }
                }
            }
        });
    }
    /**
	 * Updates the drop target marker to the provided range.
	 *
	 * @param targetRange The range to set the marker to.
	 */ _updateDropMarker(targetRange) {
        const editor = this.editor;
        const markers = editor.model.markers;
        editor.model.change((writer)=>{
            if (markers.has('drop-target')) {
                if (!markers.get('drop-target').getRange().isEqual(targetRange)) {
                    writer.updateMarker('drop-target', {
                        range: targetRange
                    });
                }
            } else {
                writer.addMarker('drop-target', {
                    range: targetRange,
                    usingOperation: false,
                    affectsData: false
                });
            }
        });
    }
    /**
	 * Creates the UI element for vertical (in-line) drop target.
	 */ _createDropTargetPosition(writer) {
        return writer.createUIElement('span', {
            class: 'ck ck-clipboard-drop-target-position'
        }, function(domDocument) {
            const domElement = this.toDomElement(domDocument);
            // Using word joiner to make this marker as high as text and also making text not break on marker.
            domElement.append('\u2060', domDocument.createElement('span'), '\u2060');
            return domElement;
        });
    }
    /**
	 * Updates the horizontal drop target line.
	 */ _updateDropTargetLine(range) {
        const editing = this.editor.editing;
        const nodeBefore = range.start.nodeBefore;
        const nodeAfter = range.start.nodeAfter;
        const nodeParent = range.start.parent;
        const viewElementBefore = nodeBefore ? editing.mapper.toViewElement(nodeBefore) : null;
        const domElementBefore = viewElementBefore ? editing.view.domConverter.mapViewToDom(viewElementBefore) : null;
        const viewElementAfter = nodeAfter ? editing.mapper.toViewElement(nodeAfter) : null;
        const domElementAfter = viewElementAfter ? editing.view.domConverter.mapViewToDom(viewElementAfter) : null;
        const viewElementParent = editing.mapper.toViewElement(nodeParent);
        if (!viewElementParent) {
            return;
        }
        const domElementParent = editing.view.domConverter.mapViewToDom(viewElementParent);
        const domScrollableRect = this._getScrollableRect(viewElementParent);
        const { scrollX, scrollY } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window;
        const rectBefore = domElementBefore ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](domElementBefore) : null;
        const rectAfter = domElementAfter ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](domElementAfter) : null;
        const rectParent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](domElementParent).excludeScrollbarsAndBorders();
        const above = rectBefore ? rectBefore.bottom : rectParent.top;
        const below = rectAfter ? rectAfter.top : rectParent.bottom;
        const parentStyle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window.getComputedStyle(domElementParent);
        const top = above <= below ? (above + below) / 2 : below;
        if (domScrollableRect.top < top && top < domScrollableRect.bottom) {
            const left = rectParent.left + parseFloat(parentStyle.paddingLeft);
            const right = rectParent.right - parseFloat(parentStyle.paddingRight);
            const leftClamped = Math.max(left + scrollX, domScrollableRect.left);
            const rightClamped = Math.min(right + scrollX, domScrollableRect.right);
            this._dropTargetLineView.set({
                isVisible: true,
                left: leftClamped,
                top: top + scrollY,
                width: rightClamped - leftClamped
            });
        } else {
            this._dropTargetLineView.isVisible = false;
        }
    }
    /**
	 * Finds the closest scrollable element rect for the given view element.
	 */ _getScrollableRect(viewElement) {
        const rootName = viewElement.root.rootName;
        let domScrollable;
        if (this._scrollables.has(rootName)) {
            domScrollable = this._scrollables.get(rootName).domElement;
        } else {
            const domElement = this.editor.editing.view.domConverter.mapViewToDom(viewElement);
            domScrollable = findScrollableElement(domElement);
            this._domEmitter.listenTo(domScrollable, 'scroll', this._reconvertMarkerThrottled, {
                usePassive: true
            });
            const resizeObserver = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserver"](domScrollable, this._reconvertMarkerThrottled);
            this._scrollables.set(rootName, {
                domElement: domScrollable,
                resizeObserver
            });
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](domScrollable).excludeScrollbarsAndBorders();
    }
}
/**
 * Returns fixed selection range for given position and target element.
 */ function findDropTargetRange(editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
    const model = editor.model;
    const mapper = editor.editing.mapper;
    const targetModelElement = getClosestMappedModelElement(editor, targetViewElement);
    let modelElement = targetModelElement;
    while(modelElement){
        if (!blockMode) {
            if (model.schema.checkChild(modelElement, '$text')) {
                if (targetViewRanges) {
                    const targetViewPosition = targetViewRanges[0].start;
                    const targetModelPosition = mapper.toModelPosition(targetViewPosition);
                    const canDropOnPosition = !draggedRange || Array.from(draggedRange.getItems({
                        shallow: true
                    })).every((item)=>model.schema.checkChild(targetModelPosition, item));
                    if (canDropOnPosition) {
                        if (model.schema.checkChild(targetModelPosition, '$text')) {
                            return model.createRange(targetModelPosition);
                        } else if (targetViewPosition) {
                            // This is the case of dropping inside a span wrapper of an inline image.
                            return findDropTargetRangeForElement(editor, getClosestMappedModelElement(editor, targetViewPosition.parent), clientX, clientY);
                        }
                    }
                }
            } else if (model.schema.isInline(modelElement)) {
                return findDropTargetRangeForElement(editor, modelElement, clientX, clientY);
            }
        }
        if (model.schema.isBlock(modelElement)) {
            return findDropTargetRangeForElement(editor, modelElement, clientX, clientY);
        } else if (model.schema.checkChild(modelElement, '$block')) {
            const childNodes = Array.from(modelElement.getChildren()).filter((node)=>node.is('element') && !shouldIgnoreElement(editor, node));
            let startIndex = 0;
            let endIndex = childNodes.length;
            if (endIndex == 0) {
                return model.createRange(model.createPositionAt(modelElement, 'end'));
            }
            while(startIndex < endIndex - 1){
                const middleIndex = Math.floor((startIndex + endIndex) / 2);
                const side = findElementSide(editor, childNodes[middleIndex], clientX, clientY);
                if (side == 'before') {
                    endIndex = middleIndex;
                } else {
                    startIndex = middleIndex;
                }
            }
            return findDropTargetRangeForElement(editor, childNodes[startIndex], clientX, clientY);
        }
        modelElement = modelElement.parent;
    }
    return null;
}
/**
 * Returns true for elements which should be ignored.
 */ function shouldIgnoreElement(editor, modelElement) {
    const mapper = editor.editing.mapper;
    const domConverter = editor.editing.view.domConverter;
    const viewElement = mapper.toViewElement(modelElement);
    if (!viewElement) {
        return true;
    }
    const domElement = domConverter.mapViewToDom(viewElement);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window.getComputedStyle(domElement).float != 'none';
}
/**
 * Returns target range relative to the given element.
 */ function findDropTargetRangeForElement(editor, modelElement, clientX, clientY) {
    const model = editor.model;
    return model.createRange(model.createPositionAt(modelElement, findElementSide(editor, modelElement, clientX, clientY)));
}
/**
 * Resolves whether drop marker should be before or after the given element.
 */ function findElementSide(editor, modelElement, clientX, clientY) {
    const mapper = editor.editing.mapper;
    const domConverter = editor.editing.view.domConverter;
    const viewElement = mapper.toViewElement(modelElement);
    const domElement = domConverter.mapViewToDom(viewElement);
    const rect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](domElement);
    if (editor.model.schema.isInline(modelElement)) {
        return clientX < (rect.left + rect.right) / 2 ? 'before' : 'after';
    } else {
        return clientY < (rect.top + rect.bottom) / 2 ? 'before' : 'after';
    }
}
/**
 * Returns the closest model element for the specified view element.
 */ function getClosestMappedModelElement(editor, element) {
    const mapper = editor.editing.mapper;
    const view = editor.editing.view;
    const targetModelElement = mapper.toModelElement(element);
    if (targetModelElement) {
        return targetModelElement;
    }
    // Find mapped ancestor if the target is inside not mapped element (for example inline code element).
    const viewPosition = view.createPositionBefore(element);
    const viewElement = mapper.findMappedViewAncestor(viewPosition);
    return mapper.toModelElement(viewElement);
}
/**
 * Returns the closest scrollable ancestor DOM element.
 *
 * It is assumed that `domNode` is attached to the document.
 */ function findScrollableElement(domNode) {
    let domElement = domNode;
    do {
        domElement = domElement.parentElement;
        const overflow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window.getComputedStyle(domElement).overflowY;
        if (overflow == 'auto' || overflow == 'scroll') {
            break;
        }
    }while (domElement.tagName != 'BODY')
    return domElement;
}
/**
 * Integration of a block Drag and Drop support with the block toolbar.
 *
 * @internal
 */ class DragDropBlockToolbar extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * Whether current dragging is started by block toolbar button dragging.
	 */ _isBlockDragging = false;
    /**
	 * DOM Emitter.
	 */ _domEmitter = new ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DomEmitterMixin"])())();
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'DragDropBlockToolbar';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        this.listenTo(editor, 'change:isReadOnly', (evt, name, isReadOnly)=>{
            if (isReadOnly) {
                this.forceDisabled('readOnlyMode');
                this._isBlockDragging = false;
            } else {
                this.clearForceDisabled('readOnlyMode');
            }
        });
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isAndroid) {
            this.forceDisabled('noAndroidSupport');
        }
        if (editor.plugins.has('BlockToolbar')) {
            const blockToolbar = editor.plugins.get('BlockToolbar');
            const element = blockToolbar.buttonView.element;
            this._domEmitter.listenTo(element, 'dragstart', (evt, data)=>this._handleBlockDragStart(data));
            this._domEmitter.listenTo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document, 'dragover', (evt, data)=>this._handleBlockDragging(data));
            this._domEmitter.listenTo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document, 'drop', (evt, data)=>this._handleBlockDragging(data));
            this._domEmitter.listenTo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document, 'dragend', ()=>this._handleBlockDragEnd(), {
                useCapture: true
            });
            if (this.isEnabled) {
                element.setAttribute('draggable', 'true');
            }
            this.on('change:isEnabled', (evt, name, isEnabled)=>{
                element.setAttribute('draggable', isEnabled ? 'true' : 'false');
            });
        }
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        this._domEmitter.stopListening();
        return super.destroy();
    }
    /**
	 * The `dragstart` event handler.
	 */ _handleBlockDragStart(domEvent) {
        if (!this.isEnabled) {
            return;
        }
        const model = this.editor.model;
        const selection = model.document.selection;
        const view = this.editor.editing.view;
        const blocks = Array.from(selection.getSelectedBlocks());
        const draggedRange = model.createRange(model.createPositionBefore(blocks[0]), model.createPositionAfter(blocks[blocks.length - 1]));
        model.change((writer)=>writer.setSelection(draggedRange));
        this._isBlockDragging = true;
        view.focus();
        view.getObserver(ClipboardObserver).onDomEvent(domEvent);
    }
    /**
	 * The `dragover` and `drop` event handler.
	 */ _handleBlockDragging(domEvent) {
        if (!this.isEnabled || !this._isBlockDragging) {
            return;
        }
        const clientX = domEvent.clientX + (this.editor.locale.contentLanguageDirection == 'ltr' ? 100 : -100);
        const clientY = domEvent.clientY;
        const target = document.elementFromPoint(clientX, clientY);
        const view = this.editor.editing.view;
        if (!target || !target.closest('.ck-editor__editable')) {
            return;
        }
        view.getObserver(ClipboardObserver).onDomEvent({
            ...domEvent,
            type: domEvent.type,
            dataTransfer: domEvent.dataTransfer,
            target,
            clientX,
            clientY,
            preventDefault: ()=>domEvent.preventDefault(),
            stopPropagation: ()=>domEvent.stopPropagation()
        });
    }
    /**
	 * The `dragend` event handler.
	 */ _handleBlockDragEnd() {
        this._isBlockDragging = false;
    }
}
// Drag and drop events overview:
//
//                ┌──────────────────┐
//                │     mousedown    │   Sets the draggable attribute.
//                └─────────┬────────┘
//                          │
//                          └─────────────────────┐
//                          │                     │
//                          │           ┌─────────V────────┐
//                          │           │      mouseup     │   Dragging did not start, removes the draggable attribute.
//                          │           └──────────────────┘
//                          │
//                ┌─────────V────────┐   Retrieves the selected model.DocumentFragment
//                │     dragstart    │   and converts it to view.DocumentFragment.
//                └─────────┬────────┘
//                          │
//                ┌─────────V────────┐   Processes view.DocumentFragment to text/html and text/plain
//                │  clipboardOutput │   and stores the results in data.dataTransfer.
//                └─────────┬────────┘
//                          │
//                          │   DOM dragover
//                          ┌────────────┐
//                          │            │
//                ┌─────────V────────┐   │
//                │     dragging     │   │   Updates the drop target marker.
//                └─────────┬────────┘   │
//                          │            │
//            ┌─────────────└────────────┘
//            │             │            │
//            │   ┌─────────V────────┐   │
//            │   │     dragleave    │   │   Removes the drop target marker.
//            │   └─────────┬────────┘   │
//            │             │            │
//        ┌───│─────────────┘            │
//        │   │             │            │
//        │   │   ┌─────────V────────┐   │
//        │   │   │     dragenter    │   │   Focuses the editor view.
//        │   │   └─────────┬────────┘   │
//        │   │             │            │
//        │   │             └────────────┘
//        │   │
//        │   └─────────────┐
//        │   │             │
//        │   │   ┌─────────V────────┐
//        └───┐   │       drop       │   (The default handler of the clipboard pipeline).
//            │   └─────────┬────────┘
//            │             │
//            │   ┌─────────V────────┐   Resolves the final data.targetRanges.
//            │   │  clipboardInput  │   Aborts if dropping on dragged content.
//            │   └─────────┬────────┘
//            │             │
//            │   ┌─────────V────────┐
//            │   │  clipboardInput  │   (The default handler of the clipboard pipeline).
//            │   └─────────┬────────┘
//            │             │
//            │ ┌───────────V───────────┐
//            │ │  inputTransformation  │   (The default handler of the clipboard pipeline).
//            │ └───────────┬───────────┘
//            │             │
//            │  ┌──────────V──────────┐
//            │  │   contentInsertion  │   Updates the document selection to drop range.
//            │  └──────────┬──────────┘
//            │             │
//            │  ┌──────────V──────────┐
//            │  │   contentInsertion  │   (The default handler of the clipboard pipeline).
//            │  └──────────┬──────────┘
//            │             │
//            │  ┌──────────V──────────┐
//            │  │   contentInsertion  │   Removes the content from the original range if the insertion was successful.
//            │  └──────────┬──────────┘
//            │             │
//            └─────────────┐
//                          │
//                ┌─────────V────────┐
//                │      dragend     │   Removes the drop marker and cleans the state.
//                └──────────────────┘
//
/**
 * The drag and drop feature. It works on top of the {@link module:clipboard/clipboardpipeline~ClipboardPipeline}.
 *
 * Read more about the clipboard integration in the {@glink framework/deep-dive/clipboard clipboard deep-dive} guide.
 *
 * @internal
 */ class DragDrop extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * The live range over the original content that is being dragged.
	 */ _draggedRange;
    /**
	 * The UID of current dragging that is used to verify if the drop started in the same editor as the drag start.
	 *
	 * **Note**: This is a workaround for broken 'dragend' events (they are not fired if the source text node got removed).
	 */ _draggingUid;
    /**
	 * The reference to the model element that currently has a `draggable` attribute set (it is set while dragging).
	 */ _draggableElement;
    /**
	 * A delayed callback removing draggable attributes.
	 */ _clearDraggableAttributesDelayed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["delay"])(()=>this._clearDraggableAttributes(), 40);
    /**
	 * Whether the dragged content can be dropped only in block context.
	 */ // TODO handle drag from other editor instance
    // TODO configure to use block, inline or both
    _blockMode = false;
    /**
	 * DOM Emitter.
	 */ _domEmitter = new ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DomEmitterMixin"])())();
    /**
	 * The DOM element used to generate dragged preview image.
	 */ _previewContainer;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'DragDrop';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            ClipboardPipeline,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Widget"],
            DragDropTarget,
            DragDropBlockToolbar
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const view = editor.editing.view;
        this._draggedRange = null;
        this._draggingUid = '';
        this._draggableElement = null;
        view.addObserver(ClipboardObserver);
        view.addObserver(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MouseObserver"]);
        this._setupDragging();
        this._setupContentInsertionIntegration();
        this._setupClipboardInputIntegration();
        this._setupDraggableAttributeHandling();
        this.listenTo(editor, 'change:isReadOnly', (evt, name, isReadOnly)=>{
            if (isReadOnly) {
                this.forceDisabled('readOnlyMode');
            } else {
                this.clearForceDisabled('readOnlyMode');
            }
        });
        this.on('change:isEnabled', (evt, name, isEnabled)=>{
            if (!isEnabled) {
                this._finalizeDragging(false);
            }
        });
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isAndroid) {
            this.forceDisabled('noAndroidSupport');
        }
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        if (this._draggedRange) {
            this._draggedRange.detach();
            this._draggedRange = null;
        }
        if (this._previewContainer) {
            this._previewContainer.remove();
        }
        this._domEmitter.stopListening();
        this._clearDraggableAttributesDelayed.cancel();
        return super.destroy();
    }
    /**
	 * Drag and drop events handling.
	 */ _setupDragging() {
        const editor = this.editor;
        const model = editor.model;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const dragDropTarget = editor.plugins.get(DragDropTarget);
        // The handler for the drag start; it is responsible for setting data transfer object.
        this.listenTo(viewDocument, 'dragstart', (evt, data)=>{
            // Don't drag the editable element itself.
            if (data.target && data.target.is('editableElement')) {
                data.preventDefault();
                return;
            }
            this._prepareDraggedRange(data.target);
            if (!this._draggedRange) {
                data.preventDefault();
                return;
            }
            this._draggingUid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])();
            data.dataTransfer.effectAllowed = this.isEnabled ? 'copyMove' : 'copy';
            data.dataTransfer.setData('application/ckeditor5-dragging-uid', this._draggingUid);
            const draggedSelection = model.createSelection(this._draggedRange.toRange());
            const clipboardPipeline = this.editor.plugins.get('ClipboardPipeline');
            clipboardPipeline._fireOutputTransformationEvent(data.dataTransfer, draggedSelection, 'dragstart');
            const { dataTransfer, domTarget, domEvent } = data;
            const { clientX } = domEvent;
            this._updatePreview({
                dataTransfer,
                domTarget,
                clientX
            });
            data.stopPropagation();
            if (!this.isEnabled) {
                this._draggedRange.detach();
                this._draggedRange = null;
                this._draggingUid = '';
            }
        }, {
            priority: 'low'
        });
        // The handler for finalizing drag and drop. It should always be triggered after dragging completes
        // even if it was completed in a different application.
        // Note: This is not fired if source text node got removed while downcasting a marker.
        this.listenTo(viewDocument, 'dragend', (evt, data)=>{
            this._finalizeDragging(!data.dataTransfer.isCanceled && data.dataTransfer.dropEffect == 'move');
        }, {
            priority: 'low'
        });
        // Reset block dragging mode even if dropped outside the editable.
        this._domEmitter.listenTo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document, 'dragend', ()=>{
            this._blockMode = false;
        }, {
            useCapture: true
        });
        // Dragging over the editable.
        this.listenTo(viewDocument, 'dragenter', ()=>{
            if (!this.isEnabled) {
                return;
            }
            view.focus();
        });
        // Dragging out of the editable.
        this.listenTo(viewDocument, 'dragleave', ()=>{
            // We do not know if the mouse left the editor or just some element in it, so let us wait a few milliseconds
            // to check if 'dragover' is not fired.
            dragDropTarget.removeDropMarkerDelayed();
        });
        // Handler for moving dragged content over the target area.
        this.listenTo(viewDocument, 'dragging', (evt, data)=>{
            if (!this.isEnabled) {
                data.dataTransfer.dropEffect = 'none';
                return;
            }
            const { clientX, clientY } = data.domEvent;
            dragDropTarget.updateDropMarker(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);
            // If this is content being dragged from another editor, moving out of current editor instance
            // is not possible until 'dragend' event case will be fixed.
            if (!this._draggedRange) {
                data.dataTransfer.dropEffect = 'copy';
            }
            // In Firefox it is already set and effect allowed remains the same as originally set.
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isGecko) {
                if (data.dataTransfer.effectAllowed == 'copy') {
                    data.dataTransfer.dropEffect = 'copy';
                } else if ([
                    'all',
                    'copyMove'
                ].includes(data.dataTransfer.effectAllowed)) {
                    data.dataTransfer.dropEffect = 'move';
                }
            }
            evt.stop();
        }, {
            priority: 'low'
        });
    }
    /**
	 * Integration with the `clipboardInput` event.
	 */ _setupClipboardInputIntegration() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const dragDropTarget = editor.plugins.get(DragDropTarget);
        // Update the event target ranges and abort dropping if dropping over itself.
        this.listenTo(viewDocument, 'clipboardInput', (evt, data)=>{
            if (data.method != 'drop') {
                return;
            }
            const { clientX, clientY } = data.domEvent;
            const targetRange = dragDropTarget.getFinalDropRange(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);
            if (!targetRange) {
                this._finalizeDragging(false);
                evt.stop();
                return;
            }
            // Since we cannot rely on the drag end event, we must check if the local drag range is from the current drag and drop
            // or it is from some previous not cleared one.
            if (this._draggedRange && this._draggingUid != data.dataTransfer.getData('application/ckeditor5-dragging-uid')) {
                this._draggedRange.detach();
                this._draggedRange = null;
                this._draggingUid = '';
            }
            // Do not do anything if some content was dragged within the same document to the same position.
            const isMove = getFinalDropEffect(data.dataTransfer) == 'move';
            if (isMove && this._draggedRange && this._draggedRange.containsRange(targetRange, true)) {
                this._finalizeDragging(false);
                evt.stop();
                return;
            }
            // Override the target ranges with the one adjusted to the best one for a drop.
            data.targetRanges = [
                editor.editing.mapper.toViewRange(targetRange)
            ];
        }, {
            priority: 'high'
        });
    }
    /**
	 * Integration with the `contentInsertion` event of the clipboard pipeline.
	 */ _setupContentInsertionIntegration() {
        const clipboardPipeline = this.editor.plugins.get(ClipboardPipeline);
        clipboardPipeline.on('contentInsertion', (evt, data)=>{
            if (!this.isEnabled || data.method !== 'drop') {
                return;
            }
            // Update the selection to the target range in the same change block to avoid selection post-fixing
            // and to be able to clone text attributes for plain text dropping.
            const ranges = data.targetRanges.map((viewRange)=>this.editor.editing.mapper.toModelRange(viewRange));
            this.editor.model.change((writer)=>writer.setSelection(ranges));
        }, {
            priority: 'high'
        });
        clipboardPipeline.on('contentInsertion', (evt, data)=>{
            if (!this.isEnabled || data.method !== 'drop') {
                return;
            }
            // Remove dragged range content, remove markers, clean after dragging.
            const isMove = getFinalDropEffect(data.dataTransfer) == 'move';
            // Whether any content was inserted (insertion might fail if the schema is disallowing some elements
            // (for example an image caption allows only the content of a block but not blocks themselves.
            // Some integrations might not return valid range (i.e., table pasting).
            const isSuccess = !data.resultRange || !data.resultRange.isCollapsed;
            this._finalizeDragging(isSuccess && isMove);
        }, {
            priority: 'lowest'
        });
    }
    /**
	 * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.
	 */ _setupDraggableAttributeHandling() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        // Add the 'draggable' attribute to the widget while pressing the selection handle.
        // This is required for widgets to be draggable. In Chrome it will enable dragging text nodes.
        this.listenTo(viewDocument, 'mousedown', (evt, data)=>{
            // The lack of data can be caused by editor tests firing fake mouse events. This should not occur
            // in real-life scenarios but this greatly simplifies editor tests that would otherwise fail a lot.
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isAndroid || !data) {
                return;
            }
            this._clearDraggableAttributesDelayed.cancel();
            // Check if this is a mousedown over the widget (but not a nested editable).
            let draggableElement = findDraggableWidget(data.target);
            // Note: There is a limitation that if more than a widget is selected (a widget and some text)
            // and dragging starts on the widget, then only the widget is dragged.
            // If this was not a widget then we should check if we need to drag some text content.
            // In Chrome set a 'draggable' attribute on closest editable to allow immediate dragging of the selected text range.
            // In Firefox this is not needed. In Safari it makes the whole editable draggable (not just textual content).
            // Disabled in read-only mode because draggable="true" + contenteditable="false" results
            // in not firing selectionchange event ever, which makes the selection stuck in read-only mode.
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isBlink && !editor.isReadOnly && !draggableElement && !viewDocument.selection.isCollapsed) {
                const selectedElement = viewDocument.selection.getSelectedElement();
                if (!selectedElement || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWidget"])(selectedElement)) {
                    draggableElement = viewDocument.selection.editableElement;
                }
            }
            if (draggableElement) {
                view.change((writer)=>{
                    writer.setAttribute('draggable', 'true', draggableElement);
                });
                // Keep the reference to the model element in case the view element gets removed while dragging.
                this._draggableElement = editor.editing.mapper.toModelElement(draggableElement);
            }
        });
        // Remove the draggable attribute in case no dragging started (only mousedown + mouseup).
        this.listenTo(viewDocument, 'mouseup', ()=>{
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isAndroid) {
                this._clearDraggableAttributesDelayed();
            }
        });
    }
    /**
	 * Removes the `draggable` attribute from the element that was used for dragging.
	 */ _clearDraggableAttributes() {
        const editing = this.editor.editing;
        editing.view.change((writer)=>{
            // Remove 'draggable' attribute.
            if (this._draggableElement && this._draggableElement.root.rootName != '$graveyard') {
                writer.removeAttribute('draggable', editing.mapper.toViewElement(this._draggableElement));
            }
            this._draggableElement = null;
        });
    }
    /**
	 * Deletes the dragged content from its original range and clears the dragging state.
	 *
	 * @param moved Whether the move succeeded.
	 */ _finalizeDragging(moved) {
        const editor = this.editor;
        const model = editor.model;
        const dragDropTarget = editor.plugins.get(DragDropTarget);
        dragDropTarget.removeDropMarker();
        this._clearDraggableAttributes();
        if (editor.plugins.has('WidgetToolbarRepository')) {
            const widgetToolbarRepository = editor.plugins.get('WidgetToolbarRepository');
            widgetToolbarRepository.clearForceDisabled('dragDrop');
        }
        this._draggingUid = '';
        if (this._previewContainer) {
            this._previewContainer.remove();
            this._previewContainer = undefined;
        }
        if (!this._draggedRange) {
            return;
        }
        // Delete moved content.
        if (moved && this.isEnabled) {
            model.change((writer)=>{
                const selection = model.createSelection(this._draggedRange);
                model.deleteContent(selection, {
                    doNotAutoparagraph: true
                });
                // Check result selection if it does not require auto-paragraphing of empty container.
                const selectionParent = selection.getFirstPosition().parent;
                if (selectionParent.isEmpty && !model.schema.checkChild(selectionParent, '$text') && model.schema.checkChild(selectionParent, 'paragraph')) {
                    writer.insertElement('paragraph', selectionParent, 0);
                }
            });
        }
        this._draggedRange.detach();
        this._draggedRange = null;
    }
    /**
	 * Sets the dragged source range based on event target and document selection.
	 */ _prepareDraggedRange(target) {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        // Check if this is dragstart over the widget (but not a nested editable).
        const draggableWidget = target ? findDraggableWidget(target) : null;
        if (draggableWidget) {
            const modelElement = editor.editing.mapper.toModelElement(draggableWidget);
            this._draggedRange = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LiveRange"].fromRange(model.createRangeOn(modelElement));
            this._blockMode = model.schema.isBlock(modelElement);
            // Disable toolbars so they won't obscure the drop area.
            if (editor.plugins.has('WidgetToolbarRepository')) {
                const widgetToolbarRepository = editor.plugins.get('WidgetToolbarRepository');
                widgetToolbarRepository.forceDisabled('dragDrop');
            }
            return;
        }
        // If this was not a widget we should check if we need to drag some text content.
        if (selection.isCollapsed && !selection.getFirstPosition().parent.isEmpty) {
            return;
        }
        const blocks = Array.from(selection.getSelectedBlocks());
        const draggedRange = selection.getFirstRange();
        if (blocks.length == 0) {
            this._draggedRange = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LiveRange"].fromRange(draggedRange);
            return;
        }
        const blockRange = getRangeIncludingFullySelectedParents(model, blocks);
        if (blocks.length > 1) {
            this._draggedRange = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LiveRange"].fromRange(blockRange);
            this._blockMode = true;
        // TODO block mode for dragging from outside editor? or inline? or both?
        } else if (blocks.length == 1) {
            const touchesBlockEdges = draggedRange.start.isTouching(blockRange.start) && draggedRange.end.isTouching(blockRange.end);
            this._draggedRange = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LiveRange"].fromRange(touchesBlockEdges ? blockRange : draggedRange);
            this._blockMode = touchesBlockEdges;
        }
        model.change((writer)=>writer.setSelection(this._draggedRange.toRange()));
    }
    /**
	 * Updates the dragged preview image.
	 */ _updatePreview({ dataTransfer, domTarget, clientX }) {
        const view = this.editor.editing.view;
        const editable = view.document.selection.editableElement;
        const domEditable = view.domConverter.mapViewToDom(editable);
        const computedStyle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window.getComputedStyle(domEditable);
        if (!this._previewContainer) {
            this._previewContainer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document, 'div', {
                style: 'position: fixed; left: -999999px;'
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document.body.appendChild(this._previewContainer);
        } else if (this._previewContainer.firstElementChild) {
            this._previewContainer.removeChild(this._previewContainer.firstElementChild);
        }
        const domRect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](domEditable);
        // If domTarget is inside the editable root, browsers will display the preview correctly by themselves.
        if (domEditable.contains(domTarget)) {
            return;
        }
        const domEditablePaddingLeft = parseFloat(computedStyle.paddingLeft);
        const preview = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document, 'div');
        preview.className = 'ck ck-content';
        preview.style.width = computedStyle.width;
        preview.style.paddingLeft = `${domRect.left - clientX + domEditablePaddingLeft}px`;
        /**
		 * Set white background in drag and drop preview if iOS.
		 * Check: https://github.com/ckeditor/ckeditor5/issues/15085
		 */ if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isiOS) {
            preview.style.backgroundColor = 'white';
        }
        view.domConverter.setContentOf(preview, dataTransfer.getData('text/html'));
        dataTransfer.setDragImage(preview, 0, 0);
        this._previewContainer.appendChild(preview);
    }
}
/**
 * Returns the drop effect that should be a result of dragging the content.
 * This function is handling a quirk when checking the effect in the 'drop' DOM event.
 */ function getFinalDropEffect(dataTransfer) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isGecko) {
        return dataTransfer.dropEffect;
    }
    return [
        'all',
        'copyMove'
    ].includes(dataTransfer.effectAllowed) ? 'move' : 'copy';
}
/**
 * Returns a widget element that should be dragged.
 */ function findDraggableWidget(target) {
    // This is directly an editable so not a widget for sure.
    if (target.is('editableElement')) {
        return null;
    }
    // TODO: Let's have a isWidgetSelectionHandleDomElement() helper in ckeditor5-widget utils.
    if (target.hasClass('ck-widget__selection-handle')) {
        return target.findAncestor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWidget"]);
    }
    // Direct hit on a widget.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWidget"])(target)) {
        return target;
    }
    // Find closest ancestor that is either a widget or an editable element...
    const ancestor = target.findAncestor((node)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWidget"])(node) || node.is('editableElement'));
    // ...and if closer was the widget then enable dragging it.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWidget"])(ancestor)) {
        return ancestor;
    }
    return null;
}
/**
 * Recursively checks if common parent of provided elements doesn't have any other children. If that's the case,
 * it returns range including this parent. Otherwise, it returns only the range from first to last element.
 *
 * Example:
 *
 * <blockQuote>
 *   <paragraph>[Test 1</paragraph>
 *   <paragraph>Test 2</paragraph>
 *   <paragraph>Test 3]</paragraph>
 * <blockQuote>
 *
 * Because all elements inside the `blockQuote` are selected, the range is extended to include the `blockQuote` too.
 * If only first and second paragraphs would be selected, the range would not include it.
 */ function getRangeIncludingFullySelectedParents(model, elements) {
    const firstElement = elements[0];
    const lastElement = elements[elements.length - 1];
    const parent = firstElement.getCommonAncestor(lastElement);
    const startPosition = model.createPositionBefore(firstElement);
    const endPosition = model.createPositionAfter(lastElement);
    if (parent && parent.is('element') && !model.schema.isLimit(parent)) {
        const parentRange = model.createRangeOn(parent);
        const touchesStart = startPosition.isTouching(parentRange.start);
        const touchesEnd = endPosition.isTouching(parentRange.end);
        if (touchesStart && touchesEnd) {
            // Selection includes all elements in the parent.
            return getRangeIncludingFullySelectedParents(model, [
                parent
            ]);
        }
    }
    return model.createRange(startPosition, endPosition);
}
/**
 * The plugin detects the user's intention to paste plain text.
 *
 * For example, it detects the <kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>V</kbd> keystroke.
 */ class PastePlainText extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'PastePlainText';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            ClipboardPipeline
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const model = editor.model;
        const view = editor.editing.view;
        const selection = model.document.selection;
        view.addObserver(ClipboardObserver);
        editor.plugins.get(ClipboardPipeline).on('contentInsertion', (evt, data)=>{
            if (!isUnformattedInlineContent(data.content, model)) {
                return;
            }
            model.change((writer)=>{
                // Formatting attributes should be preserved.
                const textAttributes = Array.from(selection.getAttributes()).filter(([key])=>model.schema.getAttributeProperties(key).isFormatting);
                if (!selection.isCollapsed) {
                    model.deleteContent(selection, {
                        doNotAutoparagraph: true
                    });
                }
                // Also preserve other attributes if they survived the content deletion (because they were not fully selected).
                // For example linkHref is not a formatting attribute but it should be preserved if pasted text was in the middle
                // of a link.
                textAttributes.push(...selection.getAttributes());
                const range = writer.createRangeIn(data.content);
                for (const item of range.getItems()){
                    for (const attribute of textAttributes){
                        if (model.schema.checkAttribute(item, attribute[0])) {
                            writer.setAttribute(attribute[0], attribute[1], item);
                        }
                    }
                }
            });
        });
    }
}
/**
 * Returns true if specified `documentFragment` represents the unformatted inline content.
 */ function isUnformattedInlineContent(documentFragment, model) {
    let range = model.createRangeIn(documentFragment);
    // We consider three scenarios here. The document fragment may include:
    //
    // 1. Only text and inline objects. Then it could be unformatted inline content.
    // 2. Exactly one block element on top-level, eg. <p>Foobar</p> or <h2>Title</h2>.
    //    In this case, check this element content, it could be treated as unformatted inline content.
    // 3. More block elements or block objects, then it is not unformatted inline content.
    //
    // We will check for scenario 2. specifically, and if it happens, we will unwrap it and follow with the regular algorithm.
    //
    if (documentFragment.childCount == 1) {
        const child = documentFragment.getChild(0);
        if (child.is('element') && model.schema.isBlock(child) && !model.schema.isObject(child) && !model.schema.isLimit(child)) {
            // Scenario 2. as described above.
            range = model.createRangeIn(child);
        }
    }
    for (const child of range.getItems()){
        if (!model.schema.isInline(child)) {
            return false;
        }
        const attributeKeys = Array.from(child.getAttributeKeys());
        if (attributeKeys.find((key)=>model.schema.getAttributeProperties(key).isFormatting)) {
            return false;
        }
    }
    return true;
}
/**
 * The clipboard feature.
 *
 * Read more about the clipboard integration in the {@glink framework/deep-dive/clipboard clipboard deep-dive} guide.
 *
 * This is a "glue" plugin which loads the following plugins:
 * * {@link module:clipboard/clipboardpipeline~ClipboardPipeline}
 * * {@link module:clipboard/dragdrop~DragDrop}
 * * {@link module:clipboard/pasteplaintext~PastePlainText}
 */ class Clipboard extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Clipboard';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            ClipboardMarkersUtils,
            ClipboardPipeline,
            DragDrop,
            PastePlainText
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = this.editor.t;
        // Add the information about the keystrokes to the accessibility database.
        editor.accessibility.addKeystrokeInfos({
            keystrokes: [
                {
                    label: t('Copy selected content'),
                    keystroke: 'CTRL+C'
                },
                {
                    label: t('Paste content'),
                    keystroke: 'CTRL+V'
                },
                {
                    label: t('Paste content as plain text'),
                    keystroke: 'CTRL+SHIFT+V'
                }
            ]
        });
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-cloud-services/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "CloudServices": (()=>CloudServices),
    "CloudServicesCore": (()=>CloudServicesCore),
    "Token": (()=>Token)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
;
;
const DEFAULT_OPTIONS = {
    autoRefresh: true
};
const DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME = 3600000; // 1 hour
const TOKEN_FAILED_REFRESH_TIMEOUT_TIME = 5000; // 5 seconds
/**
 * The class representing the token used for communication with CKEditor Cloud Services.
 * The value of the token is retrieved from the specified URL and refreshed every 1 hour by default.
 * If the token retrieval fails, the token will automatically retry in 5 seconds intervals.
 */ class Token extends /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObservableMixin"])() {
    /**
	 * Base refreshing function.
	 */ _refresh;
    /**
	 * Cached token options.
	 */ _options;
    /**
	 * `setTimeout()` id for a token refresh when {@link module:cloud-services/token/token~TokenOptions auto refresh} is enabled.
	 */ _tokenRefreshTimeout;
    /**
	 * Flag indicating whether the token has been destroyed.
	 */ _isDestroyed = false;
    /**
	 * Creates `Token` instance.
	 * Method `init` should be called after using the constructor or use `create` method instead.
	 *
	 * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
	 * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
	 */ constructor(tokenUrlOrRefreshToken, options = {}){
        super();
        if (!tokenUrlOrRefreshToken) {
            /**
			 * A `tokenUrl` must be provided as the first constructor argument.
			 *
			 * @error token-missing-token-url
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('token-missing-token-url', this);
        }
        if (options.initValue) {
            this._validateTokenValue(options.initValue);
        }
        this.set('value', options.initValue);
        if (typeof tokenUrlOrRefreshToken === 'function') {
            this._refresh = tokenUrlOrRefreshToken;
        } else {
            this._refresh = ()=>defaultRefreshToken(tokenUrlOrRefreshToken);
        }
        this._options = {
            ...DEFAULT_OPTIONS,
            ...options
        };
    }
    /**
	 * Initializes the token.
	 */ init() {
        return new Promise((resolve, reject)=>{
            if (!this.value) {
                this.refreshToken().then(resolve).catch(reject);
                return;
            }
            if (this._options.autoRefresh) {
                this._registerRefreshTokenTimeout();
            }
            resolve(this);
        });
    }
    /**
	 * Refresh token method. Useful in a method form as it can be overridden in tests.
	 *
	 * This method will be invoked periodically based on the token expiry date after first call to keep the token up-to-date
	 * (requires {@link module:cloud-services/token/token~TokenOptions auto refresh option} to be set).
	 *
	 * If the token refresh fails, the method will retry in 5 seconds intervals until success or the token gets
	 * {@link #destroy destroyed}.
	 */ refreshToken() {
        const autoRefresh = this._options.autoRefresh;
        return this._refresh().then((value)=>{
            this._validateTokenValue(value);
            this.set('value', value);
            if (autoRefresh) {
                this._registerRefreshTokenTimeout();
            }
            return this;
        }).catch((err)=>{
            /**
				 * You will see this warning when the CKEditor {@link module:cloud-services/token/token~Token token} could not be refreshed.
				 * This may be a result of a network error, a token endpoint (server) error, or an invalid
				 * {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig#tokenUrl token URL configuration}.
				 *
				 * If this warning repeats, please make sure that the configuration is correct and that the token
				 * endpoint is up and running. {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig#tokenUrl Learn more}
				 * about token configuration.
				 *
				 * **Note:** If the token's {@link module:cloud-services/token/token~TokenOptions auto refresh option} is enabled,
				 * attempts to refresh will be made until success or token's
				 * {@link module:cloud-services/token/token~Token#destroy destruction}.
				 *
				 * @error token-refresh-failed
				 * @param autoRefresh Whether the token will keep auto refreshing.
				 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('token-refresh-failed', {
                autoRefresh
            });
            // If the refresh failed, keep trying to refresh the token. Failing to do so will eventually
            // lead to the disconnection from the RTC service and the editing session (and potential data loss
            // if the user keeps editing).
            if (autoRefresh) {
                this._registerRefreshTokenTimeout(TOKEN_FAILED_REFRESH_TIMEOUT_TIME);
            }
            throw err;
        });
    }
    /**
	 * Destroys token instance. Stops refreshing.
	 */ destroy() {
        this._isDestroyed = true;
        clearTimeout(this._tokenRefreshTimeout);
    }
    /**
	 * Checks whether the provided token follows the JSON Web Tokens (JWT) format.
	 *
	 * @param tokenValue The token to validate.
	 */ _validateTokenValue(tokenValue) {
        // The token must be a string.
        const isString = typeof tokenValue === 'string';
        // The token must be a plain string without quotes ("").
        const isPlainString = !/^".*"$/.test(tokenValue);
        // JWT token contains 3 parts: header, payload, and signature.
        // Each part is separated by a dot.
        const isJWTFormat = isString && tokenValue.split('.').length === 3;
        if (!(isPlainString && isJWTFormat)) {
            /**
			 * The provided token must follow the [JSON Web Tokens](https://jwt.io/introduction/) format.
			 *
			 * @error token-not-in-jwt-format
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('token-not-in-jwt-format', this);
        }
    }
    /**
	 * Registers a refresh token timeout for the time taken from token.
	 */ _registerRefreshTokenTimeout(timeoutTime) {
        clearTimeout(this._tokenRefreshTimeout);
        if (this._isDestroyed) {
            return;
        }
        const tokenRefreshTimeoutTime = timeoutTime || this._getTokenRefreshTimeoutTime();
        this._tokenRefreshTimeout = setTimeout(()=>{
            this.refreshToken();
        }, tokenRefreshTimeoutTime);
    }
    /**
	 * Returns token refresh timeout time calculated from expire time in the token payload.
	 *
	 * If the token parse fails or the token payload doesn't contain, the default DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME is returned.
	 */ _getTokenRefreshTimeoutTime() {
        try {
            const [, binaryTokenPayload] = this.value.split('.');
            const { exp: tokenExpireTime } = JSON.parse(atob(binaryTokenPayload));
            if (!tokenExpireTime) {
                return DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME;
            }
            const tokenRefreshTimeoutTime = Math.floor((tokenExpireTime * 1000 - Date.now()) / 2);
            return tokenRefreshTimeoutTime;
        } catch (err) {
            return DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME;
        }
    }
    /**
	 * Creates a initialized {@link module:cloud-services/token/token~Token} instance.
	 *
	 * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
	 * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
	 */ static create(tokenUrlOrRefreshToken, options = {}) {
        const token = new Token(tokenUrlOrRefreshToken, options);
        return token.init();
    }
}
/**
 * This function is called in a defined interval by the {@link ~Token} class. It also can be invoked manually.
 * It should return a promise, which resolves with the new token value.
 * If any error occurs it should return a rejected promise with an error message.
 */ function defaultRefreshToken(tokenUrl) {
    return new Promise((resolve, reject)=>{
        const xhr = new XMLHttpRequest();
        xhr.open('GET', tokenUrl);
        xhr.addEventListener('load', ()=>{
            const statusCode = xhr.status;
            const xhrResponse = xhr.response;
            if (statusCode < 200 || statusCode > 299) {
                /**
				 * Cannot download new token from the provided url.
				 *
				 * @error token-cannot-download-new-token
				 */ return reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('token-cannot-download-new-token', null));
            }
            return resolve(xhrResponse);
        });
        xhr.addEventListener('error', ()=>reject(new Error('Network Error')));
        xhr.addEventListener('abort', ()=>reject(new Error('Abort')));
        xhr.send();
    });
}
const BASE64_HEADER_REG_EXP = /^data:(\S*?);base64,/;
/**
 * FileUploader class used to upload single file.
 */ class FileUploader extends /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EmitterMixin"])() {
    /**
	 * A file that is being uploaded.
	 */ file;
    xhr;
    /**
	 * CKEditor Cloud Services access token.
	 */ _token;
    /**
	 * CKEditor Cloud Services API address.
	 */ _apiAddress;
    /**
	 * Creates `FileUploader` instance.
	 *
	 * @param fileOrData A blob object or a data string encoded with Base64.
	 * @param token Token used for authentication.
	 * @param apiAddress API address.
	 */ constructor(fileOrData, token, apiAddress){
        super();
        if (!fileOrData) {
            /**
			 * File must be provided as the first argument.
			 *
			 * @error fileuploader-missing-file
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('fileuploader-missing-file', null);
        }
        if (!token) {
            /**
			 * Token must be provided as the second argument.
			 *
			 * @error fileuploader-missing-token
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('fileuploader-missing-token', null);
        }
        if (!apiAddress) {
            /**
			 * Api address must be provided as the third argument.
			 *
			 * @error fileuploader-missing-api-address
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('fileuploader-missing-api-address', null);
        }
        this.file = _isBase64(fileOrData) ? _base64ToBlob(fileOrData) : fileOrData;
        this._token = token;
        this._apiAddress = apiAddress;
    }
    /**
	 * Registers callback on `progress` event.
	 */ onProgress(callback) {
        this.on('progress', (event, data)=>callback(data));
        return this;
    }
    /**
	 * Registers callback on `error` event. Event is called once when error occurs.
	 */ onError(callback) {
        this.once('error', (event, data)=>callback(data));
        return this;
    }
    /**
	 * Aborts upload process.
	 */ abort() {
        this.xhr.abort();
    }
    /**
	 * Sends XHR request to API.
	 */ send() {
        this._prepareRequest();
        this._attachXHRListeners();
        return this._sendRequest();
    }
    /**
	 * Prepares XHR request.
	 */ _prepareRequest() {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', this._apiAddress);
        xhr.setRequestHeader('Authorization', this._token.value);
        xhr.responseType = 'json';
        this.xhr = xhr;
    }
    /**
	 * Attaches listeners to the XHR.
	 */ _attachXHRListeners() {
        const xhr = this.xhr;
        const onError = (message)=>{
            return ()=>this.fire('error', message);
        };
        xhr.addEventListener('error', onError('Network Error'));
        xhr.addEventListener('abort', onError('Abort'));
        /* istanbul ignore else -- @preserve */ if (xhr.upload) {
            xhr.upload.addEventListener('progress', (event)=>{
                if (event.lengthComputable) {
                    this.fire('progress', {
                        total: event.total,
                        uploaded: event.loaded
                    });
                }
            });
        }
        xhr.addEventListener('load', ()=>{
            const statusCode = xhr.status;
            const xhrResponse = xhr.response;
            if (statusCode < 200 || statusCode > 299) {
                return this.fire('error', xhrResponse.message || xhrResponse.error);
            }
        });
    }
    /**
	 * Sends XHR request.
	 */ _sendRequest() {
        const formData = new FormData();
        const xhr = this.xhr;
        formData.append('file', this.file);
        return new Promise((resolve, reject)=>{
            xhr.addEventListener('load', ()=>{
                const statusCode = xhr.status;
                const xhrResponse = xhr.response;
                if (statusCode < 200 || statusCode > 299) {
                    if (xhrResponse.message) {
                        /**
						 * Uploading file failed.
						 *
						 * @error fileuploader-uploading-data-failed
						 */ return reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('fileuploader-uploading-data-failed', this, {
                            message: xhrResponse.message
                        }));
                    }
                    return reject(xhrResponse.error);
                }
                return resolve(xhrResponse);
            });
            xhr.addEventListener('error', ()=>reject(new Error('Network Error')));
            xhr.addEventListener('abort', ()=>reject(new Error('Abort')));
            xhr.send(formData);
        });
    }
}
/**
 * Transforms Base64 string data into file.
 *
 * @param base64 String data.
 */ function _base64ToBlob(base64, sliceSize = 512) {
    try {
        const contentType = base64.match(BASE64_HEADER_REG_EXP)[1];
        const base64Data = atob(base64.replace(BASE64_HEADER_REG_EXP, ''));
        const byteArrays = [];
        for(let offset = 0; offset < base64Data.length; offset += sliceSize){
            const slice = base64Data.slice(offset, offset + sliceSize);
            const byteNumbers = new Array(slice.length);
            for(let i = 0; i < slice.length; i++){
                byteNumbers[i] = slice.charCodeAt(i);
            }
            byteArrays.push(new Uint8Array(byteNumbers));
        }
        return new Blob(byteArrays, {
            type: contentType
        });
    } catch (error) {
        /**
		 * Problem with decoding Base64 image data.
		 *
		 * @error fileuploader-decoding-image-data-error
		 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('fileuploader-decoding-image-data-error', null);
    }
}
/**
 * Checks that string is Base64.
 */ function _isBase64(string) {
    if (typeof string !== 'string') {
        return false;
    }
    const match = string.match(BASE64_HEADER_REG_EXP);
    return !!(match && match.length);
}
/**
 * UploadGateway abstracts file uploads to CKEditor Cloud Services.
 */ class UploadGateway {
    /**
	 * CKEditor Cloud Services access token.
	 */ _token;
    /**
	 * CKEditor Cloud Services API address.
	 */ _apiAddress;
    /**
	 * Creates `UploadGateway` instance.
	 *
	 * @param token Token used for authentication.
	 * @param apiAddress API address.
	 */ constructor(token, apiAddress){
        if (!token) {
            /**
			 * Token must be provided.
			 *
			 * @error uploadgateway-missing-token
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('uploadgateway-missing-token', null);
        }
        if (!apiAddress) {
            /**
			 * Api address must be provided.
			 *
			 * @error uploadgateway-missing-api-address
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('uploadgateway-missing-api-address', null);
        }
        this._token = token;
        this._apiAddress = apiAddress;
    }
    /**
	 * Creates a {@link module:cloud-services/uploadgateway/fileuploader~FileUploader} instance that wraps
	 * file upload process. The file is being sent at a time when the
	 * {@link module:cloud-services/uploadgateway/fileuploader~FileUploader#send} method is called.
	 *
	 * ```ts
	 * const token = await Token.create( 'https://token-endpoint' );
	 * new UploadGateway( token, 'https://example.org' )
	 * 	.upload( 'FILE' )
	 * 	.onProgress( ( data ) => console.log( data ) )
	 * 	.send()
	 * 	.then( ( response ) => console.log( response ) );
	 * ```
	 *
	 * @param {Blob|String} fileOrData A blob object or a data string encoded with Base64.
	 * @returns {module:cloud-services/uploadgateway/fileuploader~FileUploader} Returns `FileUploader` instance.
	 */ upload(fileOrData) {
        return new FileUploader(fileOrData, this._token, this._apiAddress);
    }
}
/**
 * The `CloudServicesCore` plugin exposes the base API for communication with CKEditor Cloud Services.
 */ class CloudServicesCore extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ContextPlugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CloudServicesCore';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * Creates the {@link module:cloud-services/token/token~Token} instance.
	 *
	 * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
	 * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
	 * @param options.initValue Initial value of the token.
	 * @param options.autoRefresh Specifies whether to start the refresh automatically.
	 */ createToken(tokenUrlOrRefreshToken, options) {
        return new Token(tokenUrlOrRefreshToken, options);
    }
    /**
	 * Creates the {@link module:cloud-services/uploadgateway/uploadgateway~UploadGateway} instance.
	 *
	 * @param token Token used for authentication.
	 * @param apiAddress API address.
	 */ createUploadGateway(token, apiAddress) {
        return new UploadGateway(token, apiAddress);
    }
}
/**
 * Plugin introducing the integration between CKEditor 5 and CKEditor Cloud Services .
 *
 * It initializes the token provider based on
 * the {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig `config.cloudService`}.
 */ class CloudServices extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ContextPlugin"] {
    /**
	 * The authentication token URL for CKEditor Cloud Services or a callback to the token value promise. See the
	 * {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig#tokenUrl} for more details.
	 */ tokenUrl;
    /**
	 * The URL to which the files should be uploaded.
	 */ uploadUrl;
    /**
	 * The URL for web socket communication, used by the `RealTimeCollaborativeEditing` plugin. Every customer (organization in the CKEditor
	 * Ecosystem dashboard) has their own, unique URLs to communicate with CKEditor Cloud Services. The URL can be found in the
	 * CKEditor Ecosystem customer dashboard.
	 *
	 * Note: Unlike most plugins, `RealTimeCollaborativeEditing` is not included in any CKEditor 5 build and needs to be installed manually.
	 * Check [Collaboration overview](https://ckeditor.com/docs/ckeditor5/latest/features/collaboration/overview.html) for more details.
	 */ webSocketUrl;
    /**
	 * An optional parameter used for integration with CKEditor Cloud Services when uploading the editor build to cloud services.
	 *
	 * Whenever the editor build or the configuration changes, this parameter should be set to a new, unique value to differentiate
	 * the new bundle (build + configuration) from the old ones.
	 */ bundleVersion;
    /**
	 * Other plugins use this token for the authorization process. It handles token requesting and refreshing.
	 * Its value is `null` when {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig#tokenUrl} is not provided.
	 *
	 * @readonly
	 */ token = null;
    /**
	 * A map of token object instances keyed by the token URLs.
	 */ _tokens = new Map();
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CloudServices';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            CloudServicesCore
        ];
    }
    /**
	 * @inheritDoc
	 */ async init() {
        const config = this.context.config;
        const options = config.get('cloudServices') || {};
        for (const [key, value] of Object.entries(options)){
            this[key] = value;
        }
        if (!this.tokenUrl) {
            this.token = null;
            return;
        }
        // Initialization of the token may fail. By default, the token is being refreshed on the failure.
        // The problem is that if this happens here, then the token refresh interval will be executed even
        // after destroying the editor (as the exception was thrown from `init` method). To prevent that
        // behavior we need to catch the exception and destroy the uninitialized token instance.
        // See: https://github.com/ckeditor/ckeditor5/issues/17531
        const cloudServicesCore = this.context.plugins.get('CloudServicesCore');
        const uninitializedToken = cloudServicesCore.createToken(this.tokenUrl);
        try {
            this.token = await uninitializedToken.init();
            this._tokens.set(this.tokenUrl, this.token);
        } catch (error) {
            uninitializedToken.destroy();
            throw error;
        }
    }
    /**
	 * Registers an additional authentication token URL for CKEditor Cloud Services or a callback to the token value promise. See the
	 * {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig#tokenUrl} for more details.
	 *
	 * @param tokenUrl The authentication token URL for CKEditor Cloud Services or a callback to the token value promise.
	 */ async registerTokenUrl(tokenUrl) {
        // Reuse the token instance in case of multiple features using the same token URL.
        if (this._tokens.has(tokenUrl)) {
            return this.getTokenFor(tokenUrl);
        }
        const cloudServicesCore = this.context.plugins.get('CloudServicesCore');
        const token = await cloudServicesCore.createToken(tokenUrl).init();
        this._tokens.set(tokenUrl, token);
        return token;
    }
    /**
	 * Returns an authentication token provider previously registered by {@link #registerTokenUrl}.
	 *
	 * @param tokenUrl The authentication token URL for CKEditor Cloud Services or a callback to the token value promise.
	 */ getTokenFor(tokenUrl) {
        const token = this._tokens.get(tokenUrl);
        if (!token) {
            /**
			 * The provided `tokenUrl` was not registered by {@link module:cloud-services/cloudservices~CloudServices#registerTokenUrl}.
			 *
			 * @error cloudservices-token-not-registered
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('cloudservices-token-not-registered', this);
        }
        return token;
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        for (const token of this._tokens.values()){
            token.destroy();
        }
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-code-block/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "CodeBlock": (()=>CodeBlock),
    "CodeBlockEditing": (()=>CodeBlockEditing),
    "CodeBlockUI": (()=>CodeBlockUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$enter$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-enter/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$clipboard$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-clipboard/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
/**
 * Returns code block languages as defined in `config.codeBlock.languages` but processed:
 *
 * * To consider the editor localization, i.e. to display {@link module:code-block/codeblockconfig~CodeBlockLanguageDefinition}
 * in the correct language. There is no way to use {@link module:utils/locale~Locale#t} when the user
 * configuration is defined because the editor does not exist yet.
 * * To make sure each definition has a CSS class associated with it even if not specified
 * in the original configuration.
 */ function getNormalizedAndLocalizedLanguageDefinitions(editor) {
    const t = editor.t;
    const languageDefs = editor.config.get('codeBlock.languages');
    for (const def of languageDefs){
        if (def.label === 'Plain text') {
            def.label = t('Plain text');
        }
        if (def.class === undefined) {
            def.class = `language-${def.language}`;
        }
    }
    return languageDefs;
}
/**
 * Returns an object associating certain language definition properties with others. For instance:
 *
 * For:
 *
 * ```ts
 * const definitions = {
 * 	{ language: 'php', class: 'language-php', label: 'PHP' },
 * 	{ language: 'javascript', class: 'js', label: 'JavaScript' },
 * };
 *
 * getPropertyAssociation( definitions, 'class', 'language' );
 * ```
 *
 * returns:
 *
 * ```ts
 * {
 * 	'language-php': 'php',
 * 	'js': 'javascript'
 * }
 * ```
 *
 * and
 *
 * ```ts
 * getPropertyAssociation( definitions, 'language', 'label' );
 * ```
 *
 * returns:
 *
 * ```ts
 * {
 * 	'php': 'PHP',
 * 	'javascript': 'JavaScript'
 * }
 * ```
 */ function getPropertyAssociation(languageDefs, key, value) {
    const association = {};
    for (const def of languageDefs){
        if (key === 'class') {
            // Only the first class is considered.
            const newKey = def[key].split(' ').shift();
            association[newKey] = def[value];
        } else {
            association[def[key]] = def[value];
        }
    }
    return association;
}
/**
 * For a given model text node, it returns white spaces that precede other characters in that node.
 * This corresponds to the indentation part of the code block line.
 */ function getLeadingWhiteSpaces(textNode) {
    return textNode.data.match(/^(\s*)/)[0];
}
/**
 * For plain text containing the code (a snippet), it returns a document fragment containing
 * view text nodes separated by `<br>` elements (in place of new line characters "\n"), for instance:
 *
 * Input:
 *
 * ```ts
 * "foo()\n
 * bar()"
 * ```
 *
 * Output:
 *
 * ```html
 * <DocumentFragment>
 * 	"foo()"
 * 	<br/>
 * 	"bar()"
 * </DocumentFragment>
 * ```
 *
 * @param text The raw code text to be converted.
 */ function rawSnippetTextToViewDocumentFragment(writer, text) {
    const fragment = writer.createDocumentFragment();
    const textLines = text.split('\n');
    const items = textLines.reduce((nodes, line, lineIndex)=>{
        nodes.push(line);
        if (lineIndex < textLines.length - 1) {
            nodes.push(writer.createElement('br'));
        }
        return nodes;
    }, []);
    writer.appendChild(items, fragment);
    return fragment;
}
/**
 * Returns an array of all model positions within the selection that represent code block lines.
 *
 * If the selection is collapsed, it returns the exact selection anchor position:
 *
 * ```html
 * <codeBlock>[]foo</codeBlock>        ->     <codeBlock>^foo</codeBlock>
 * <codeBlock>foo[]bar</codeBlock>     ->     <codeBlock>foo^bar</codeBlock>
 * ```
 *
 * Otherwise, it returns positions **before** each text node belonging to all code blocks contained by the selection:
 *
 * ```html
 * <codeBlock>                                <codeBlock>
 *     foo[bar                                   ^foobar
 *     <softBreak></softBreak>         ->        <softBreak></softBreak>
 *     baz]qux                                   ^bazqux
 * </codeBlock>                               </codeBlock>
 * ```
 *
 * It also works across other non–code blocks:
 *
 * ```html
 * <codeBlock>                                <codeBlock>
 *     foo[bar                                   ^foobar
 * </codeBlock>                               </codeBlock>
 * <paragraph>text</paragraph>         ->     <paragraph>text</paragraph>
 * <codeBlock>                                <codeBlock>
 *     baz]qux                                   ^bazqux
 * </codeBlock>                               </codeBlock>
 * ```
 *
 * **Note:** The positions are in reverse order so they do not get outdated when iterating over them and
 * the writer inserts or removes elements at the same time.
 *
 * **Note:** The position is located after the leading white spaces in the text node.
 */ function getIndentOutdentPositions(model) {
    const selection = model.document.selection;
    const positions = [];
    // When the selection is collapsed, there's only one position we can indent or outdent.
    if (selection.isCollapsed) {
        return [
            selection.anchor
        ];
    }
    // When the selection is NOT collapsed, collect all positions starting before text nodes
    // (code lines) in any <codeBlock> within the selection.
    // Walk backward so positions we are about to collect here do not get outdated when
    // inserting or deleting using the writer.
    const walker = selection.getFirstRange().getWalker({
        ignoreElementEnd: true,
        direction: 'backward'
    });
    for (const { item } of walker){
        let node = item.is('$textProxy') ? item.textNode : item;
        const parent = node.parent;
        if (!parent.is('element', 'codeBlock') || node.is('element', 'softBreak')) {
            continue;
        }
        // For each item in code block, move backwards until the beginning of the line it is in is found.
        while(node.previousSibling && !node.previousSibling.is('element', 'softBreak')){
            node = node.previousSibling;
        }
        // Take the leading white spaces into account (only for text nodes).
        const startOffset = !node.is('$text') ? node.startOffset : node.startOffset + getLeadingWhiteSpaces(node).length;
        const position = model.createPositionAt(parent, startOffset);
        // Do not add the same position twice. Unfortunately using set doesn't deduplicate positions because
        // they are different objects.
        if (positions.every((pos)=>!pos.isEqual(position))) {
            positions.push(position);
        }
    }
    return positions;
}
/**
 * Checks if any of the blocks within the model selection is a code block.
 */ function isModelSelectionInCodeBlock(selection) {
    const firstBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(selection.getSelectedBlocks());
    return !!firstBlock && firstBlock.is('element', 'codeBlock');
}
/**
 * Checks if an {@link module:engine/model/element~Element Element} can become a code block.
 *
 * @param schema Model's schema.
 * @param element The element to be checked.
 * @returns Check result.
 */ function canBeCodeBlock(schema, element) {
    if (element.is('rootElement') || schema.isLimit(element)) {
        return false;
    }
    return schema.checkChild(element.parent, 'codeBlock');
}
/**
 * Get the translated message read by the screen reader when you enter or exit an element with your cursor.
 */ function getCodeBlockAriaAnnouncement(t, languageDefs, element, direction) {
    const languagesToLabels = getPropertyAssociation(languageDefs, 'language', 'label');
    const codeBlockLanguage = element.getAttribute('language');
    if (codeBlockLanguage in languagesToLabels) {
        const language = languagesToLabels[codeBlockLanguage];
        if (direction === 'enter') {
            return t('Entering %0 code snippet', language);
        }
        return t('Leaving %0 code snippet', language);
    }
    if (direction === 'enter') {
        return t('Entering code snippet');
    }
    return t('Leaving code snippet');
}
/**
 * For given position, finds the closest position that is at the beginning of a line of code and returns a text node that is at the
 * beginning of the line (or `null` if there's no text node at the beginning of a given line).
 *
 * Line beings at the start of a code block element and after each `softBreak` element.
 *
 * Note: even though code block doesn't allow inline elements other than `<softBreak>` by default, some features may overwrite this rule,
 * so such inline elements are taken into account.
 *
 * Some examples of expected results:
 *
 * ```
 * <codeBlock>^</codeBlock>                                ->   null
 * <codeBlock>^foobar</codeBlock>                          ->   <codeBlock>[foobar]</codeBlock>
 * <codeBlock>foobar^</codeBlock>                          ->   <codeBlock>[foobar]</codeBlock>
 * <codeBlock>foo^bar</codeBlock>                          ->   <codeBlock>[foobar]</codeBlock>
 * <codeBlock>foo^<softBreak />bar</codeBlock>             ->   <codeBlock>[foo]<softBreak />bar</codeBlock>
 * <codeBlock>foo<softBreak />bar^</codeBlock>             ->   <codeBlock>foo<softBreak />[bar]</codeBlock>
 * <codeBlock>foo<softBreak />b^ar</codeBlock>             ->   <codeBlock>foo<softBreak />[bar]</codeBlock>
 * <codeBlock>foo<softBreak />^bar</codeBlock>             ->   <codeBlock>foo<softBreak />[bar]</codeBlock>
 * <codeBlock>^<element /></codeBlock>                     ->   null
 * <codeBlock><element />^</codeBlock>                     ->   null
 * <codeBlock>foo^<element /></codeBlock>                  ->   <codeBlock>[foo]<element /></codeBlock>
 * <codeBlock>foo<element />^</codeBlock>                  ->   <codeBlock>[foo]<element /></codeBlock>
 * <codeBlock>foo<element />bar^</codeBlock>               ->   <codeBlock>[foo]<element />bar</codeBlock>
 * <codeBlock><element />bar^</codeBlock>                  ->   null
 * <codeBlock>foo<softBreak />^<softBreak /></codeBlock>   ->   null
 * <codeBlock>foo<softBreak />^<element /></codeBlock>     ->   null
 * <codeBlock>foo<softBreak /><element />^</codeBlock>     ->   null
 * <codeBlock>foo<softBreak />bar<element />^</codeBlock>  ->   <codeBlock>foo<softBreak />[bar]<element /></codeBlock>
 * <codeBlock>foo<softBreak /><element />ba^r</codeBlock>  ->   null
 * ```
 */ function getTextNodeAtLineStart(position, model) {
    // First, move position before a text node, if it is inside a text node.
    if (position.textNode) {
        position = model.createPositionBefore(position.textNode);
    }
    // Then, jump-back the position until it is before a `softBreak` or at the beginning of the `codeBlock`.
    while(position.nodeBefore && !position.nodeBefore.is('element', 'softBreak')){
        position = model.createPositionBefore(position.nodeBefore);
    }
    // Now, the position is at the beginning of a line.
    // Return a text node after the position, if there is one.
    const nodeAtStart = position.nodeAfter;
    return nodeAtStart && nodeAtStart.is('$text') ? nodeAtStart : null;
}
/**
 * The code block command plugin.
 */ class CodeBlockCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * Contains the last used language.
	 */ _lastLanguage;
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        this._lastLanguage = null;
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        this.value = this._getValue();
        this.isEnabled = this._checkEnabled();
    }
    /**
	 * Executes the command. When the command {@link #value is on}, all topmost code blocks within
	 * the selection will be removed. If it is off, all selected blocks will be flattened and
	 * wrapped by a code block.
	 *
	 * @fires execute
	 * @param options Command options.
	 * @param options.language The code block language.
	 * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply a code block,
	 * otherwise the command will remove the code block. If not set, the command will act basing on its current value.
	 * @param options.usePreviousLanguageChoice If set on `true` and the `options.language` is not specified, the command
	 * will apply the previous language (if the command was already executed) when inserting the `codeBlock` element.
	 */ execute(options = {}) {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const normalizedLanguagesDefs = getNormalizedAndLocalizedLanguageDefinitions(editor);
        const firstLanguageInConfig = normalizedLanguagesDefs[0];
        const blocks = Array.from(selection.getSelectedBlocks());
        const value = options.forceValue == undefined ? !this.value : options.forceValue;
        const language = getLanguage(options, this._lastLanguage, firstLanguageInConfig.language);
        model.change((writer)=>{
            if (value) {
                this._applyCodeBlock(writer, blocks, language);
            } else {
                this._removeCodeBlock(writer, blocks);
            }
        });
    }
    /**
	 * Checks the command's {@link #value}.
	 *
	 * @returns The current value.
	 */ _getValue() {
        const selection = this.editor.model.document.selection;
        const firstBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(selection.getSelectedBlocks());
        const isCodeBlock = !!(firstBlock && firstBlock.is('element', 'codeBlock'));
        return isCodeBlock ? firstBlock.getAttribute('language') : false;
    }
    /**
	 * Checks whether the command can be enabled in the current context.
	 *
	 * @returns Whether the command should be enabled.
	 */ _checkEnabled() {
        if (this.value) {
            return true;
        }
        const selection = this.editor.model.document.selection;
        const schema = this.editor.model.schema;
        const firstBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(selection.getSelectedBlocks());
        if (!firstBlock) {
            return false;
        }
        return canBeCodeBlock(schema, firstBlock);
    }
    _applyCodeBlock(writer, blocks, language) {
        this._lastLanguage = language;
        const schema = this.editor.model.schema;
        const allowedBlocks = blocks.filter((block)=>canBeCodeBlock(schema, block));
        for (const block of allowedBlocks){
            writer.rename(block, 'codeBlock');
            writer.setAttribute('language', language, block);
            schema.removeDisallowedAttributes([
                block
            ], writer);
            // Remove children of the  `codeBlock` element that are not allowed. See #9567.
            Array.from(block.getChildren()).filter((child)=>!schema.checkChild(block, child)).forEach((child)=>writer.remove(child));
        }
        allowedBlocks.reverse().forEach((currentBlock, i)=>{
            const nextBlock = allowedBlocks[i + 1];
            if (currentBlock.previousSibling === nextBlock) {
                writer.appendElement('softBreak', nextBlock);
                writer.merge(writer.createPositionBefore(currentBlock));
            }
        });
    }
    _removeCodeBlock(writer, blocks) {
        const codeBlocks = blocks.filter((block)=>block.is('element', 'codeBlock'));
        for (const block of codeBlocks){
            const range = writer.createRangeOn(block);
            for (const item of Array.from(range.getItems()).reverse()){
                if (item.is('element', 'softBreak') && item.parent.is('element', 'codeBlock')) {
                    const { position } = writer.split(writer.createPositionBefore(item));
                    const elementAfter = position.nodeAfter;
                    writer.rename(elementAfter, 'paragraph');
                    writer.removeAttribute('language', elementAfter);
                    writer.remove(item);
                }
            }
            writer.rename(block, 'paragraph');
            writer.removeAttribute('language', block);
        }
    }
}
/**
 * Picks the language for the new code block. If any language is passed as an option,
 * it will be returned. Else, if option usePreviousLanguageChoice is true and some
 * code block was already created (lastLanguage is not null) then previously used
 * language will be returned. If not, it will return default language.
 */ function getLanguage(options, lastLanguage, defaultLanguage) {
    if (options.language) {
        return options.language;
    }
    if (options.usePreviousLanguageChoice && lastLanguage) {
        return lastLanguage;
    }
    return defaultLanguage;
}
/**
 * The code block indentation increase command plugin.
 */ class IndentCodeBlockCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * A sequence of characters added to the line when the command is executed.
	 */ _indentSequence;
    constructor(editor){
        super(editor);
        this._indentSequence = editor.config.get('codeBlock.indentSequence');
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        this.isEnabled = this._checkEnabled();
    }
    /**
	 * Executes the command. When the command {@link #isEnabled is enabled}, the indentation of the
	 * code lines in the selection will be increased.
	 *
	 * @fires execute
	 */ execute() {
        const editor = this.editor;
        const model = editor.model;
        model.change((writer)=>{
            const positions = getIndentOutdentPositions(model);
            // Indent all positions, for instance assuming the indent sequence is 4x space ("    "):
            //
            //		<codeBlock>^foo</codeBlock>        ->       <codeBlock>    foo</codeBlock>
            //
            //		<codeBlock>foo^bar</codeBlock>     ->       <codeBlock>foo    bar</codeBlock>
            //
            // Also, when there is more than one position:
            //
            //		<codeBlock>
            //			^foobar
            //			<softBreak></softBreak>
            //			^bazqux
            //		</codeBlock>
            //
            //		->
            //
            //		<codeBlock>
            //			    foobar
            //			<softBreak></softBreak>
            //			    bazqux
            //		</codeBlock>
            //
            for (const position of positions){
                const indentSequenceTextElement = writer.createText(this._indentSequence);
                // Previously insertion was done by writer.insertText(). It was changed to insertContent() to enable
                // integration of code block with track changes. It's the easiest way of integration because insertContent()
                // is already integrated with track changes, but if it ever cause any troubles it can be reverted, however
                // some additional work will be required in track changes integration of code block.
                model.insertContent(indentSequenceTextElement, position);
            }
        });
    }
    /**
	 * Checks whether the command can be enabled in the current context.
	 */ _checkEnabled() {
        if (!this._indentSequence) {
            return false;
        }
        // Indent (forward) command is always enabled when there's any code block in the selection
        // because you can always indent code lines.
        return isModelSelectionInCodeBlock(this.editor.model.document.selection);
    }
}
/**
 * The code block indentation decrease command plugin.
 */ class OutdentCodeBlockCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * A sequence of characters removed from the line when the command is executed.
	 */ _indentSequence;
    constructor(editor){
        super(editor);
        this._indentSequence = editor.config.get('codeBlock.indentSequence');
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        this.isEnabled = this._checkEnabled();
    }
    /**
	 * Executes the command. When the command {@link #isEnabled is enabled}, the indentation of the
	 * code lines in the selection will be decreased.
	 *
	 * @fires execute
	 */ execute() {
        const editor = this.editor;
        const model = editor.model;
        model.change(()=>{
            const positions = getIndentOutdentPositions(model);
            // Outdent all positions, for instance assuming the indent sequence is 4x space ("    "):
            //
            //		<codeBlock>^foo</codeBlock>         ->       <codeBlock>foo</codeBlock>
            //
            //		<codeBlock>    ^bar</codeBlock>     ->       <codeBlock>bar</codeBlock>
            //
            // Also, when there is more than one position:
            //
            //		<codeBlock>
            //			    ^foobar
            //			<softBreak></softBreak>
            //			    ^bazqux
            //		</codeBlock>
            //
            //		->
            //
            //		<codeBlock>
            //			foobar
            //			<softBreak></softBreak>
            //			bazqux
            //		</codeBlock>
            for (const position of positions){
                const range = getLastOutdentableSequenceRange(model, position, this._indentSequence);
                if (range) {
                    // Previously deletion was done by writer.remove(). It was changed to deleteContent() to enable
                    // integration of code block with track changes. It's the easiest way of integration because deleteContent()
                    // is already integrated with track changes, but if it ever cause any troubles it can be reverted, however
                    // some additional work will be required in track changes integration of code block.
                    model.deleteContent(model.createSelection(range));
                }
            }
        });
    }
    /**
	 * Checks whether the command can be enabled in the current context.
	 *
	 * @private
	 * @returns {Boolean} Whether the command should be enabled.
	 */ _checkEnabled() {
        if (!this._indentSequence) {
            return false;
        }
        const model = this.editor.model;
        if (!isModelSelectionInCodeBlock(model.document.selection)) {
            return false;
        }
        // Outdent command can execute only when there is an indent character sequence
        // in some of the lines.
        return getIndentOutdentPositions(model).some((position)=>{
            return getLastOutdentableSequenceRange(model, position, this._indentSequence);
        });
    }
}
// For a position coming from `getIndentOutdentPositions()`, it returns the range representing
// the last occurrence of the indent sequence among the leading whitespaces of the code line the
// position represents.
//
// For instance, assuming the indent sequence is 4x space ("    "):
//
//		<codeBlock>foo^</codeBlock>                                 ->          null
//		<codeBlock>foo^<softBreak></softBreak>bar</codeBlock>       ->          null
//		<codeBlock>  ^foo</codeBlock>                               ->          null
//		<codeBlock>        ^foo</codeBlock>                         ->          <codeBlock>    [    ]foo</codeBlock>
//		<codeBlock>    ^foo    bar</codeBlock>                      ->          <codeBlock>[    ]foo    bar</codeBlock>
//
// @param {<module:engine/model/model~Model>} model
// @param {<module:engine/model/position~Position>} position
// @param {String} sequence
// @returns {<module:engine/model/range~Range>|null}
function getLastOutdentableSequenceRange(model, position, sequence) {
    // Positions start before each text node (code line). Get the node corresponding to the position.
    const nodeAtPosition = getTextNodeAtLineStart(position, model);
    if (!nodeAtPosition) {
        return null;
    }
    const leadingWhiteSpaces = getLeadingWhiteSpaces(nodeAtPosition);
    const lastIndexOfSequence = leadingWhiteSpaces.lastIndexOf(sequence);
    // For instance, assuming the indent sequence is 4x space ("    "):
    //
    //		<codeBlock>    	^foo</codeBlock>           ->             null
    //
    if (lastIndexOfSequence + sequence.length !== leadingWhiteSpaces.length) {
        return null;
    }
    // For instance, assuming the indent sequence is 4x space ("    "):
    //
    //		<codeBlock>  ^foo</codeBlock>           ->             null
    //
    if (lastIndexOfSequence === -1) {
        return null;
    }
    const { parent, startOffset } = nodeAtPosition;
    // Create a range that contains the **last** indent sequence among the leading whitespaces
    // of the line.
    //
    // For instance, assuming the indent sequence is 4x space ("    "):
    //
    //		<codeBlock>        ^foo</codeBlock>      ->     <codeBlock>    [    ]foo</codeBlock>
    //
    return model.createRange(model.createPositionAt(parent, startOffset + lastIndexOfSequence), model.createPositionAt(parent, startOffset + lastIndexOfSequence + sequence.length));
}
/**
 * A model-to-view (both editing and data) converter for the `codeBlock` element.
 *
 * Sample input:
 *
 * ```html
 * <codeBlock language="javascript">foo();<softBreak></softBreak>bar();</codeBlock>
 * ```
 *
 * Sample output (editing):
 *
 * ```html
 * <pre data-language="JavaScript"><code class="language-javascript">foo();<br />bar();</code></pre>
 * ```
 *
 * Sample output (data, see {@link module:code-block/converters~modelToDataViewSoftBreakInsertion}):
 *
 * ```html
 * <pre><code class="language-javascript">foo();\nbar();</code></pre>
 * ```
 *
 * @param languageDefs The normalized language configuration passed to the feature.
 * @param useLabels When `true`, the `<pre>` element will get a `data-language` attribute with a
 * human–readable label of the language. Used only in the editing.
 * @returns Returns a conversion callback.
 */ function modelToViewCodeBlockInsertion(model, languageDefs, useLabels = false) {
    // Language CSS classes:
    //
    //		{
    //			php: 'language-php',
    //			python: 'language-python',
    //			javascript: 'js',
    //			...
    //		}
    const languagesToClasses = getPropertyAssociation(languageDefs, 'language', 'class');
    // Language labels:
    //
    //		{
    //			php: 'PHP',
    //			python: 'Python',
    //			javascript: 'JavaScript',
    //			...
    //		}
    const languagesToLabels = getPropertyAssociation(languageDefs, 'language', 'label');
    return (evt, data, conversionApi)=>{
        const { writer, mapper, consumable } = conversionApi;
        if (!consumable.consume(data.item, 'insert')) {
            return;
        }
        const codeBlockLanguage = data.item.getAttribute('language');
        const targetViewPosition = mapper.toViewPosition(model.createPositionBefore(data.item));
        const preAttributes = {};
        // Attributes added only in the editing view.
        if (useLabels) {
            preAttributes['data-language'] = languagesToLabels[codeBlockLanguage];
            preAttributes.spellcheck = 'false';
        }
        const codeAttributes = languagesToClasses[codeBlockLanguage] ? {
            class: languagesToClasses[codeBlockLanguage]
        } : undefined;
        const code = writer.createContainerElement('code', codeAttributes);
        const pre = writer.createContainerElement('pre', preAttributes, code);
        writer.insert(targetViewPosition, pre);
        mapper.bindElements(data.item, code);
    };
}
/**
 * A model-to-data view converter for the new line (`softBreak`) separator.
 *
 * Sample input:
 *
 * ```html
 * <codeBlock ...>foo();<softBreak></softBreak>bar();</codeBlock>
 * ```
 *
 * Sample output:
 *
 * ```html
 * <pre><code ...>foo();\nbar();</code></pre>
 * ```
 *
 * @returns Returns a conversion callback.
 */ function modelToDataViewSoftBreakInsertion(model) {
    return (evt, data, conversionApi)=>{
        if (data.item.parent.name !== 'codeBlock') {
            return;
        }
        const { writer, mapper, consumable } = conversionApi;
        if (!consumable.consume(data.item, 'insert')) {
            return;
        }
        const position = mapper.toViewPosition(model.createPositionBefore(data.item));
        writer.insert(position, writer.createText('\n'));
    };
}
/**
 * A view-to-model converter for `<pre>` with the `<code>` HTML.
 *
 * Sample input:
 *
 * ```html
 * <pre><code class="language-javascript">foo();bar();</code></pre>
 * ```
 *
 * Sample output:
 *
 * ```html
 * <codeBlock language="javascript">foo();bar();</codeBlock>
 * ```
 *
 * @param languageDefs The normalized language configuration passed to the feature.
 * @returns Returns a conversion callback.
 */ function dataViewToModelCodeBlockInsertion(editingView, languageDefs) {
    // Language names associated with CSS classes:
    //
    //		{
    //			'language-php': 'php',
    //			'language-python': 'python',
    //			js: 'javascript',
    //			...
    //		}
    const classesToLanguages = getPropertyAssociation(languageDefs, 'class', 'language');
    const defaultLanguageName = languageDefs[0].language;
    return (evt, data, conversionApi)=>{
        const viewCodeElement = data.viewItem;
        const viewPreElement = viewCodeElement.parent;
        if (!viewPreElement || !viewPreElement.is('element', 'pre')) {
            return;
        }
        // In case of nested code blocks we don't want to convert to another code block.
        if (data.modelCursor.findAncestor('codeBlock')) {
            return;
        }
        const { consumable, writer } = conversionApi;
        if (!consumable.test(viewCodeElement, {
            name: true
        })) {
            return;
        }
        const codeBlock = writer.createElement('codeBlock');
        const viewChildClasses = [
            ...viewCodeElement.getClassNames()
        ];
        // As we're to associate each class with a model language, a lack of class (empty class) can be
        // also associated with a language if the language definition was configured so. Pushing an empty
        // string to make sure the association will work.
        if (!viewChildClasses.length) {
            viewChildClasses.push('');
        }
        // Figure out if any of the <code> element's class names is a valid programming
        // language class. If so, use it on the model element (becomes the language of the entire block).
        for (const className of viewChildClasses){
            const language = classesToLanguages[className];
            if (language) {
                writer.setAttribute('language', language, codeBlock);
                break;
            }
        }
        // If no language value was set, use the default language from the config.
        if (!codeBlock.hasAttribute('language')) {
            writer.setAttribute('language', defaultLanguageName, codeBlock);
        }
        // Convert children before inserting the code block element
        // to make sure that code block won't be splitted by any block.
        conversionApi.convertChildren(viewCodeElement, codeBlock);
        // Let's try to insert code block.
        if (!conversionApi.safeInsert(codeBlock, data.modelCursor)) {
            return;
        }
        consumable.consume(viewCodeElement, {
            name: true
        });
        conversionApi.updateConversionResult(codeBlock, data);
    };
}
/**
 * A view-to-model converter for new line characters in `<pre>`.
 *
 * Sample input:
 *
 * ```html
 * <pre><code class="language-javascript">foo();\nbar();</code></pre>
 * ```
 *
 * Sample output:
 *
 * ```html
 * <codeBlock language="javascript">foo();<softBreak></softBreak>bar();</codeBlock>
 * ```
 *
 * @returns {Function} Returns a conversion callback.
 */ function dataViewToModelTextNewlinesInsertion() {
    return (evt, data, { consumable, writer })=>{
        let position = data.modelCursor;
        // When node is already converted then do nothing.
        if (!consumable.test(data.viewItem)) {
            return;
        }
        // When not inside `codeBlock` then do nothing.
        if (!position.findAncestor('codeBlock')) {
            return;
        }
        consumable.consume(data.viewItem);
        const text = data.viewItem.data;
        const textLines = text.split('\n').map((data)=>writer.createText(data));
        const lastLine = textLines[textLines.length - 1];
        for (const node of textLines){
            writer.insert(node, position);
            position = position.getShiftedBy(node.offsetSize);
            if (node !== lastLine) {
                const softBreak = writer.createElement('softBreak');
                writer.insert(softBreak, position);
                position = writer.createPositionAfter(softBreak);
            }
        }
        data.modelRange = writer.createRange(data.modelCursor, position);
        data.modelCursor = position;
    };
}
/**
 * A view-to-model converter that handles orphan text nodes (white spaces, new lines, etc.)
 * that surround `<code>` inside `<pre>`.
 *
 * Sample input:
 *
 * ```html
 * // White spaces
 * <pre> <code>foo()</code> </pre>
 *
 * // White spaces
 * <pre>      <code>foo()</code>      </pre>
 *
 * // White spaces
 * <pre>			<code>foo()</code>			</pre>
 *
 * // New lines
 * <pre>
 * 	<code>foo()</code>
 * </pre>
 *
 * // Redundant text
 * <pre>ABC<code>foo()</code>DEF</pre>
 * ```
 *
 * Unified output for each case:
 *
 * ```html
 * <codeBlock language="plaintext">foo()</codeBlock>
 * ```
 *
 * @returns Returns a conversion callback.
 */ function dataViewToModelOrphanNodeConsumer() {
    return (evt, data, { consumable })=>{
        const preElement = data.viewItem;
        // Don't clean up nested pre elements. Their content should stay as it is, they are not upcasted
        // to code blocks.
        if (preElement.findAncestor('pre')) {
            return;
        }
        const preChildren = Array.from(preElement.getChildren());
        const childCodeElement = preChildren.find((node)=>node.is('element', 'code'));
        // <code>-less <pre>. It will not upcast to code block in the model, skipping.
        if (!childCodeElement) {
            return;
        }
        for (const child of preChildren){
            if (child === childCodeElement || !child.is('$text')) {
                continue;
            }
            // Consuming the orphan to remove it from the input data.
            // Second argument in `consumable.consume` is discarded for text nodes.
            consumable.consume(child, {
                name: true
            });
        }
    };
}
const DEFAULT_ELEMENT = 'paragraph';
/**
 * The editing part of the code block feature.
 *
 * Introduces the `'codeBlock'` command and the `'codeBlock'` model element.
 */ class CodeBlockEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CodeBlockEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$enter$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShiftEnter"]
        ];
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('codeBlock', {
            languages: [
                {
                    language: 'plaintext',
                    label: 'Plain text'
                },
                {
                    language: 'c',
                    label: 'C'
                },
                {
                    language: 'cs',
                    label: 'C#'
                },
                {
                    language: 'cpp',
                    label: 'C++'
                },
                {
                    language: 'css',
                    label: 'CSS'
                },
                {
                    language: 'diff',
                    label: 'Diff'
                },
                {
                    language: 'html',
                    label: 'HTML'
                },
                {
                    language: 'java',
                    label: 'Java'
                },
                {
                    language: 'javascript',
                    label: 'JavaScript'
                },
                {
                    language: 'php',
                    label: 'PHP'
                },
                {
                    language: 'python',
                    label: 'Python'
                },
                {
                    language: 'ruby',
                    label: 'Ruby'
                },
                {
                    language: 'typescript',
                    label: 'TypeScript'
                },
                {
                    language: 'xml',
                    label: 'XML'
                }
            ],
            // A single tab.
            indentSequence: '\t'
        });
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        const model = editor.model;
        const view = editor.editing.view;
        const normalizedLanguagesDefs = getNormalizedAndLocalizedLanguageDefinitions(editor);
        // The main command.
        editor.commands.add('codeBlock', new CodeBlockCommand(editor));
        // Commands that change the indentation.
        editor.commands.add('indentCodeBlock', new IndentCodeBlockCommand(editor));
        editor.commands.add('outdentCodeBlock', new OutdentCodeBlockCommand(editor));
        this.listenTo(view.document, 'tab', (evt, data)=>{
            const commandName = data.shiftKey ? 'outdentCodeBlock' : 'indentCodeBlock';
            const command = editor.commands.get(commandName);
            if (!command.isEnabled) {
                return;
            }
            editor.execute(commandName);
            data.stopPropagation();
            data.preventDefault();
            evt.stop();
        }, {
            context: 'pre'
        });
        schema.register('codeBlock', {
            allowWhere: '$block',
            allowChildren: '$text',
            // Disallow `$inlineObject` and its derivatives like `inlineWidget` inside `codeBlock` to ensure that only text,
            // not other inline elements like inline images, are allowed. This maintains the semantic integrity of code blocks.
            disallowChildren: '$inlineObject',
            allowAttributes: [
                'language'
            ],
            allowAttributesOf: '$listItem',
            isBlock: true
        });
        // Disallow formatting attributes on `codeBlock` children.
        schema.addAttributeCheck((context, attributeName)=>{
            const parent = context.getItem(context.length - 2);
            const isFormatting = schema.getAttributeProperties(attributeName).isFormatting;
            if (isFormatting && parent && parent.name == 'codeBlock') {
                return false;
            }
        });
        // Conversion.
        editor.editing.downcastDispatcher.on('insert:codeBlock', modelToViewCodeBlockInsertion(model, normalizedLanguagesDefs, true));
        editor.data.downcastDispatcher.on('insert:codeBlock', modelToViewCodeBlockInsertion(model, normalizedLanguagesDefs));
        editor.data.downcastDispatcher.on('insert:softBreak', modelToDataViewSoftBreakInsertion(model), {
            priority: 'high'
        });
        editor.data.upcastDispatcher.on('element:code', dataViewToModelCodeBlockInsertion(view, normalizedLanguagesDefs));
        editor.data.upcastDispatcher.on('text', dataViewToModelTextNewlinesInsertion());
        editor.data.upcastDispatcher.on('element:pre', dataViewToModelOrphanNodeConsumer(), {
            priority: 'high'
        });
        // Intercept the clipboard input (paste) when the selection is anchored in the code block and force the clipboard
        // data to be pasted as a single plain text. Otherwise, the code lines will split the code block and
        // "spill out" as separate paragraphs.
        this.listenTo(editor.editing.view.document, 'clipboardInput', (evt, data)=>{
            let insertionRange = model.createRange(model.document.selection.anchor);
            // Use target ranges in case this is a drop.
            if (data.targetRanges) {
                insertionRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);
            }
            if (!insertionRange.start.parent.is('element', 'codeBlock')) {
                return;
            }
            const text = data.dataTransfer.getData('text/plain');
            const writer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UpcastWriter"](editor.editing.view.document);
            // Pass the view fragment to the default clipboardInput handler.
            data.content = rawSnippetTextToViewDocumentFragment(writer, text);
        });
        if (editor.plugins.has('ClipboardPipeline')) {
            // Elements may have a plain textual representation (hence be present in the 'text/plain' data transfer),
            // but not be allowed in the code block.
            // Filter them out before inserting the content to the model.
            editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$clipboard$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClipboardPipeline"]).on('contentInsertion', (evt, data)=>{
                const model = editor.model;
                const selection = model.document.selection;
                if (!selection.anchor.parent.is('element', 'codeBlock')) {
                    return;
                }
                model.change((writer)=>{
                    const contentRange = writer.createRangeIn(data.content);
                    for (const item of [
                        ...contentRange.getItems()
                    ]){
                        // Remove all nodes disallowed in the code block.
                        if (item.is('node') && !schema.checkChild(selection.anchor, item)) {
                            writer.remove(item);
                        }
                    }
                });
            });
        }
        // Make sure multi–line selection is always wrapped in a code block when `getSelectedContent()`
        // is used (e.g. clipboard copy). Otherwise, only the raw text will be copied to the clipboard and,
        // upon next paste, this bare text will not be inserted as a code block, which is not the best UX.
        // Similarly, when the selection in a single line, the selected content should be an inline code
        // so it can be pasted later on and retain it's preformatted nature.
        this.listenTo(model, 'getSelectedContent', (evt, [selection])=>{
            const anchor = selection.anchor;
            if (selection.isCollapsed || !anchor.parent.is('element', 'codeBlock') || !anchor.hasSameParentAs(selection.focus)) {
                return;
            }
            model.change((writer)=>{
                const docFragment = evt.return;
                // fo[o<softBreak></softBreak>b]ar  ->   <codeBlock language="...">[o<softBreak></softBreak>b]<codeBlock>
                if (anchor.parent.is('element') && (docFragment.childCount > 1 || selection.containsEntireContent(anchor.parent))) {
                    const codeBlock = writer.createElement('codeBlock', anchor.parent.getAttributes());
                    writer.append(docFragment, codeBlock);
                    const newDocumentFragment = writer.createDocumentFragment();
                    writer.append(codeBlock, newDocumentFragment);
                    evt.return = newDocumentFragment;
                    return;
                }
                // "f[oo]"                          ->   <$text code="true">oo</text>
                const textNode = docFragment.getChild(0);
                if (schema.checkAttribute(textNode, 'code')) {
                    writer.setAttribute('code', true, textNode);
                }
            });
        });
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        const editor = this.editor;
        const commands = editor.commands;
        const indent = commands.get('indent');
        const outdent = commands.get('outdent');
        if (indent) {
            // Priority is highest due to integration with `IndentList` command of `List` plugin.
            // If selection is in a code block we give priority to it. This way list item cannot be indented
            // but if we would give priority to indenting list item then user would have to indent list item
            // as much as possible and only then he could indent code block.
            indent.registerChildCommand(commands.get('indentCodeBlock'), {
                priority: 'highest'
            });
        }
        if (outdent) {
            outdent.registerChildCommand(commands.get('outdentCodeBlock'));
        }
        // Customize the response to the <kbd>Enter</kbd> and <kbd>Shift</kbd>+<kbd>Enter</kbd>
        // key press when the selection is in the code block. Upon enter key press we can either
        // leave the block if it's "two or three enters" in a row or create a new code block line, preserving
        // previous line's indentation.
        this.listenTo(editor.editing.view.document, 'enter', (evt, data)=>{
            const positionParent = editor.model.document.selection.getLastPosition().parent;
            if (!positionParent.is('element', 'codeBlock')) {
                return;
            }
            if (!leaveBlockStartOnEnter(editor, data.isSoft) && !leaveBlockEndOnEnter(editor, data.isSoft)) {
                breakLineOnEnter(editor);
            }
            data.preventDefault();
            evt.stop();
        }, {
            context: 'pre'
        });
        this._initAriaAnnouncements();
    }
    /**
	 * Observe when user enters or leaves code block and set proper aria value in global live announcer.
	 * This allows screen readers to indicate when the user has entered and left the specified code block.
	 *
	 * @internal
	 */ _initAriaAnnouncements() {
        const { model, ui, t } = this.editor;
        const languageDefs = getNormalizedAndLocalizedLanguageDefinitions(this.editor);
        let lastFocusedCodeBlock = null;
        model.document.selection.on('change:range', ()=>{
            const focusParent = model.document.selection.focus.parent;
            if (!ui || lastFocusedCodeBlock === focusParent || !focusParent.is('element')) {
                return;
            }
            if (lastFocusedCodeBlock && lastFocusedCodeBlock.is('element', 'codeBlock')) {
                ui.ariaLiveAnnouncer.announce(getCodeBlockAriaAnnouncement(t, languageDefs, lastFocusedCodeBlock, 'leave'));
            }
            if (focusParent.is('element', 'codeBlock')) {
                ui.ariaLiveAnnouncer.announce(getCodeBlockAriaAnnouncement(t, languageDefs, focusParent, 'enter'));
            }
            lastFocusedCodeBlock = focusParent;
        });
    }
}
/**
 * Normally, when the Enter (or Shift+Enter) key is pressed, a soft line break is to be added to the
 * code block. Let's try to follow the indentation of the previous line when possible, for instance:
 *
 * ```html
 * // Before pressing enter (or shift enter)
 * <codeBlock>
 * "    foo()"[]                   // Indent of 4 spaces.
 * </codeBlock>
 *
 * // After pressing:
 * <codeBlock>
 * "    foo()"                 // Indent of 4 spaces.
 * <softBreak></softBreak>     // A new soft break created by pressing enter.
 * "    "[]                    // Retain the indent of 4 spaces.
 * </codeBlock>
 * ```
 */ function breakLineOnEnter(editor) {
    const model = editor.model;
    const modelDoc = model.document;
    // Use last position as other mechanisms (e.g. condition deciding whether this function should be called) also check that.
    const lastSelectionPosition = modelDoc.selection.getLastPosition();
    let leadingWhiteSpaces;
    const node = getTextNodeAtLineStart(lastSelectionPosition, model);
    // Figure out the indentation (white space chars) at the beginning of the line.
    if (node && node.is('$text')) {
        leadingWhiteSpaces = getLeadingWhiteSpaces(node);
    }
    // Keeping everything in a change block for a single undo step.
    editor.model.change((writer)=>{
        editor.execute('shiftEnter');
        // If the line before being broken in two had some indentation, let's retain it
        // in the new line.
        if (leadingWhiteSpaces) {
            writer.insertText(leadingWhiteSpaces, modelDoc.selection.anchor);
        }
    });
}
/**
 * Leave the code block when Enter (but NOT Shift+Enter) has been pressed twice at the beginning
 * of the code block:
 *
 * ```html
 * // Before:
 * <codeBlock>[]<softBreak></softBreak>foo</codeBlock>
 *
 * // After pressing:
 * <paragraph>[]</paragraph><codeBlock>foo</codeBlock>
 * ```
 *
 * @param isSoftEnter When `true`, enter was pressed along with <kbd>Shift</kbd>.
 * @returns `true` when selection left the block. `false` if stayed.
 */ function leaveBlockStartOnEnter(editor, isSoftEnter) {
    const model = editor.model;
    const modelDoc = model.document;
    const view = editor.editing.view;
    const lastSelectionPosition = modelDoc.selection.getLastPosition();
    const nodeAfter = lastSelectionPosition.nodeAfter;
    if (isSoftEnter || !modelDoc.selection.isCollapsed || !lastSelectionPosition.isAtStart) {
        return false;
    }
    if (!isSoftBreakNode(nodeAfter)) {
        return false;
    }
    // We're doing everything in a single change block to have a single undo step.
    editor.model.change((writer)=>{
        // "Clone" the <codeBlock> in the standard way.
        editor.execute('enter');
        // The cloned block exists now before the original code block.
        const newBlock = modelDoc.selection.anchor.parent.previousSibling;
        // Make the cloned <codeBlock> a regular <paragraph> (with clean attributes, so no language).
        writer.rename(newBlock, DEFAULT_ELEMENT);
        writer.setSelection(newBlock, 'in');
        editor.model.schema.removeDisallowedAttributes([
            newBlock
        ], writer);
        // Remove the <softBreak> that originally followed the selection position.
        writer.remove(nodeAfter);
    });
    // Eye candy.
    view.scrollToTheSelection();
    return true;
}
/**
 * Leave the code block when Enter (but NOT Shift+Enter) has been pressed twice at the end
 * of the code block:
 *
 * ```html
 * // Before:
 * <codeBlock>foo[]</codeBlock>
 *
 * // After first press:
 * <codeBlock>foo<softBreak></softBreak>[]</codeBlock>
 *
 * // After second press:
 * <codeBlock>foo</codeBlock><paragraph>[]</paragraph>
 * ```
 *
 * @param isSoftEnter When `true`, enter was pressed along with <kbd>Shift</kbd>.
 * @returns `true` when selection left the block. `false` if stayed.
 */ function leaveBlockEndOnEnter(editor, isSoftEnter) {
    const model = editor.model;
    const modelDoc = model.document;
    const view = editor.editing.view;
    const lastSelectionPosition = modelDoc.selection.getLastPosition();
    const nodeBefore = lastSelectionPosition.nodeBefore;
    let emptyLineRangeToRemoveOnEnter;
    if (isSoftEnter || !modelDoc.selection.isCollapsed || !lastSelectionPosition.isAtEnd || !nodeBefore || !nodeBefore.previousSibling) {
        return false;
    }
    // When the position is directly preceded by two soft breaks
    //
    //		<codeBlock>foo<softBreak></softBreak><softBreak></softBreak>[]</codeBlock>
    //
    // it creates the following range that will be cleaned up before leaving:
    //
    //		<codeBlock>foo[<softBreak></softBreak><softBreak></softBreak>]</codeBlock>
    //
    if (isSoftBreakNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling)) {
        emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling), model.createPositionAfter(nodeBefore));
    } else if (isEmptyishTextNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling) && isSoftBreakNode(nodeBefore.previousSibling.previousSibling)) {
        emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling.previousSibling), model.createPositionAfter(nodeBefore));
    } else if (isEmptyishTextNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling) && isEmptyishTextNode(nodeBefore.previousSibling.previousSibling) && nodeBefore.previousSibling.previousSibling && isSoftBreakNode(nodeBefore.previousSibling.previousSibling.previousSibling)) {
        emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling.previousSibling.previousSibling), model.createPositionAfter(nodeBefore));
    } else {
        return false;
    }
    // We're doing everything in a single change block to have a single undo step.
    editor.model.change((writer)=>{
        // Remove the last <softBreak>s and all white space characters that followed them.
        writer.remove(emptyLineRangeToRemoveOnEnter);
        // "Clone" the <codeBlock> in the standard way.
        editor.execute('enter');
        const newBlock = modelDoc.selection.anchor.parent;
        // Make the cloned <codeBlock> a regular <paragraph> (with clean attributes, so no language).
        writer.rename(newBlock, DEFAULT_ELEMENT);
        editor.model.schema.removeDisallowedAttributes([
            newBlock
        ], writer);
    });
    // Eye candy.
    view.scrollToTheSelection();
    return true;
}
function isEmptyishTextNode(node) {
    return node && node.is('$text') && !node.data.match(/\S/);
}
function isSoftBreakNode(node) {
    return node && node.is('element', 'softBreak');
}
/**
 * The code block UI plugin.
 *
 * Introduces the `'codeBlock'` dropdown.
 */ class CodeBlockUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CodeBlockUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        const componentFactory = editor.ui.componentFactory;
        const normalizedLanguageDefs = getNormalizedAndLocalizedLanguageDefinitions(editor);
        const itemDefinitions = this._getLanguageListItemDefinitions(normalizedLanguageDefs);
        const command = editor.commands.get('codeBlock');
        componentFactory.add('codeBlock', (locale)=>{
            const dropdownView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDropdown"])(locale, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SplitButtonView"]);
            const splitButtonView = dropdownView.buttonView;
            const accessibleLabel = t('Insert code block');
            splitButtonView.set({
                label: accessibleLabel,
                tooltip: true,
                icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].codeBlock,
                isToggleable: true
            });
            splitButtonView.bind('isOn').to(command, 'value', (value)=>!!value);
            splitButtonView.on('execute', ()=>{
                editor.execute('codeBlock', {
                    usePreviousLanguageChoice: true
                });
                editor.editing.view.focus();
            });
            dropdownView.on('execute', (evt)=>{
                editor.execute('codeBlock', {
                    language: evt.source._codeBlockLanguage,
                    forceValue: true
                });
                editor.editing.view.focus();
            });
            dropdownView.class = 'ck-code-block-dropdown';
            dropdownView.bind('isEnabled').to(command);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addListToDropdown"])(dropdownView, itemDefinitions, {
                role: 'menu',
                ariaLabel: accessibleLabel
            });
            return dropdownView;
        });
        componentFactory.add('menuBar:codeBlock', (locale)=>{
            const menuView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuView"](locale);
            menuView.buttonView.set({
                role: 'menuitem',
                label: t('Code block'),
                icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].codeBlock
            });
            menuView.bind('isEnabled').to(command);
            const listView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListView"](locale);
            listView.set({
                ariaLabel: t('Insert code block')
            });
            for (const definition of itemDefinitions){
                const listItemView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemView"](locale, menuView);
                const buttonView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"](locale);
                buttonView.bind(...Object.keys(definition.model)).to(definition.model);
                buttonView.set({
                    isToggleable: true,
                    role: 'menuitemcheckbox'
                });
                buttonView.delegate('execute').to(menuView);
                buttonView.on('execute', ()=>{
                    editor.execute('codeBlock', {
                        language: definition.model._codeBlockLanguage,
                        forceValue: command.value == definition.model._codeBlockLanguage ? false : true
                    });
                    editor.editing.view.focus();
                });
                listItemView.children.add(buttonView);
                listView.items.add(listItemView);
            }
            menuView.panelView.children.add(listView);
            return menuView;
        });
    }
    /**
	 * A helper returning a collection of the `codeBlock` dropdown items representing languages
	 * available for the user to choose from.
	 */ _getLanguageListItemDefinitions(normalizedLanguageDefs) {
        const editor = this.editor;
        const command = editor.commands.get('codeBlock');
        const itemDefinitions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"]();
        for (const languageDef of normalizedLanguageDefs){
            const definition = {
                type: 'button',
                model: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewModel"]({
                    _codeBlockLanguage: languageDef.language,
                    label: languageDef.label,
                    role: 'menuitemradio',
                    withText: true
                })
            };
            definition.model.bind('isOn').to(command, 'value', (value)=>{
                return value === definition.model._codeBlockLanguage;
            });
            itemDefinitions.add(definition);
        }
        return itemDefinitions;
    }
}
/**
 * The code block plugin.
 *
 * For more information about this feature check the {@glink api/code-block package page} and the
 * {@glink features/code-blocks code block} feature guide.
 *
 * This is a "glue" plugin that loads the {@link module:code-block/codeblockediting~CodeBlockEditing code block editing feature}
 * and the {@link module:code-block/codeblockui~CodeBlockUI code block UI feature}.
 */ class CodeBlock extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            CodeBlockEditing,
            CodeBlockUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CodeBlock';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-easy-image/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "CloudServicesUploadAdapter": (()=>CloudServicesUploadAdapter),
    "EasyImage": (()=>EasyImage)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$upload$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-upload/dist/index.js [app-client] (ecmascript)");
;
;
;
/**
 * A plugin that enables upload to [CKEditor Cloud Services](https://ckeditor.com/ckeditor-cloud-services/).
 *
 * It is mainly used by the {@link module:easy-image/easyimage~EasyImage} feature.
 *
 * After enabling this adapter you need to configure the CKEditor Cloud Services integration through
 * {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig `config.cloudServices`}.
 */ class CloudServicesUploadAdapter extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    _uploadGateway;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'CloudServicesUploadAdapter';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            'CloudServices',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$upload$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileRepository"]
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const cloudServices = editor.plugins.get('CloudServices');
        const token = cloudServices.token;
        const uploadUrl = cloudServices.uploadUrl;
        if (!token) {
            return;
        }
        const cloudServicesCore = editor.plugins.get('CloudServicesCore');
        this._uploadGateway = cloudServicesCore.createUploadGateway(token, uploadUrl);
        editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$upload$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileRepository"]).createUploadAdapter = (loader)=>{
            return new Adapter(this._uploadGateway, loader);
        };
    }
}
class Adapter {
    uploadGateway;
    loader;
    fileUploader;
    constructor(uploadGateway, loader){
        this.uploadGateway = uploadGateway;
        this.loader = loader;
    }
    upload() {
        return this.loader.file.then((file)=>{
            this.fileUploader = this.uploadGateway.upload(file);
            this.fileUploader.on('progress', (evt, data)=>{
                this.loader.uploadTotal = data.total;
                this.loader.uploaded = data.uploaded;
            });
            return this.fileUploader.send();
        });
    }
    abort() {
        this.fileUploader.abort();
    }
}
/**
 * The Easy Image feature, which makes the image upload in CKEditor 5 possible with virtually zero
 * server setup. A part of the [CKEditor Cloud Services](https://ckeditor.com/ckeditor-cloud-services/)
 * family.
 *
 * This is a "glue" plugin which enables:
 *
 * * {@link module:easy-image/cloudservicesuploadadapter~CloudServicesUploadAdapter}.
 *
 * This plugin requires plugin to be present in the editor configuration:
 *
 * * {@link module:image/image~Image},
 * * {@link module:image/imageupload~ImageUpload},
 *
 * See the [Easy Image Quick Start guide](https://ckeditor.com/docs/cs/latest/guides/easy-image/quick-start.html) to learn how to configure
 * and use this feature.
 *
 * Check out the {@glink features/images/image-upload/image-upload comprehensive "Image upload" guide} to learn about
 * other ways to upload images into CKEditor 5.
 *
 * **Note**: After enabling the Easy Image plugin you need to configure the
 * [CKEditor Cloud Services](https://ckeditor.com/ckeditor-cloud-services/)
 * integration through {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig `config.cloudServices`}.
 */ class EasyImage extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'EasyImage';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            CloudServicesUploadAdapter,
            'ImageUpload'
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        if (!editor.plugins.has('ImageBlockEditing') && !editor.plugins.has('ImageInlineEditing')) {
            /**
			 * The Easy Image feature requires one of the following plugins to be loaded to work correctly:
			 *
			 * * {@link module:image/imageblock~ImageBlock},
			 * * {@link module:image/imageinline~ImageInline},
			 * * {@link module:image/image~Image} (loads both `ImageBlock` and `ImageInline`)
			 *
			 * Please make sure your editor configuration is correct.
			 *
			 * @error easy-image-image-feature-missing
			 * @param {module:core/editor/editor~Editor} editor
			 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('easy-image-image-feature-missing', editor);
        }
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-editor-balloon/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "BalloonEditor": (()=>BalloonEditor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/isElement.js [app-client] (ecmascript) <export default as isElement>");
;
;
;
;
;
/**
 * The balloon editor UI class.
 */ class BalloonEditorUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EditorUI"] {
    /**
	 * The main (top–most) view of the editor UI.
	 */ view;
    /**
	 * Creates an instance of the balloon editor UI class.
	 *
	 * @param editor The editor instance.
	 * @param view The view of the UI.
	 */ constructor(editor, view){
        super(editor);
        this.view = view;
    }
    /**
	 * @inheritDoc
	 */ get element() {
        return this.view.editable.element;
    }
    /**
	 * Initializes the UI.
	 */ init() {
        const editor = this.editor;
        const view = this.view;
        const editingView = editor.editing.view;
        const editable = view.editable;
        const editingRoot = editingView.document.getRoot();
        // The editable UI and editing root should share the same name. Then name is used
        // to recognize the particular editable, for instance in ARIA attributes.
        editable.name = editingRoot.rootName;
        view.render();
        // The editable UI element in DOM is available for sure only after the editor UI view has been rendered.
        // But it can be available earlier if a DOM element has been passed to BalloonEditor.create().
        const editableElement = editable.element;
        // Register the editable UI view in the editor. A single editor instance can aggregate multiple
        // editable areas (roots) but the balloon editor has only one.
        this.setEditableElement(editable.name, editableElement);
        // Let the editable UI element respond to the changes in the global editor focus
        // tracker. It has been added to the same tracker a few lines above but, in reality, there are
        // many focusable areas in the editor, like balloons, toolbars or dropdowns and as long
        // as they have focus, the editable should act like it is focused too (although technically
        // it isn't), e.g. by setting the proper CSS class, visually announcing focus to the user.
        // Doing otherwise will result in editable focus styles disappearing, once e.g. the
        // toolbar gets focused.
        editable.bind('isFocused').to(this.focusTracker);
        // Bind the editable UI element to the editing view, making it an end– and entry–point
        // of the editor's engine. This is where the engine meets the UI.
        editingView.attachDomRoot(editableElement);
        this._initPlaceholder();
        this._initMenuBar(this.view.menuBarView);
        this.fire('ready');
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        const view = this.view;
        const editingView = this.editor.editing.view;
        if (editingView.getDomRoot(view.editable.name)) {
            editingView.detachDomRoot(view.editable.name);
        }
        view.destroy();
    }
    /**
	 * Enable the placeholder text on the editing root.
	 */ _initPlaceholder() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        const editingRoot = editingView.document.getRoot();
        const placeholder = editor.config.get('placeholder');
        if (placeholder) {
            const placeholderText = typeof placeholder === 'string' ? placeholder : placeholder[editingRoot.rootName];
            if (placeholderText) {
                editingRoot.placeholder = placeholderText;
            }
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enablePlaceholder"])({
            view: editingView,
            element: editingRoot,
            isDirectHost: false,
            keepOnFocus: true
        });
    }
}
/**
 * Contextual editor UI view. Uses the {@link module:ui/editableui/inline/inlineeditableuiview~InlineEditableUIView}.
 */ class BalloonEditorUIView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EditorUIView"] {
    /**
	 * Editable UI view.
	 */ editable;
    /**
	 * Menu bar view instance.
	 */ menuBarView;
    /**
	 * Creates an instance of the balloon editor UI view.
	 *
	 * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
	 * @param editingView The editing view instance this view is related to.
	 * @param editableElement The editable element. If not specified, it will be automatically created by
	 * {@link module:ui/editableui/editableuiview~EditableUIView}. Otherwise, the given element will be used.
	 * @param label When set, this value will be used as an accessible `aria-label` of the
	 * {@link module:ui/editableui/editableuiview~EditableUIView editable view}.
	 */ constructor(locale, editingView, editableElement, label){
        super(locale);
        this.editable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InlineEditableUIView"](locale, editingView, editableElement, {
            label
        });
        this.menuBarView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarView"](locale);
        this.menuBarView.extendTemplate({
            attributes: {
                class: [
                    'ck-reset_all',
                    'ck-rounded-corners'
                ],
                dir: locale.uiLanguageDirection
            }
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        this.registerChild(this.editable);
        this.registerChild(this.menuBarView);
    }
}
/**
 * The balloon editor implementation (Medium-like editor).
 * It uses an inline editable and a toolbar based on the {@link module:ui/toolbar/balloon/balloontoolbar~BalloonToolbar}.
 * See the {@glink examples/builds/balloon-editor demo}.
 *
 * In order to create a balloon editor instance, use the static
 * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`} method.
 */ class BalloonEditor extends /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementApiMixin"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"]) {
    /**
	 * @inheritDoc
	 */ static get editorName() {
        return 'BalloonEditor';
    }
    /**
	 * @inheritDoc
	 */ ui;
    /**
	 * Creates an instance of the balloon editor.
	 *
	 * **Note:** do not use the constructor to create editor instances. Use the static
	 * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`} method instead.
	 *
	 * @param sourceElementOrData The DOM element that will be the source for the created editor
	 * (on which the editor will be initialized) or initial data for the editor. For more information see
	 * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}.
	 * @param config The editor configuration.
	 */ constructor(sourceElementOrData, config = {}){
        // If both `config.initialData` is set and initial data is passed as the constructor parameter, then throw.
        if (!isElement(sourceElementOrData) && config.initialData !== undefined) {
            // Documented in core/editor/editorconfig.jsdoc.
            // eslint-disable-next-line ckeditor5-rules/ckeditor-error-message
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('editor-create-initial-data', null);
        }
        super(config);
        if (this.config.get('initialData') === undefined) {
            this.config.set('initialData', getInitialData(sourceElementOrData));
        }
        if (isElement(sourceElementOrData)) {
            this.sourceElement = sourceElementOrData;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["secureSourceElement"])(this, sourceElementOrData);
        }
        const plugins = this.config.get('plugins');
        plugins.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BalloonToolbar"]);
        this.config.set('plugins', plugins);
        this.config.define('balloonToolbar', this.config.get('toolbar'));
        this.model.document.createRoot();
        const view = new BalloonEditorUIView(this.locale, this.editing.view, this.sourceElement, this.config.get('label'));
        this.ui = new BalloonEditorUI(this, view);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachToForm"])(this);
    }
    /**
	 * Destroys the editor instance, releasing all resources used by it.
	 *
	 * Updates the original editor element with the data if the
	 * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
	 * configuration option is set to `true`.
	 */ destroy() {
        // Cache the data, then destroy.
        // It's safe to assume that the model->view conversion will not work after super.destroy().
        const data = this.getData();
        this.ui.destroy();
        return super.destroy().then(()=>{
            if (this.sourceElement) {
                this.updateSourceElement(data);
            }
        });
    }
    /**
	 * Creates a new balloon editor instance.
	 *
	 * There are three general ways how the editor can be initialized.
	 *
	 * # Using an existing DOM element (and loading data from it)
	 *
	 * You can initialize the editor using an existing DOM element:
	 *
	 * ```ts
	 * BalloonEditor
	 * 	.create( document.querySelector( '#editor' ) )
	 * 	.then( editor => {
	 * 		console.log( 'Editor was initialized', editor );
	 * 	} )
	 * 	.catch( err => {
	 * 		console.error( err.stack );
	 * 	} );
	 * ```
	 *
	 * The element's content will be used as the editor data and the element will become the editable element.
	 *
	 * # Creating a detached editor
	 *
	 * Alternatively, you can initialize the editor by passing the initial data directly as a string.
	 * In this case, the editor will render an element that must be inserted into the DOM for the editor to work properly:
	 *
	 * ```ts
	 * BalloonEditor
	 * 	.create( '<p>Hello world!</p>' )
	 * 	.then( editor => {
	 * 		console.log( 'Editor was initialized', editor );
	 *
	 * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
	 * 		document.body.appendChild( editor.ui.element );
	 * 	} )
	 * 	.catch( err => {
	 * 		console.error( err.stack );
	 * 	} );
	 * ```
	 *
	 * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
	 * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
	 *
	 * # Using an existing DOM element (and data provided in `config.initialData`)
	 *
	 * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
	 *
	 * ```ts
	 * BalloonEditor
	 * 	.create( document.querySelector( '#editor' ), {
	 * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
	 * 	} )
	 * 	.then( editor => {
	 * 		console.log( 'Editor was initialized', editor );
	 * 	} )
	 * 	.catch( err => {
	 * 		console.error( err.stack );
	 * 	} );
	 * ```
	 *
	 * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
	 * makes it difficult to set the content of the source element.
	 *
	 * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
	 *
	 * # Configuring the editor
	 *
	 * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
	 * customizing plugins, toolbar and more.
	 *
	 * # Using the editor from source
	 *
	 * If you want to use the balloon editor,
	 * you need to define the list of
	 * {@link module:core/editor/editorconfig~EditorConfig#plugins plugins to be initialized} and
	 * {@link module:core/editor/editorconfig~EditorConfig#toolbar toolbar items}.
	 *
	 * @param sourceElementOrData The DOM element that will be the source for the created editor
	 * or the editor's initial data.
	 *
	 * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization.
	 * The editor data will be set back to the original element once the editor is destroyed only if the
	 * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
	 * option is set to `true`.
	 *
	 * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
	 * It is available under the {@link module:editor-balloon/ballooneditorui~BalloonEditorUI#element `editor.ui.element`} property.
	 *
	 * @param config The editor configuration.
	 * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
	 */ static create(sourceElementOrData, config = {}) {
        return new Promise((resolve)=>{
            if (isElement(sourceElementOrData) && sourceElementOrData.tagName === 'TEXTAREA') {
                // Documented in core/editor/editor.js
                // eslint-disable-next-line ckeditor5-rules/ckeditor-error-message
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('editor-wrong-element', null);
            }
            const editor = new this(sourceElementOrData, config);
            resolve(editor.initPlugins().then(()=>editor.ui.init()).then(()=>editor.data.init(editor.config.get('initialData'))).then(()=>editor.fire('ready')).then(()=>editor));
        });
    }
}
function getInitialData(sourceElementOrData) {
    return isElement(sourceElementOrData) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDataFromElement"])(sourceElementOrData) : sourceElementOrData;
}
function isElement(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__["isElement"])(value);
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-editor-classic/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "ClassicEditor": (()=>ClassicEditor),
    "ClassicEditorUIView": (()=>ClassicEditorUIView)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/isElement.js [app-client] (ecmascript) <export default as isElement>");
;
;
;
;
;
/**
 * The classic editor UI class.
 */ class ClassicEditorUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EditorUI"] {
    /**
	 * The main (top–most) view of the editor UI.
	 */ view;
    /**
	 * A normalized `config.toolbar` object.
	 */ _toolbarConfig;
    /**
	 * The element replacer instance used to hide the editor's source element.
	 */ _elementReplacer;
    /**
	 * Creates an instance of the classic editor UI class.
	 *
	 * @param editor The editor instance.
	 * @param view The view of the UI.
	 */ constructor(editor, view){
        super(editor);
        this.view = view;
        this._toolbarConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeToolbarConfig"])(editor.config.get('toolbar'));
        this._elementReplacer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementReplacer"]();
        this.listenTo(editor.editing.view, 'scrollToTheSelection', this._handleScrollToTheSelectionWithStickyPanel.bind(this));
    }
    /**
	 * @inheritDoc
	 */ get element() {
        return this.view.element;
    }
    /**
	 * Initializes the UI.
	 *
	 * @param replacementElement The DOM element that will be the source for the created editor.
	 */ init(replacementElement) {
        const editor = this.editor;
        const view = this.view;
        const editingView = editor.editing.view;
        const editable = view.editable;
        const editingRoot = editingView.document.getRoot();
        // The editable UI and editing root should share the same name. Then name is used
        // to recognize the particular editable, for instance in ARIA attributes.
        editable.name = editingRoot.rootName;
        view.render();
        // The editable UI element in DOM is available for sure only after the editor UI view has been rendered.
        // But it can be available earlier if a DOM element has been passed to BalloonEditor.create().
        const editableElement = editable.element;
        // Register the editable UI view in the editor. A single editor instance can aggregate multiple
        // editable areas (roots) but the classic editor has only one.
        this.setEditableElement(editable.name, editableElement);
        // Let the editable UI element respond to the changes in the global editor focus
        // tracker. It has been added to the same tracker a few lines above but, in reality, there are
        // many focusable areas in the editor, like balloons, toolbars or dropdowns and as long
        // as they have focus, the editable should act like it is focused too (although technically
        // it isn't), e.g. by setting the proper CSS class, visually announcing focus to the user.
        // Doing otherwise will result in editable focus styles disappearing, once e.g. the
        // toolbar gets focused.
        view.editable.bind('isFocused').to(this.focusTracker);
        // Bind the editable UI element to the editing view, making it an end– and entry–point
        // of the editor's engine. This is where the engine meets the UI.
        editingView.attachDomRoot(editableElement);
        // If an element containing the initial data of the editor was provided, replace it with
        // an editor instance's UI in DOM until the editor is destroyed. For instance, a <textarea>
        // can be such element.
        if (replacementElement) {
            this._elementReplacer.replace(replacementElement, this.element);
        }
        this._initPlaceholder();
        this._initToolbar();
        if (view.menuBarView) {
            this._initMenuBar(view.menuBarView);
        }
        this._initDialogPluginIntegration();
        this._initContextualBalloonIntegration();
        this.fire('ready');
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        const view = this.view;
        const editingView = this.editor.editing.view;
        this._elementReplacer.restore();
        if (editingView.getDomRoot(view.editable.name)) {
            editingView.detachDomRoot(view.editable.name);
        }
        view.destroy();
    }
    /**
	 * Initializes the editor toolbar.
	 */ _initToolbar() {
        const view = this.view;
        // Set–up the sticky panel with toolbar.
        view.stickyPanel.bind('isActive').to(this.focusTracker, 'isFocused');
        view.stickyPanel.limiterElement = view.element;
        view.stickyPanel.bind('viewportTopOffset').to(this, 'viewportOffset', ({ top })=>top || 0);
        view.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory);
        // Register the toolbar so it becomes available for Alt+F10 and Esc navigation.
        this.addToolbar(view.toolbar);
    }
    /**
	 * Enable the placeholder text on the editing root.
	 */ _initPlaceholder() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        const editingRoot = editingView.document.getRoot();
        const sourceElement = editor.sourceElement;
        let placeholderText;
        const placeholder = editor.config.get('placeholder');
        if (placeholder) {
            placeholderText = typeof placeholder === 'string' ? placeholder : placeholder[this.view.editable.name];
        }
        if (!placeholderText && sourceElement && sourceElement.tagName.toLowerCase() === 'textarea') {
            placeholderText = sourceElement.getAttribute('placeholder');
        }
        if (placeholderText) {
            editingRoot.placeholder = placeholderText;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enablePlaceholder"])({
            view: editingView,
            element: editingRoot,
            isDirectHost: false,
            keepOnFocus: true
        });
    }
    /**
	 * Provides an integration between the sticky toolbar and {@link module:ui/panel/balloon/contextualballoon contextual balloon plugin}.
	 * It allows the contextual balloon to consider the height of the
	 * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel}. It prevents the balloon from overlapping
	 * the sticky toolbar by adjusting the balloon's position using viewport offset configuration.
	 */ _initContextualBalloonIntegration() {
        if (!this.editor.plugins.has('ContextualBalloon')) {
            return;
        }
        const { stickyPanel } = this.view;
        const contextualBalloon = this.editor.plugins.get('ContextualBalloon');
        contextualBalloon.on('getPositionOptions', (evt)=>{
            const position = evt.return;
            if (!position || !stickyPanel.isSticky || !stickyPanel.element) {
                return;
            }
            // Measure toolbar (and menu bar) height.
            const stickyPanelHeight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](stickyPanel.element).height;
            // Handle edge case when the target element is larger than the limiter.
            // It's an issue because the contextual balloon can overlap top table cells when the table is larger than the viewport
            // and it's placed at the top of the editor. It's better to overlap toolbar in that situation.
            // Check this issue: https://github.com/ckeditor/ckeditor5/issues/15744
            const target = typeof position.target === 'function' ? position.target() : position.target;
            const limiter = typeof position.limiter === 'function' ? position.limiter() : position.limiter;
            if (target && limiter && new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](target).height >= new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](limiter).height - stickyPanelHeight) {
                return;
            }
            // Ensure that viewport offset is present, it can be undefined according to the typing.
            const viewportOffsetConfig = {
                ...position.viewportOffsetConfig
            };
            const newTopViewportOffset = (viewportOffsetConfig.top || 0) + stickyPanelHeight;
            evt.return = {
                ...position,
                viewportOffsetConfig: {
                    ...viewportOffsetConfig,
                    top: newTopViewportOffset
                }
            };
        }, {
            priority: 'low'
        });
        // Update balloon position when the toolbar becomes sticky or when ui viewportOffset changes.
        const updateBalloonPosition = ()=>{
            if (contextualBalloon.visibleView) {
                contextualBalloon.updatePosition();
            }
        };
        this.listenTo(stickyPanel, 'change:isSticky', updateBalloonPosition);
        this.listenTo(this.editor.ui, 'change:viewportOffset', updateBalloonPosition);
    }
    /**
	 * Provides an integration between the sticky toolbar and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
	 * It allows the UI-agnostic engine method to consider the geometry of the
	 * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel} that pins to the
	 * edge of the viewport and can obscure the user caret after scrolling the window.
	 *
	 * @param evt The `scrollToTheSelection` event info.
	 * @param data The payload carried by the `scrollToTheSelection` event.
	 * @param originalArgs The original arguments passed to `scrollViewportToShowTarget()` method (see implementation to learn more).
	 */ _handleScrollToTheSelectionWithStickyPanel(evt, data, originalArgs) {
        const stickyPanel = this.view.stickyPanel;
        if (stickyPanel.isSticky) {
            const stickyPanelHeight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](stickyPanel.element).height;
            data.viewportOffset.top += stickyPanelHeight;
        } else {
            const scrollViewportOnPanelGettingSticky = ()=>{
                this.editor.editing.view.scrollToTheSelection(originalArgs);
            };
            this.listenTo(stickyPanel, 'change:isSticky', scrollViewportOnPanelGettingSticky);
            // This works as a post-scroll-fixer because it's impossible predict whether the panel will be sticky after scrolling or not.
            // Listen for a short period of time only and if the toolbar does not become sticky very soon, cancel the listener.
            setTimeout(()=>{
                this.stopListening(stickyPanel, 'change:isSticky', scrollViewportOnPanelGettingSticky);
            }, 20);
        }
    }
    /**
	 * Provides an integration between the sticky toolbar and {@link module:ui/dialog/dialog the Dialog plugin}.
	 *
	 * It moves the dialog down to ensure that the
	 * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel sticky panel}
	 * used by the editor UI will not get obscured by the dialog when the dialog uses one of its automatic positions.
	 */ _initDialogPluginIntegration() {
        if (!this.editor.plugins.has('Dialog')) {
            return;
        }
        const stickyPanel = this.view.stickyPanel;
        const dialogPlugin = this.editor.plugins.get('Dialog');
        dialogPlugin.on('show', ()=>{
            const dialogView = dialogPlugin.view;
            dialogView.on('moveTo', (evt, data)=>{
                // Engage only when the panel is sticky, and the dialog is using one of default positions.
                // Ignore modals because they are displayed on top of the page (and overlay) and they do not collide with anything
                // See (https://github.com/ckeditor/ckeditor5/issues/17339).
                if (!stickyPanel.isSticky || dialogView.wasMoved || dialogView.isModal) {
                    return;
                }
                const stickyPanelContentRect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](stickyPanel.contentPanelElement);
                if (data[1] < stickyPanelContentRect.bottom + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DialogView"].defaultOffset) {
                    data[1] = stickyPanelContentRect.bottom + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DialogView"].defaultOffset;
                }
            }, {
                priority: 'high'
            });
        }, {
            priority: 'low'
        });
    }
}
/**
 * Classic editor UI view. Uses an inline editable and a sticky toolbar, all
 * enclosed in a boxed UI view.
 */ class ClassicEditorUIView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoxedEditorUIView"] {
    /**
	 * Sticky panel view instance. This is a parent view of a {@link #toolbar}
	 * that makes toolbar sticky.
	 */ stickyPanel;
    /**
	 * Toolbar view instance.
	 */ toolbar;
    /**
	 * Editable UI view.
	 */ editable;
    /**
	 * Creates an instance of the classic editor UI view.
	 *
	 * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
	 * @param editingView The editing view instance this view is related to.
	 * @param options Configuration options for the view instance.
	 * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
	 * in the main {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#toolbar toolbar}.
	 * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
	 * @param options.label When set, this value will be used as an accessible `aria-label` of the
	 * {@link module:ui/editableui/editableuiview~EditableUIView editable view}.
	 */ constructor(locale, editingView, options = {}){
        super(locale);
        this.stickyPanel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StickyPanelView"](locale);
        this.toolbar = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToolbarView"](locale, {
            shouldGroupWhenFull: options.shouldToolbarGroupWhenFull
        });
        if (options.useMenuBar) {
            this.menuBarView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarView"](locale);
        }
        this.editable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InlineEditableUIView"](locale, editingView, undefined, {
            label: options.label
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        if (this.menuBarView) {
            // Set toolbar as a child of a stickyPanel and makes toolbar sticky.
            this.stickyPanel.content.addMany([
                this.menuBarView,
                this.toolbar
            ]);
        } else {
            this.stickyPanel.content.add(this.toolbar);
        }
        this.top.add(this.stickyPanel);
        this.main.add(this.editable);
    }
}
/**
 * The classic editor implementation. It uses an inline editable and a sticky toolbar, all enclosed in a boxed UI.
 * See the {@glink examples/builds/classic-editor demo}.
 *
 * In order to create a classic editor instance, use the static
 * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`} method.
 */ class ClassicEditor extends /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementApiMixin"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"]) {
    /**
	 * @inheritDoc
	 */ static get editorName() {
        return 'ClassicEditor';
    }
    /**
	 * @inheritDoc
	 */ ui;
    /**
	 * Creates an instance of the classic editor.
	 *
	 * **Note:** do not use the constructor to create editor instances. Use the static
	 * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`} method instead.
	 *
	 * @param sourceElementOrData The DOM element that will be the source for the created editor
	 * or the editor's initial data. For more information see
	 * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}.
	 * @param config The editor configuration.
	 */ constructor(sourceElementOrData, config = {}){
        // If both `config.initialData` is set and initial data is passed as the constructor parameter, then throw.
        if (!isElement(sourceElementOrData) && config.initialData !== undefined) {
            // Documented in core/editor/editorconfig.jsdoc.
            // eslint-disable-next-line ckeditor5-rules/ckeditor-error-message
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('editor-create-initial-data', null);
        }
        super(config);
        this.config.define('menuBar.isVisible', false);
        if (this.config.get('initialData') === undefined) {
            this.config.set('initialData', getInitialData(sourceElementOrData));
        }
        if (isElement(sourceElementOrData)) {
            this.sourceElement = sourceElementOrData;
        }
        this.model.document.createRoot();
        const shouldToolbarGroupWhenFull = !this.config.get('toolbar.shouldNotGroupWhenFull');
        const menuBarConfig = this.config.get('menuBar');
        const view = new ClassicEditorUIView(this.locale, this.editing.view, {
            shouldToolbarGroupWhenFull,
            useMenuBar: menuBarConfig.isVisible,
            label: this.config.get('label')
        });
        this.ui = new ClassicEditorUI(this, view);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachToForm"])(this);
    }
    /**
	 * Destroys the editor instance, releasing all resources used by it.
	 *
	 * Updates the original editor element with the data if the
	 * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
	 * configuration option is set to `true`.
	 */ destroy() {
        if (this.sourceElement) {
            this.updateSourceElement();
        }
        this.ui.destroy();
        return super.destroy();
    }
    /**
	 * Creates a new classic editor instance.
	 *
	 * There are three ways how the editor can be initialized.
	 *
	 * # Replacing a DOM element (and loading data from it)
	 *
	 * You can initialize the editor using an existing DOM element:
	 *
	 * ```ts
	 * ClassicEditor
	 * 	.create( document.querySelector( '#editor' ) )
	 * 	.then( editor => {
	 * 		console.log( 'Editor was initialized', editor );
	 * 	} )
	 * 	.catch( err => {
	 * 		console.error( err.stack );
	 * 	} );
	 * ```
	 *
	 * The element's content will be used as the editor data and the element will be replaced by the editor UI.
	 *
	 * # Creating a detached editor
	 *
	 * Alternatively, you can initialize the editor by passing the initial data directly as a string.
	 * In this case, the editor will render an element that must be inserted into the DOM:
	 *
	 * ```ts
	 * ClassicEditor
	 * 	.create( '<p>Hello world!</p>' )
	 * 	.then( editor => {
	 * 		console.log( 'Editor was initialized', editor );
	 *
	 * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
	 * 		document.body.appendChild( editor.ui.element );
	 * 	} )
	 * 	.catch( err => {
	 * 		console.error( err.stack );
	 * 	} );
	 * ```
	 *
	 * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
	 * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
	 *
	 * # Replacing a DOM element (and data provided in `config.initialData`)
	 *
	 * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
	 *
	 * ```ts
	 * ClassicEditor
	 * 	.create( document.querySelector( '#editor' ), {
	 * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
	 * 	} )
	 * 	.then( editor => {
	 * 		console.log( 'Editor was initialized', editor );
	 * 	} )
	 * 	.catch( err => {
	 * 		console.error( err.stack );
	 * 	} );
	 * ```
	 *
	 * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
	 * makes it difficult to set the content of the source element.
	 *
	 * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
	 *
	 * # Configuring the editor
	 *
	 * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
	 * customizing plugins, toolbar and more.
	 *
	 * @param sourceElementOrData The DOM element that will be the source for the created editor
	 * or the editor's initial data.
	 *
	 * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization
	 * and the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element editor element} will replace the passed element
	 * in the DOM (the original one will be hidden and the editor will be injected next to it).
	 *
	 * If the {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
	 * option is set to `true`, the editor data will be set back to the original element once the editor is destroyed and when a form,
	 * in which this element is contained, is submitted (if the original element is a `<textarea>`). This ensures seamless integration
	 * with native web forms.
	 *
	 * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
	 * It is available under the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element `editor.ui.element`} property.
	 *
	 * @param config The editor configuration.
	 * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
	 */ static create(sourceElementOrData, config = {}) {
        return new Promise((resolve)=>{
            const editor = new this(sourceElementOrData, config);
            resolve(editor.initPlugins().then(()=>editor.ui.init(isElement(sourceElementOrData) ? sourceElementOrData : null)).then(()=>editor.data.init(editor.config.get('initialData'))).then(()=>editor.fire('ready')).then(()=>editor));
        });
    }
}
function getInitialData(sourceElementOrData) {
    return isElement(sourceElementOrData) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDataFromElement"])(sourceElementOrData) : sourceElementOrData;
}
function isElement(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__["isElement"])(value);
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-editor-decoupled/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "DecoupledEditor": (()=>DecoupledEditor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/isElement.js [app-client] (ecmascript) <export default as isElement>");
;
;
;
;
;
/**
 * The decoupled editor UI class.
 */ class DecoupledEditorUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EditorUI"] {
    /**
	 * The main (top–most) view of the editor UI.
	 */ view;
    /**
	 * Creates an instance of the decoupled editor UI class.
	 *
	 * @param editor The editor instance.
	 * @param view The view of the UI.
	 */ constructor(editor, view){
        super(editor);
        this.view = view;
    }
    /**
	 * Initializes the UI.
	 */ init() {
        const editor = this.editor;
        const view = this.view;
        const editingView = editor.editing.view;
        const editable = view.editable;
        const editingRoot = editingView.document.getRoot();
        // The editable UI and editing root should share the same name. Then name is used
        // to recognize the particular editable, for instance in ARIA attributes.
        editable.name = editingRoot.rootName;
        view.render();
        // The editable UI element in DOM is available for sure only after the editor UI view has been rendered.
        // But it can be available earlier if a DOM element has been passed to DecoupledEditor.create().
        const editableElement = editable.element;
        // Register the editable UI view in the editor. A single editor instance can aggregate multiple
        // editable areas (roots) but the decoupled editor has only one.
        this.setEditableElement(editable.name, editableElement);
        // Let the editable UI element respond to the changes in the global editor focus
        // tracker. It has been added to the same tracker a few lines above but, in reality, there are
        // many focusable areas in the editor, like balloons, toolbars or dropdowns and as long
        // as they have focus, the editable should act like it is focused too (although technically
        // it isn't), e.g. by setting the proper CSS class, visually announcing focus to the user.
        // Doing otherwise will result in editable focus styles disappearing, once e.g. the
        // toolbar gets focused.
        view.editable.bind('isFocused').to(this.focusTracker);
        // Bind the editable UI element to the editing view, making it an end– and entry–point
        // of the editor's engine. This is where the engine meets the UI.
        editingView.attachDomRoot(editableElement);
        this._initPlaceholder();
        this._initToolbar();
        this._initMenuBar(this.view.menuBarView);
        this.fire('ready');
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        const view = this.view;
        const editingView = this.editor.editing.view;
        if (editingView.getDomRoot(view.editable.name)) {
            editingView.detachDomRoot(view.editable.name);
        }
        view.destroy();
    }
    /**
	 * Initializes the inline editor toolbar and its panel.
	 */ _initToolbar() {
        const editor = this.editor;
        const view = this.view;
        const toolbar = view.toolbar;
        toolbar.fillFromConfig(editor.config.get('toolbar'), this.componentFactory);
        // Register the toolbar so it becomes available for Alt+F10 and Esc navigation.
        this.addToolbar(view.toolbar);
    }
    /**
	 * Enable the placeholder text on the editing root.
	 */ _initPlaceholder() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        const editingRoot = editingView.document.getRoot();
        const placeholder = editor.config.get('placeholder');
        if (placeholder) {
            const placeholderText = typeof placeholder === 'string' ? placeholder : placeholder[editingRoot.rootName];
            if (placeholderText) {
                editingRoot.placeholder = placeholderText;
            }
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enablePlaceholder"])({
            view: editingView,
            element: editingRoot,
            isDirectHost: false,
            keepOnFocus: true
        });
    }
}
/**
 * The decoupled editor UI view. It is a virtual view providing an inline
 * {@link module:editor-decoupled/decouplededitoruiview~DecoupledEditorUIView#editable},
 * {@link module:editor-decoupled/decouplededitoruiview~DecoupledEditorUIView#toolbar}, and a
 * {@link module:editor-decoupled/decouplededitoruiview~DecoupledEditorUIView#menuBarView} but without any
 * specific arrangement of the components in the DOM.
 *
 * See {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`}
 * to learn more about this view.
 */ class DecoupledEditorUIView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EditorUIView"] {
    /**
	 * The main toolbar of the decoupled editor UI.
	 */ toolbar;
    /**
	 * The editable of the decoupled editor UI.
	 */ editable;
    /**
	 * Menu bar view instance.
	 */ menuBarView;
    /**
	 * Creates an instance of the decoupled editor UI view.
	 *
	 * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
	 * @param editingView The editing view instance this view is related to.
	 * @param options Configuration options for the view instance.
	 * @param options.editableElement The editable element. If not specified, it will be automatically created by
	 * {@link module:ui/editableui/editableuiview~EditableUIView}. Otherwise, the given element will be used.
	 * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
	 * in the main {@link module:editor-decoupled/decouplededitoruiview~DecoupledEditorUIView#toolbar toolbar}.
	 * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
	 * @param options.label When set, this value will be used as an accessible `aria-label` of the
	 * {@link module:ui/editableui/editableuiview~EditableUIView editable view}.
	 */ constructor(locale, editingView, options = {}){
        super(locale);
        this.toolbar = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToolbarView"](locale, {
            shouldGroupWhenFull: options.shouldToolbarGroupWhenFull
        });
        this.menuBarView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarView"](locale);
        this.editable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InlineEditableUIView"](locale, editingView, options.editableElement, {
            label: options.label
        });
        // This toolbar may be placed anywhere in the page so things like font size need to be reset in it.
        // Because of the above, make sure the toolbar supports rounded corners.
        // Also, make sure the toolbar has the proper dir attribute because its ancestor may not have one
        // and some toolbar item styles depend on this attribute.
        this.toolbar.extendTemplate({
            attributes: {
                class: [
                    'ck-reset_all',
                    'ck-rounded-corners'
                ],
                dir: locale.uiLanguageDirection
            }
        });
        this.menuBarView.extendTemplate({
            attributes: {
                class: [
                    'ck-reset_all',
                    'ck-rounded-corners'
                ],
                dir: locale.uiLanguageDirection
            }
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        this.registerChild([
            this.menuBarView,
            this.toolbar,
            this.editable
        ]);
    }
}
/**
 * The decoupled editor implementation. It provides an inline editable and a toolbar. However, unlike other editors,
 * it does not render these components anywhere in the DOM unless configured.
 *
 * This type of an editor is dedicated to integrations which require a customized UI with an open
 * structure, allowing developers to specify the exact location of the interface.
 *
 * See the document editor {@glink examples/builds/document-editor demo} to learn about possible use cases
 * for the decoupled editor.
 *
 * In order to create a decoupled editor instance, use the static
 * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`} method.
 *
 * Note that you will need to attach the editor toolbar and menu bar to your web page manually, in a desired place,
 * after the editor is initialized.
 */ class DecoupledEditor extends /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementApiMixin"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"]) {
    /**
	 * @inheritDoc
	 */ static get editorName() {
        return 'DecoupledEditor';
    }
    /**
	 * @inheritDoc
	 */ ui;
    /**
	 * Creates an instance of the decoupled editor.
	 *
	 * **Note:** Do not use the constructor to create editor instances. Use the static
	 * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`} method instead.
	 *
	 * @param sourceElementOrData The DOM element that will be the source for the created editor
	 * (on which the editor will be initialized) or initial data for the editor. For more information see
	 * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}.
	 * @param config The editor configuration.
	 */ constructor(sourceElementOrData, config = {}){
        // If both `config.initialData` is set and initial data is passed as the constructor parameter, then throw.
        if (!isElement(sourceElementOrData) && config.initialData !== undefined) {
            // Documented in core/editor/editorconfig.jsdoc.
            // eslint-disable-next-line ckeditor5-rules/ckeditor-error-message
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('editor-create-initial-data', null);
        }
        super(config);
        if (this.config.get('initialData') === undefined) {
            this.config.set('initialData', getInitialData(sourceElementOrData));
        }
        if (isElement(sourceElementOrData)) {
            this.sourceElement = sourceElementOrData;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["secureSourceElement"])(this, sourceElementOrData);
        }
        this.model.document.createRoot();
        const shouldToolbarGroupWhenFull = !this.config.get('toolbar.shouldNotGroupWhenFull');
        const view = new DecoupledEditorUIView(this.locale, this.editing.view, {
            editableElement: this.sourceElement,
            shouldToolbarGroupWhenFull,
            label: this.config.get('label')
        });
        this.ui = new DecoupledEditorUI(this, view);
    }
    /**
	 * Destroys the editor instance, releasing all resources used by it.
	 *
	 * Updates the original editor element with the data if the
	 * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
	 * configuration option is set to `true`.
	 *
	 * **Note**: The decoupled editor does not remove the toolbar and editable when destroyed. You can
	 * do that yourself in the destruction chain:
	 *
	 * ```ts
	 * editor.destroy()
	 * 	.then( () => {
	 * 		// Remove the toolbar from DOM.
	 * 		editor.ui.view.toolbar.element.remove();
	 *
	 * 		// Remove the editable from DOM.
	 * 		editor.ui.view.editable.element.remove();
	 *
	 * 		console.log( 'Editor was destroyed' );
	 * 	} );
	 * ```
	 */ destroy() {
        // Cache the data, then destroy.
        // It's safe to assume that the model->view conversion will not work after super.destroy().
        const data = this.getData();
        this.ui.destroy();
        return super.destroy().then(()=>{
            if (this.sourceElement) {
                this.updateSourceElement(data);
            }
        });
    }
    /**
	 * Creates a new decoupled editor instance.
	 *
	 * **Note:** remember that `DecoupledEditor` does not append the toolbar element to your web page, so you have to do it manually
	 * after the editor has been initialized.
	 *
	 * There are two ways how the editor can be initialized.
	 *
	 * # Using an existing DOM element (and loading data from it)
	 *
	 * You can initialize the editor using an existing DOM element:
	 *
	 * ```ts
	 * DecoupledEditor
	 * 	.create( document.querySelector( '#editor' ) )
	 * 	.then( editor => {
	 * 		console.log( 'Editor was initialized', editor );
	 *
	 * 		// Append the toolbar to the <body> element.
	 * 		document.body.appendChild( editor.ui.view.toolbar.element );
	 * 	} )
	 * 	.catch( err => {
	 * 		console.error( err.stack );
	 * 	} );
	 * ```
	 *
	 * The element's content will be used as the editor data and the element will become the editable element.
	 *
	 * # Creating a detached editor
	 *
	 * Alternatively, you can initialize the editor by passing the initial data directly as a string.
	 * In this case, you will have to manually append both the toolbar element and the editable element to your web page.
	 *
	 * ```ts
	 * DecoupledEditor
	 * 	.create( '<p>Hello world!</p>' )
	 * 	.then( editor => {
	 * 		console.log( 'Editor was initialized', editor );
	 *
	 * 		// Append the toolbar to the <body> element.
	 * 		document.body.appendChild( editor.ui.view.toolbar.element );
	 *
	 * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
	 * 		document.body.appendChild( editor.ui.getEditableElement() );
	 * 	} )
	 * 	.catch( err => {
	 * 		console.error( err.stack );
	 * 	} );
	 * ```
	 *
	 * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
	 * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
	 *
	 * # Using an existing DOM element (and data provided in `config.initialData`)
	 *
	 * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
	 *
	 * ```ts
	 * DecoupledEditor
	 * 	.create( document.querySelector( '#editor' ), {
	 * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
	 * 	} )
	 * 	.then( editor => {
	 * 		console.log( 'Editor was initialized', editor );
	 *
	 * 		// Append the toolbar to the <body> element.
	 * 		document.body.appendChild( editor.ui.view.toolbar.element );
	 * 	} )
	 * 	.catch( err => {
	 * 		console.error( err.stack );
	 * 	} );
	 * ```
	 *
	 * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
	 * makes it difficult to set the content of the source element.
	 *
	 * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
	 *
	 * # Configuring the editor
	 *
	 * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
	 * customizing plugins, toolbar and more.
	 *
	 * @param sourceElementOrData The DOM element that will be the source for the created editor
	 * or the editor's initial data.
	 *
	 * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization.
	 * The editor data will be set back to the original element once the editor is destroyed only if the
	 * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
	 * option is set to `true`.
	 *
	 * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
	 * It is available via
	 * {@link module:editor-decoupled/decouplededitorui~DecoupledEditorUI#getEditableElement `editor.ui.getEditableElement()`}.
	 *
	 * @param config The editor configuration.
	 * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
	 */ static create(sourceElementOrData, config = {}) {
        return new Promise((resolve)=>{
            if (isElement(sourceElementOrData) && sourceElementOrData.tagName === 'TEXTAREA') {
                // Documented in core/editor/editor.js
                // eslint-disable-next-line ckeditor5-rules/ckeditor-error-message
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('editor-wrong-element', null);
            }
            const editor = new this(sourceElementOrData, config);
            resolve(editor.initPlugins().then(()=>editor.ui.init()).then(()=>editor.data.init(editor.config.get('initialData'))).then(()=>editor.fire('ready')).then(()=>editor));
        });
    }
}
function getInitialData(sourceElementOrData) {
    return isElement(sourceElementOrData) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDataFromElement"])(sourceElementOrData) : sourceElementOrData;
}
function isElement(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__["isElement"])(value);
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-editor-inline/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "InlineEditor": (()=>InlineEditor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/isElement.js [app-client] (ecmascript) <export default as isElement>");
;
;
;
;
;
/**
 * The inline editor UI class.
 *
 * @extends module:ui/editorui/editorui~EditorUI
 */ class InlineEditorUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EditorUI"] {
    /**
	 * The main (top–most) view of the editor UI.
	 */ view;
    /**
	 * A normalized `config.toolbar` object.
	 */ _toolbarConfig;
    /**
	 * Creates an instance of the inline editor UI class.
	 *
	 * @param editor The editor instance.
	 * @param view The view of the UI.
	 */ constructor(editor, view){
        super(editor);
        this.view = view;
        this._toolbarConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeToolbarConfig"])(editor.config.get('toolbar'));
    }
    /**
	 * @inheritDoc
	 */ get element() {
        return this.view.editable.element;
    }
    /**
	 * Initializes the UI.
	 */ init() {
        const editor = this.editor;
        const view = this.view;
        const editingView = editor.editing.view;
        const editable = view.editable;
        const editingRoot = editingView.document.getRoot();
        // The editable UI and editing root should share the same name. Then name is used
        // to recognize the particular editable, for instance in ARIA attributes.
        editable.name = editingRoot.rootName;
        view.render();
        // The editable UI element in DOM is available for sure only after the editor UI view has been rendered.
        // But it can be available earlier if a DOM element has been passed to InlineEditor.create().
        const editableElement = editable.element;
        // Register the editable UI view in the editor. A single editor instance can aggregate multiple
        // editable areas (roots) but the inline editor has only one.
        this.setEditableElement(editable.name, editableElement);
        // Let the editable UI element respond to the changes in the global editor focus
        // tracker. It has been added to the same tracker a few lines above but, in reality, there are
        // many focusable areas in the editor, like balloons, toolbars or dropdowns and as long
        // as they have focus, the editable should act like it is focused too (although technically
        // it isn't), e.g. by setting the proper CSS class, visually announcing focus to the user.
        // Doing otherwise will result in editable focus styles disappearing, once e.g. the
        // toolbar gets focused.
        editable.bind('isFocused').to(this.focusTracker);
        // Bind the editable UI element to the editing view, making it an end– and entry–point
        // of the editor's engine. This is where the engine meets the UI.
        editingView.attachDomRoot(editableElement);
        this._initPlaceholder();
        this._initToolbar();
        if (view.menuBarView) {
            this._initMenuBar(view.menuBarView);
        }
        this.fire('ready');
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        const view = this.view;
        const editingView = this.editor.editing.view;
        if (editingView.getDomRoot(view.editable.name)) {
            editingView.detachDomRoot(view.editable.name);
        }
        view.destroy();
    }
    /**
	 * Initializes the inline editor toolbar and its panel.
	 */ _initToolbar() {
        const editor = this.editor;
        const view = this.view;
        const editableElement = view.editable.element;
        const toolbar = view.toolbar;
        // Set–up the view#panel.
        view.panel.bind('isVisible').to(this.focusTracker, 'isFocused');
        view.bind('viewportTopOffset').to(this, 'viewportOffset', ({ top })=>top || 0);
        // https://github.com/ckeditor/ckeditor5-editor-inline/issues/4
        view.listenTo(editor.ui, 'update', ()=>{
            // Don't pin if the panel is not already visible. It prevents the panel
            // showing up when there's no focus in the UI.
            if (view.panel.isVisible) {
                view.panel.pin({
                    target: editableElement,
                    positions: view.panelPositions
                });
            }
        });
        toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory);
        // Register the toolbar so it becomes available for Alt+F10 and Esc navigation.
        this.addToolbar(toolbar);
    }
    /**
	 * Enable the placeholder text on the editing root.
	 */ _initPlaceholder() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        const editingRoot = editingView.document.getRoot();
        const placeholder = editor.config.get('placeholder');
        if (placeholder) {
            const placeholderText = typeof placeholder === 'string' ? placeholder : placeholder[editingRoot.rootName];
            if (placeholderText) {
                editingRoot.placeholder = placeholderText;
            }
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enablePlaceholder"])({
            view: editingView,
            element: editingRoot,
            isDirectHost: false,
            keepOnFocus: true
        });
    }
}
const toPx = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUnit"])('px');
/**
 * Inline editor UI view. Uses an nline editable and a floating toolbar.
 */ class InlineEditorUIView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EditorUIView"] {
    /**
	 * A floating toolbar view instance.
	 */ toolbar;
    /**
	 * A balloon panel view instance.
	 */ panel;
    /**
	 * A set of positioning functions used by the {@link #panel} to float around
	 * {@link #element editableElement}.
	 *
	 * The positioning functions are as follows:
	 *
	 * * West:
	 *
	 * ```
	 * [ Panel ]
	 * +------------------+
	 * | #editableElement |
	 * +------------------+
	 *
	 * +------------------+
	 * | #editableElement |
	 * |[ Panel ]         |
	 * |                  |
	 * +------------------+
	 *
	 * +------------------+
	 * | #editableElement |
	 * +------------------+
	 * [ Panel ]
	 * ```
	 *
	 * * East:
	 *
	 * ```
	 *            [ Panel ]
	 * +------------------+
	 * | #editableElement |
	 * +------------------+
	 *
	 * +------------------+
	 * | #editableElement |
	 * |         [ Panel ]|
	 * |                  |
	 * +------------------+
	 *
	 * +------------------+
	 * | #editableElement |
	 * +------------------+
	 *            [ Panel ]
	 * ```
	 *
	 * See: {@link module:utils/dom/position~Options#positions}.
	 */ panelPositions;
    /**
	 * Editable UI view.
	 */ editable;
    /**
	 * An instance of the resize observer that helps dynamically determine the geometry of the toolbar
	 * and manage items that do not fit into a single row.
	 *
	 * **Note:** Created in {@link #render}.
	 */ _resizeObserver;
    /**
	 * Creates an instance of the inline editor UI view.
	 *
	 * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
	 * @param editingView The editing view instance this view is related to.
	 * @param editableElement The editable element. If not specified, it will be automatically created by
	 * {@link module:ui/editableui/editableuiview~EditableUIView}. Otherwise, the given element will be used.
	 * @param options Configuration options for the view instance.
	 * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
	 * in the main {@link module:editor-inline/inlineeditoruiview~InlineEditorUIView#toolbar toolbar}.
	 * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
	 * @param options.label When set, this value will be used as an accessible `aria-label` of the
	 * {@link module:ui/editableui/editableuiview~EditableUIView editable view}.
	 */ constructor(locale, editingView, editableElement, options = {}){
        super(locale);
        this.toolbar = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToolbarView"](locale, {
            shouldGroupWhenFull: options.shouldToolbarGroupWhenFull,
            isFloating: true
        });
        if (options.useMenuBar) {
            this.menuBarView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarView"](locale);
        }
        this.set('viewportTopOffset', 0);
        this.panel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BalloonPanelView"](locale);
        this.panelPositions = this._getPanelPositions();
        this.panel.extendTemplate({
            attributes: {
                class: 'ck-toolbar-container'
            }
        });
        this.editable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InlineEditableUIView"](locale, editingView, editableElement, {
            label: options.label
        });
        this._resizeObserver = null;
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        this.body.add(this.panel);
        this.registerChild(this.editable);
        if (this.menuBarView) {
            // Set toolbar as a child of a stickyPanel and makes toolbar sticky.
            this.panel.content.addMany([
                this.menuBarView,
                this.toolbar
            ]);
        } else {
            this.panel.content.add(this.toolbar);
        }
        const options = this.toolbar.options;
        // Set toolbar's max-width on the initialization and update it on the editable resize,
        // if 'shouldToolbarGroupWhenFull' in config is set to 'true'.
        if (options.shouldGroupWhenFull) {
            const editableElement = this.editable.element;
            this._resizeObserver = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserver"](editableElement, ()=>{
                this.toolbar.maxWidth = toPx(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](editableElement).width);
            });
        }
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        if (this._resizeObserver) {
            this._resizeObserver.destroy();
        }
    }
    /**
	 * Determines the panel top position of the {@link #panel} in {@link #panelPositions}.
	 *
	 * @param editableRect Rect of the {@link #element}.
	 * @param panelRect Rect of the {@link #panel}.
	 */ _getPanelPositionTop(editableRect, panelRect) {
        let top;
        if (editableRect.top > panelRect.height + this.viewportTopOffset) {
            top = editableRect.top - panelRect.height;
        } else if (editableRect.bottom > panelRect.height + this.viewportTopOffset + 50) {
            top = this.viewportTopOffset;
        } else {
            top = editableRect.bottom;
        }
        return top;
    }
    /**
	 * Returns the positions for {@link #panelPositions}.
	 *
	 * See: {@link module:utils/dom/position~Options#positions}.
	 */ _getPanelPositions() {
        const positions = [
            (editableRect, panelRect)=>{
                return {
                    top: this._getPanelPositionTop(editableRect, panelRect),
                    left: editableRect.left,
                    name: 'toolbar_west',
                    config: {
                        withArrow: false
                    }
                };
            },
            (editableRect, panelRect)=>{
                return {
                    top: this._getPanelPositionTop(editableRect, panelRect),
                    left: editableRect.left + editableRect.width - panelRect.width,
                    name: 'toolbar_east',
                    config: {
                        withArrow: false
                    }
                };
            }
        ];
        if (this.locale.uiLanguageDirection === 'ltr') {
            return positions;
        } else {
            return positions.reverse();
        }
    }
}
/**
 * The inline editor implementation. It uses an inline editable and a floating toolbar.
 * See the {@glink examples/builds/inline-editor demo}.
 *
 * In order to create a inline editor instance, use the static
 * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`} method.
 */ class InlineEditor extends /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementApiMixin"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"]) {
    /**
	 * @inheritDoc
	 */ static get editorName() {
        return 'InlineEditor';
    }
    /**
	 * @inheritDoc
	 */ ui;
    /**
	 * Creates an instance of the inline editor.
	 *
	 * **Note:** Do not use the constructor to create editor instances. Use the static
	 * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`} method instead.
	 *
	 * @param sourceElementOrData The DOM element that will be the source for the created editor
	 * (on which the editor will be initialized) or initial data for the editor. For more information see
	 * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}.
	 * @param config The editor configuration.
	 */ constructor(sourceElementOrData, config = {}){
        // If both `config.initialData` and initial data parameter in `create()` are set, then throw.
        if (!isElement(sourceElementOrData) && config.initialData !== undefined) {
            // Documented in core/editor/editorconfig.jsdoc.
            // eslint-disable-next-line ckeditor5-rules/ckeditor-error-message
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('editor-create-initial-data', null);
        }
        super(config);
        this.config.define('menuBar.isVisible', false);
        if (this.config.get('initialData') === undefined) {
            this.config.set('initialData', getInitialData(sourceElementOrData));
        }
        this.model.document.createRoot();
        if (isElement(sourceElementOrData)) {
            this.sourceElement = sourceElementOrData;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["secureSourceElement"])(this, sourceElementOrData);
        }
        const shouldToolbarGroupWhenFull = !this.config.get('toolbar.shouldNotGroupWhenFull');
        const menuBarConfig = this.config.get('menuBar');
        const view = new InlineEditorUIView(this.locale, this.editing.view, this.sourceElement, {
            shouldToolbarGroupWhenFull,
            useMenuBar: menuBarConfig.isVisible,
            label: this.config.get('label')
        });
        this.ui = new InlineEditorUI(this, view);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachToForm"])(this);
    }
    /**
	 * Destroys the editor instance, releasing all resources used by it.
	 *
	 * Updates the original editor element with the data if the
	 * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
	 * configuration option is set to `true`.
	 */ destroy() {
        // Cache the data, then destroy.
        // It's safe to assume that the model->view conversion will not work after super.destroy().
        const data = this.getData();
        this.ui.destroy();
        return super.destroy().then(()=>{
            if (this.sourceElement) {
                this.updateSourceElement(data);
            }
        });
    }
    /**
	 * Creates a new inline editor instance.
	 *
	 * There are three general ways how the editor can be initialized.
	 *
	 * # Using an existing DOM element (and loading data from it)
	 *
	 * You can initialize the editor using an existing DOM element:
	 *
	 * ```ts
	 * InlineEditor
	 * 	.create( document.querySelector( '#editor' ) )
	 * 	.then( editor => {
	 * 		console.log( 'Editor was initialized', editor );
	 * 	} )
	 * 	.catch( err => {
	 * 		console.error( err.stack );
	 * 	} );
	 * ```
	 *
	 * The element's content will be used as the editor data and the element will become the editable element.
	 *
	 * # Creating a detached editor
	 *
	 * Alternatively, you can initialize the editor by passing the initial data directly as a `String`.
	 * In this case, the editor will render an element that must be inserted into the DOM for the editor to work properly:
	 *
	 * ```ts
	 * InlineEditor
	 * 	.create( '<p>Hello world!</p>' )
	 * 	.then( editor => {
	 * 		console.log( 'Editor was initialized', editor );
	 *
	 * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
	 * 		document.body.appendChild( editor.ui.element );
	 * 	} )
	 * 	.catch( err => {
	 * 		console.error( err.stack );
	 * 	} );
	 * ```
	 *
	 * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
	 * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
	 *
	 * # Using an existing DOM element (and data provided in `config.initialData`)
	 *
	 * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
	 *
	 * ```ts
	 * InlineEditor
	 * 	.create( document.querySelector( '#editor' ), {
	 * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
	 * 	} )
	 * 	.then( editor => {
	 * 		console.log( 'Editor was initialized', editor );
	 * 	} )
	 * 	.catch( err => {
	 * 		console.error( err.stack );
	 * 	} );
	 * ```
	 *
	 * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
	 * makes it difficult to set the content of the source element.
	 *
	 * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
	 *
	 * # Configuring the editor
	 *
	 * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
	 * customizing plugins, toolbar and more.
	 *
	 * @param sourceElementOrData The DOM element that will be the source for the created editor
	 * or the editor's initial data.
	 *
	 * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization.
	 * The editor data will be set back to the original element once the editor is destroyed only if the
	 * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
	 * option is set to `true`.
	 *
	 * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
	 * It is available under the {@link module:editor-inline/inlineeditorui~InlineEditorUI#element `editor.ui.element`} property.
	 *
	 * @param config The editor configuration.
	 * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
	 */ static create(sourceElementOrData, config = {}) {
        return new Promise((resolve)=>{
            if (isElement(sourceElementOrData) && sourceElementOrData.tagName === 'TEXTAREA') {
                // Documented in core/editor/editor.js
                // eslint-disable-next-line ckeditor5-rules/ckeditor-error-message
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('editor-wrong-element', null);
            }
            const editor = new this(sourceElementOrData, config);
            resolve(editor.initPlugins().then(()=>editor.ui.init()).then(()=>editor.data.init(editor.config.get('initialData'))).then(()=>editor.fire('ready')).then(()=>editor));
        });
    }
}
function getInitialData(sourceElementOrData) {
    return isElement(sourceElementOrData) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDataFromElement"])(sourceElementOrData) : sourceElementOrData;
}
function isElement(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__["isElement"])(value);
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-editor-multi-root/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "MultiRootEditor": (()=>MultiRootEditor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/isElement.js [app-client] (ecmascript) <export default as isElement>");
;
;
;
;
;
/**
 * The multi-root editor UI class.
 */ class MultiRootEditorUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EditorUI"] {
    /**
	 * The main (top–most) view of the editor UI.
	 */ view;
    /**
	 * The editable element that was focused the last time when any of the editables had focus.
	 */ _lastFocusedEditableElement;
    /**
	 * Creates an instance of the multi-root editor UI class.
	 *
	 * @param editor The editor instance.
	 * @param view The view of the UI.
	 */ constructor(editor, view){
        super(editor);
        this.view = view;
        this._lastFocusedEditableElement = null;
    }
    /**
	 * Initializes the UI.
	 */ init() {
        const view = this.view;
        view.render();
        // Keep track of the last focused editable element. Knowing which one was focused
        // is useful when the focus moves from editable to other UI components like balloons
        // (especially inputs) but the editable remains the "focus context" (e.g. link balloon
        // attached to a link in an editable). In this case, the editable should preserve visual
        // focus styles.
        this.focusTracker.on('change:focusedElement', (evt, name, focusedElement)=>{
            for (const editable of Object.values(this.view.editables)){
                if (focusedElement === editable.element) {
                    this._lastFocusedEditableElement = editable.element;
                }
            }
        });
        // If the focus tracker loses focus, stop tracking the last focused editable element.
        // Wherever the focus is restored, it will no longer be in the context of that editable
        // because the focus "came from the outside", as opposed to the focus moving from one element
        // to another within the editor UI.
        this.focusTracker.on('change:isFocused', (evt, name, isFocused)=>{
            if (!isFocused) {
                this._lastFocusedEditableElement = null;
            }
        });
        for (const editable of Object.values(this.view.editables)){
            this.addEditable(editable);
        }
        this._initToolbar();
        this._initMenuBar(this.view.menuBarView);
        this.fire('ready');
    }
    /**
	 * Adds the editable to the editor UI.
	 *
	 * After the editable is added to the editor UI it can be considered "active".
	 *
	 * The editable is attached to the editor editing pipeline, which means that it will be updated as the editor model updates and
	 * changing its content will be reflected in the editor model. Keystrokes, focus handling and placeholder are initialized.
	 *
	 * @param editable The editable instance to add.
	 * @param placeholder Placeholder for the editable element. If not set, placeholder value from the
	 * {@link module:core/editor/editorconfig~EditorConfig#placeholder editor configuration} will be used (if it was provided).
	 */ addEditable(editable, placeholder) {
        // The editable UI element in DOM is available for sure only after the editor UI view has been rendered.
        // But it can be available earlier if a DOM element has been passed to `MultiRootEditor.create()`.
        const editableElement = editable.element;
        // Bind the editable UI element to the editing view, making it an end– and entry–point
        // of the editor's engine. This is where the engine meets the UI.
        this.editor.editing.view.attachDomRoot(editableElement, editable.name);
        // Register each editable UI view in the editor.
        this.setEditableElement(editable.name, editableElement);
        // Let the editable UI element respond to the changes in the global editor focus
        // tracker. It has been added to the same tracker a few lines above but, in reality, there are
        // many focusable areas in the editor, like balloons, toolbars or dropdowns and as long
        // as they have focus, the editable should act like it is focused too (although technically
        // it isn't), e.g. by setting the proper CSS class, visually announcing focus to the user.
        // Doing otherwise will result in editable focus styles disappearing, once e.g. the
        // toolbar gets focused.
        editable.bind('isFocused').to(this.focusTracker, 'isFocused', this.focusTracker, 'focusedElement', (isFocused, focusedElement)=>{
            // When the focus tracker is blurred, it means the focus moved out of the editor UI.
            // No editable will maintain focus then.
            if (!isFocused) {
                return false;
            }
            // If the focus tracker says the editor UI is focused and currently focused element
            // is the editable, then the editable should be visually marked as focused too.
            if (focusedElement === editableElement) {
                return true;
            } else {
                return this._lastFocusedEditableElement === editableElement;
            }
        });
        this._initPlaceholder(editable, placeholder);
    }
    /**
	 * Removes the editable instance from the editor UI.
	 *
	 * Removed editable can be considered "deactivated".
	 *
	 * The editable is detached from the editing pipeline, so model changes are no longer reflected in it. All handling added in
	 * {@link #addEditable} is removed.
	 *
	 * @param editable Editable to remove from the editor UI.
	 */ removeEditable(editable) {
        const editingView = this.editor.editing.view;
        if (editingView.getDomRoot(editable.name)) {
            editingView.detachDomRoot(editable.name);
        }
        editable.unbind('isFocused');
        this.removeEditableElement(editable.name);
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        for (const editable of Object.values(this.view.editables)){
            this.removeEditable(editable);
        }
        this.view.destroy();
    }
    /**
	 * Initializes the editor main toolbar and its panel.
	 */ _initToolbar() {
        const editor = this.editor;
        const view = this.view;
        const toolbar = view.toolbar;
        toolbar.fillFromConfig(editor.config.get('toolbar'), this.componentFactory);
        // Register the toolbar, so it becomes available for Alt+F10 and Esc navigation.
        this.addToolbar(view.toolbar);
    }
    /**
	 * Enables the placeholder text on a given editable.
	 *
	 * @param editable Editable on which the placeholder should be set.
	 * @param placeholder Placeholder for the editable element. If not set, placeholder value from the
	 * {@link module:core/editor/editorconfig~EditorConfig#placeholder editor configuration} will be used (if it was provided).
	 */ _initPlaceholder(editable, placeholder) {
        if (!placeholder) {
            const configPlaceholder = this.editor.config.get('placeholder');
            if (configPlaceholder) {
                placeholder = typeof configPlaceholder === 'string' ? configPlaceholder : configPlaceholder[editable.name];
            }
        }
        const editingView = this.editor.editing.view;
        const editingRoot = editingView.document.getRoot(editable.name);
        if (placeholder) {
            editingRoot.placeholder = placeholder;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enablePlaceholder"])({
            view: editingView,
            element: editingRoot,
            isDirectHost: false,
            keepOnFocus: true
        });
    }
}
/**
 * The multi-root editor UI view. It is a virtual view providing an inline
 * {@link module:editor-multi-root/multirooteditoruiview~MultiRootEditorUIView#editable} and a
 * {@link module:editor-multi-root/multirooteditoruiview~MultiRootEditorUIView#toolbar}, but without any
 * specific arrangement of the components in the DOM.
 *
 * See {@link module:editor-multi-root/multirooteditor~MultiRootEditor.create `MultiRootEditor.create()`}
 * to learn more about this view.
 */ class MultiRootEditorUIView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EditorUIView"] {
    /**
	 * The main toolbar of the multi-root editor UI.
	 */ toolbar;
    /**
	 * Editable elements used by the multi-root editor UI.
	 */ editables;
    editable;
    /**
	 * Menu bar view instance.
	 */ menuBarView;
    /**
	 * The editing view instance this view is related to.
	 */ _editingView;
    /**
	 * Creates an instance of the multi-root editor UI view.
	 *
	 * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
	 * @param editingView The editing view instance this view is related to.
	 * @param editableNames Names for all editable views. For each name, one
	 * {@link module:ui/editableui/inline/inlineeditableuiview~InlineEditableUIView `InlineEditableUIView`} instance will be initialized.
	 * @param options Configuration options for the view instance.
	 * @param options.editableElements The editable elements to be used, assigned to their names. If not specified, they will be
	 * automatically created by {@link module:ui/editableui/inline/inlineeditableuiview~InlineEditableUIView `InlineEditableUIView`}
	 * instances.
	 * @param options.shouldToolbarGroupWhenFull When set to `true` enables automatic items grouping
	 * in the main {@link module:editor-multi-root/multirooteditoruiview~MultiRootEditorUIView#toolbar toolbar}.
	 * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
	 * @param options.label When set, this value will be used as an accessible `aria-label` of the
	 * {@link module:ui/editableui/editableuiview~EditableUIView editable view} elements.
	 */ constructor(locale, editingView, editableNames, options = {}){
        super(locale);
        this._editingView = editingView;
        this.toolbar = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToolbarView"](locale, {
            shouldGroupWhenFull: options.shouldToolbarGroupWhenFull
        });
        this.menuBarView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarView"](locale);
        this.editables = {};
        // Create `InlineEditableUIView` instance for each editable.
        for (const editableName of editableNames){
            const editableElement = options.editableElements ? options.editableElements[editableName] : undefined;
            let { label } = options;
            if (typeof label === 'object') {
                label = label[editableName];
            }
            this.createEditable(editableName, editableElement, label);
        }
        this.editable = Object.values(this.editables)[0];
        // This toolbar may be placed anywhere in the page so things like font size need to be reset in it.
        // Because of the above, make sure the toolbar supports rounded corners.
        // Also, make sure the toolbar has the proper dir attribute because its ancestor may not have one
        // and some toolbar item styles depend on this attribute.
        this.toolbar.extendTemplate({
            attributes: {
                class: [
                    'ck-reset_all',
                    'ck-rounded-corners'
                ],
                dir: locale.uiLanguageDirection
            }
        });
        this.menuBarView.extendTemplate({
            attributes: {
                class: [
                    'ck-reset_all',
                    'ck-rounded-corners'
                ],
                dir: locale.uiLanguageDirection
            }
        });
    }
    /**
	 * Creates an editable instance with given name and registers it in the editor UI view.
	 *
	 * If `editableElement` is provided, the editable instance will be created on top of it. Otherwise, the editor will create a new
	 * DOM element and use it instead.
	 *
	 * @param editableName The name for the editable.
	 * @param editableElement DOM element for which the editable should be created.
	 * @param label The accessible editable label used by assistive technologies.
	 * @returns The created editable instance.
	 */ createEditable(editableName, editableElement, label) {
        const editable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InlineEditableUIView"](this.locale, this._editingView, editableElement, {
            label
        });
        this.editables[editableName] = editable;
        editable.name = editableName;
        if (this.isRendered) {
            this.registerChild(editable);
        }
        return editable;
    }
    /**
	 * Destroys and removes the editable from the editor UI view.
	 *
	 * @param editableName The name of the editable that should be removed.
	 */ removeEditable(editableName) {
        const editable = this.editables[editableName];
        if (this.isRendered) {
            this.deregisterChild(editable);
        }
        delete this.editables[editableName];
        editable.destroy();
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        this.registerChild(Object.values(this.editables));
        this.registerChild(this.toolbar);
        this.registerChild(this.menuBarView);
    }
}
/**
 * The multi-root editor implementation.
 *
 * The multi-root editor provides multiple inline editable elements and a toolbar. All editable areas are controlled by one editor
 * instance, which means that they share common configuration, document ID, or undo stack.
 *
 * This type of editor is dedicated to integrations which require a customized UI with an open structure, featuring multiple editable areas,
 * allowing developers to have a control over the exact location of these editable areas.
 *
 * In order to create a multi-root editor instance, use the static
 * {@link module:editor-multi-root/multirooteditor~MultiRootEditor.create `MultiRootEditor.create()`} method.
 *
 * Note that you will need to attach the editor toolbar to your web page manually, in a desired place, after the editor is initialized.
 */ class MultiRootEditor extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"] {
    /**
	 * @inheritDoc
	 */ static get editorName() {
        return 'MultiRootEditor';
    }
    /**
	 * @inheritDoc
	 */ ui;
    /**
	 * The elements on which the editor has been initialized.
	 */ sourceElements;
    /**
	 * Holds attributes keys that were passed in {@link module:core/editor/editorconfig~EditorConfig#rootsAttributes `rootsAttributes`}
	 * config property and should be returned by {@link #getRootsAttributes}.
	 */ _registeredRootsAttributesKeys = new Set();
    /**
	 * A set of lock IDs for enabling or disabling particular root.
	 */ _readOnlyRootLocks = new Map();
    /**
	 * Creates an instance of the multi-root editor.
	 *
	 * **Note:** Do not use the constructor to create editor instances. Use the static
	 * {@link module:editor-multi-root/multirooteditor~MultiRootEditor.create `MultiRootEditor.create()`} method instead.
	 *
	 * @param sourceElementsOrData The DOM elements that will be the source for the created editor
	 * or the editor's initial data. The editor will initialize multiple roots with names according to the keys in the passed object.
	 * For more information see {@link module:editor-multi-root/multirooteditor~MultiRootEditor.create `MultiRootEditor.create()`}.
	 * @param config The editor configuration.
	 */ constructor(sourceElementsOrData, config = {}){
        const rootNames = Object.keys(sourceElementsOrData);
        const sourceIsData = rootNames.length === 0 || typeof sourceElementsOrData[rootNames[0]] === 'string';
        if (sourceIsData && config.initialData !== undefined && Object.keys(config.initialData).length > 0) {
            // Documented in core/editor/editorconfig.jsdoc.
            // eslint-disable-next-line ckeditor5-rules/ckeditor-error-message
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('editor-create-initial-data', null);
        }
        super(config);
        if (!sourceIsData) {
            this.sourceElements = sourceElementsOrData;
        } else {
            this.sourceElements = {};
        }
        if (this.config.get('initialData') === undefined) {
            // Create initial data object containing data from all roots.
            const initialData = {};
            for (const rootName of rootNames){
                initialData[rootName] = getInitialData(sourceElementsOrData[rootName]);
            }
            this.config.set('initialData', initialData);
        }
        if (!sourceIsData) {
            for (const rootName of rootNames){
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["secureSourceElement"])(this, sourceElementsOrData[rootName]);
            }
        }
        this.editing.view.document.roots.on('add', (evt, viewRoot)=>{
            // Here we change the standard binding of readOnly flag by adding
            // additional constraint that multi-root has (enabling / disabling particular root).
            viewRoot.unbind('isReadOnly');
            viewRoot.bind('isReadOnly').to(this.editing.view.document, 'isReadOnly', (isReadOnly)=>{
                return isReadOnly || this._readOnlyRootLocks.has(viewRoot.rootName);
            });
            // Hacky solution to nested editables.
            // Nested editables should be managed each separately and do not base on view document or view root.
            viewRoot.on('change:isReadOnly', (evt, prop, value)=>{
                const viewRange = this.editing.view.createRangeIn(viewRoot);
                for (const viewItem of viewRange.getItems()){
                    if (viewItem.is('editableElement')) {
                        viewItem.unbind('isReadOnly');
                        viewItem.isReadOnly = value;
                    }
                }
            });
        });
        for (const rootName of rootNames){
            // Create root and `UIView` element for each editable container.
            this.model.document.createRoot('$root', rootName);
        }
        if (this.config.get('lazyRoots')) {
            for (const rootName of this.config.get('lazyRoots')){
                const root = this.model.document.createRoot('$root', rootName);
                root._isLoaded = false;
            }
        }
        if (this.config.get('rootsAttributes')) {
            const rootsAttributes = this.config.get('rootsAttributes');
            for (const [rootName, attributes] of Object.entries(rootsAttributes)){
                if (!this.model.document.getRoot(rootName)) {
                    /**
					 * Trying to set attributes on a non-existing root.
					 *
					 * Roots specified in {@link module:core/editor/editorconfig~EditorConfig#rootsAttributes} do not match initial
					 * editor roots.
					 *
					 * @error multi-root-editor-root-attributes-no-root
					 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('multi-root-editor-root-attributes-no-root', null);
                }
                for (const key of Object.keys(attributes)){
                    this.registerRootAttribute(key);
                }
            }
            this.data.on('init', ()=>{
                this.model.enqueueChange({
                    isUndoable: false
                }, (writer)=>{
                    for (const [name, attributes] of Object.entries(rootsAttributes)){
                        const root = this.model.document.getRoot(name);
                        for (const [key, value] of Object.entries(attributes)){
                            if (value !== null) {
                                writer.setAttribute(key, value, root);
                            }
                        }
                    }
                });
            });
        }
        const options = {
            shouldToolbarGroupWhenFull: !this.config.get('toolbar.shouldNotGroupWhenFull'),
            editableElements: sourceIsData ? undefined : sourceElementsOrData,
            label: this.config.get('label')
        };
        const view = new MultiRootEditorUIView(this.locale, this.editing.view, rootNames, options);
        this.ui = new MultiRootEditorUI(this, view);
        this.model.document.on('change:data', ()=>{
            const changedRoots = this.model.document.differ.getChangedRoots();
            // Fire detaches first. If there are multiple roots removed and added in one batch, it should be easier to handle if
            // changes aren't mixed. Detaching will usually lead to just removing DOM elements. Detaching first will lead to a clean DOM
            // when new editables are added in `addRoot` event.
            for (const changes of changedRoots){
                const root = this.model.document.getRoot(changes.name);
                if (changes.state == 'detached') {
                    this.fire('detachRoot', root);
                }
            }
            for (const changes of changedRoots){
                const root = this.model.document.getRoot(changes.name);
                if (changes.state == 'attached') {
                    this.fire('addRoot', root);
                }
            }
        });
        // Overwrite `Model#canEditAt()` decorated method.
        // Check if the provided selection is inside a read-only root. If so, return `false`.
        this.listenTo(this.model, 'canEditAt', (evt, [selection])=>{
            // Skip empty selections.
            if (!selection) {
                return;
            }
            let selectionInReadOnlyRoot = false;
            for (const range of selection.getRanges()){
                const root = range.root;
                if (this._readOnlyRootLocks.has(root.rootName)) {
                    selectionInReadOnlyRoot = true;
                    break;
                }
            }
            // If selection is in read-only root, return `false` and prevent further processing.
            // Otherwise, allow for other callbacks (or default callback) to evaluate.
            if (selectionInReadOnlyRoot) {
                evt.return = false;
                evt.stop();
            }
        }, {
            priority: 'high'
        });
        this.decorate('loadRoot');
        this.on('loadRoot', (evt, [rootName])=>{
            const root = this.model.document.getRoot(rootName);
            if (!root) {
                /**
				 * The root to load does not exist.
				 *
				 * @error multi-root-editor-load-root-no-root
				 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('multi-root-editor-load-root-no-root', this, {
                    rootName
                });
            }
            if (root._isLoaded) {
                /**
				 * The root to load was already loaded before. The `loadRoot()` call has no effect.
				 *
				 * @error multi-root-editor-load-root-already-loaded
				 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('multi-root-editor-load-root-already-loaded');
                evt.stop();
            }
        }, {
            priority: 'highest'
        });
    }
    /**
	 * Destroys the editor instance, releasing all resources used by it.
	 *
	 * Updates the original editor element with the data if the
	 * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
	 * configuration option is set to `true`.
	 *
	 * **Note**: The multi-root editor does not remove the toolbar and editable when destroyed. You can
	 * do that yourself in the destruction chain, if you need to:
	 *
	 * ```ts
	 * editor.destroy().then( () => {
	 * 	// Remove the toolbar from DOM.
	 * 	editor.ui.view.toolbar.element.remove();
	 *
	 * 	// Remove editable elements from DOM.
	 * 	for ( const editable of Object.values( editor.ui.view.editables ) ) {
	 * 	    editable.element.remove();
	 * 	}
	 *
	 * 	console.log( 'Editor was destroyed' );
	 * } );
	 * ```
	 */ destroy() {
        const shouldUpdateSourceElement = this.config.get('updateSourceElementOnDestroy');
        // Cache the data and editable DOM elements, then destroy.
        // It's safe to assume that the model->view conversion will not work after `super.destroy()`,
        // same as `ui.getEditableElement()` method will not return editables.
        const data = {};
        for (const rootName of Object.keys(this.sourceElements)){
            data[rootName] = shouldUpdateSourceElement ? this.getData({
                rootName
            }) : '';
        }
        this.ui.destroy();
        return super.destroy().then(()=>{
            for (const rootName of Object.keys(this.sourceElements)){
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setDataInElement"])(this.sourceElements[rootName], data[rootName]);
            }
        });
    }
    /**
	 * Adds a new root to the editor.
	 *
	 * ```ts
	 * editor.addRoot( 'myRoot', { data: '<p>Initial root data.</p>' } );
	 * ```
	 *
	 * After a root is added, you will be able to modify and retrieve its data.
	 *
	 * All root names must be unique. An error will be thrown if you will try to create a root with the name same as
	 * an already existing, attached root. However, you can call this method for a detached root. See also {@link #detachRoot}.
	 *
	 * Whenever a root is added, the editor instance will fire {@link #event:addRoot `addRoot` event}. The event is also called when
	 * the root is added indirectly, e.g. by the undo feature or on a remote client during real-time collaboration.
	 *
	 * Note, that this method only adds a root to the editor model. It **does not** create a DOM editable element for the new root.
	 * Until such element is created (and attached to the root), the root is "virtual": it is not displayed anywhere and its data can
	 * be changed only using the editor API.
	 *
	 * To create a DOM editable element for the root, listen to {@link #event:addRoot `addRoot` event} and call {@link #createEditable}.
	 * Then, insert the DOM element in a desired place, that will depend on the integration with your application and your requirements.
	 *
	 * ```ts
	 * editor.on( 'addRoot', ( evt, root ) => {
	 * 	const editableElement = editor.createEditable( root );
	 *
	 * 	// You may want to create a more complex DOM structure here.
	 * 	//
	 * 	// Alternatively, you may want to create a DOM structure before
	 * 	// calling `editor.addRoot()` and only append `editableElement` at
	 * 	// a proper place.
	 *
	 * 	document.querySelector( '#editors' ).appendChild( editableElement );
	 * } );
	 *
	 * // ...
	 *
	 * editor.addRoot( 'myRoot' ); // Will create a root, a DOM editable element and append it to `#editors` container element.
	 * ```
	 *
	 * You can set root attributes on the new root while you add it:
	 *
	 * ```ts
	 * // Add a collapsed root at fourth position from top.
	 * // Keep in mind that these are just examples of attributes. You need to provide your own features that will handle the attributes.
	 * editor.addRoot( 'myRoot', { attributes: { isCollapsed: true, index: 4 } } );
	 * ```
	 *
	 * Note that attributes added together with a root are automatically registered.
	 *
	 * See also {@link ~MultiRootEditor#registerRootAttribute `MultiRootEditor#registerRootAttribute()`} and
	 * {@link module:core/editor/editorconfig~EditorConfig#rootsAttributes `config.rootsAttributes` configuration option}.
	 *
	 * By setting `isUndoable` flag to `true`, you can allow for detaching the root using the undo feature.
	 *
	 * Additionally, you can group adding multiple roots in one undo step. This can be useful if you add multiple roots that are
	 * combined into one, bigger UI element, and want them all to be undone together.
	 *
	 * ```ts
	 * let rowId = 0;
	 *
	 * editor.model.change( () => {
	 * 	editor.addRoot( 'left-row-' + rowId, { isUndoable: true } );
	 * 	editor.addRoot( 'center-row-' + rowId, { isUndoable: true } );
	 * 	editor.addRoot( 'right-row-' + rowId, { isUndoable: true } );
	 *
	 * 	rowId++;
	 * } );
	 * ```
	 *
	 * @param rootName Name of the root to add.
	 * @param options Additional options for the added root.
	 */ addRoot(rootName, { data = '', attributes = {}, elementName = '$root', isUndoable = false } = {}) {
        const _addRoot = (writer)=>{
            const root = writer.addRoot(rootName, elementName);
            if (data) {
                writer.insert(this.data.parse(data, root), root, 0);
            }
            for (const key of Object.keys(attributes)){
                this.registerRootAttribute(key);
                writer.setAttribute(key, attributes[key], root);
            }
        };
        if (isUndoable) {
            this.model.change(_addRoot);
        } else {
            this.model.enqueueChange({
                isUndoable: false
            }, _addRoot);
        }
    }
    /**
	 * Detaches a root from the editor.
	 *
	 * ```ts
	 * editor.detachRoot( 'myRoot' );
	 * ```
	 *
	 * A detached root is not entirely removed from the editor model, however it can be considered removed.
	 *
	 * After a root is detached all its children are removed, all markers inside it are removed, and whenever something is inserted to it,
	 * it is automatically removed as well. Finally, a detached root is not returned by
	 * {@link module:engine/model/document~Document#getRootNames} by default.
	 *
	 * It is possible to re-add a previously detached root calling {@link #addRoot}.
	 *
	 * Whenever a root is detached, the editor instance will fire {@link #event:detachRoot `detachRoot` event}. The event is also
	 * called when the root is detached indirectly, e.g. by the undo feature or on a remote client during real-time collaboration.
	 *
	 * Note, that this method only detached a root in the editor model. It **does not** destroy the DOM editable element linked with
	 * the root and it **does not** remove the DOM element from the DOM structure of your application.
	 *
	 * To properly remove a DOM editable element after a root was detached, listen to {@link #event:detachRoot `detachRoot` event}
	 * and call {@link #detachEditable}. Then, remove the DOM element from your application.
	 *
	 * ```ts
	 * editor.on( 'detachRoot', ( evt, root ) => {
	 * 	const editableElement = editor.detachEditable( root );
	 *
	 * 	// You may want to do an additional DOM clean-up here.
	 *
	 * 	editableElement.remove();
	 * } );
	 *
	 * // ...
	 *
	 * editor.detachRoot( 'myRoot' ); // Will detach the root, and remove the DOM editable element.
	 * ```
	 *
	 * By setting `isUndoable` flag to `true`, you can allow for re-adding the root using the undo feature.
	 *
	 * Additionally, you can group detaching multiple roots in one undo step. This can be useful if the roots are combined into one,
	 * bigger UI element, and you want them all to be re-added together.
	 *
	 * ```ts
	 * editor.model.change( () => {
	 * 	editor.detachRoot( 'left-row-3', true );
	 * 	editor.detachRoot( 'center-row-3', true );
	 * 	editor.detachRoot( 'right-row-3', true );
	 * } );
	 * ```
	 *
	 * @param rootName Name of the root to detach.
	 * @param isUndoable Whether detaching the root can be undone (using the undo feature) or not.
	 */ detachRoot(rootName, isUndoable = false) {
        if (isUndoable) {
            this.model.change((writer)=>writer.detachRoot(rootName));
        } else {
            this.model.enqueueChange({
                isUndoable: false
            }, (writer)=>writer.detachRoot(rootName));
        }
    }
    /**
	 * Creates and returns a new DOM editable element for the given root element.
	 *
	 * The new DOM editable is attached to the model root and can be used to modify the root content.
	 *
	 * @param root Root for which the editable element should be created.
	 * @param placeholder Placeholder for the editable element. If not set, placeholder value from the
	 * {@link module:core/editor/editorconfig~EditorConfig#placeholder editor configuration} will be used (if it was provided).
	 * @param label The accessible label text describing the editable to the assistive technologies.
	 * @returns The created DOM element. Append it in a desired place in your application.
	 */ createEditable(root, placeholder, label) {
        const editable = this.ui.view.createEditable(root.rootName, undefined, label);
        this.ui.addEditable(editable, placeholder);
        this.editing.view.forceRender();
        return editable.element;
    }
    /**
	 * Detaches the DOM editable element that was attached to the given root.
	 *
	 * @param root Root for which the editable element should be detached.
	 * @returns The DOM element that was detached. You may want to remove it from your application DOM structure.
	 */ detachEditable(root) {
        const rootName = root.rootName;
        const editable = this.ui.view.editables[rootName];
        this.ui.removeEditable(editable);
        this.ui.view.removeEditable(rootName);
        return editable.element;
    }
    /**
	 * Loads a root that has previously been declared in {@link module:core/editor/editorconfig~EditorConfig#lazyRoots `lazyRoots`}
	 * configuration option.
	 *
	 * Only roots specified in the editor config can be loaded. A root cannot be loaded multiple times. A root cannot be unloaded and
	 * loading a root cannot be reverted using the undo feature.
	 *
	 * When a root becomes loaded, it will be treated by the editor as though it was just added. This, among others, means that all
	 * related events and mechanisms will be fired, including {@link ~MultiRootEditor#event:addRoot `addRoot` event},
	 * {@link module:engine/model/document~Document#event:change `model.Document` `change` event}, model post-fixers and conversion.
	 *
	 * Until the root becomes loaded, all above mechanisms are suppressed.
	 *
	 * This method is {@link module:utils/observablemixin~Observable#decorate decorated}.
	 *
	 * Note that attributes loaded together with a root are automatically registered.
	 *
	 * See also {@link ~MultiRootEditor#registerRootAttribute `MultiRootEditor#registerRootAttribute()`} and
	 * {@link module:core/editor/editorconfig~EditorConfig#rootsAttributes `config.rootsAttributes` configuration option}.
	 *
	 * When this method is used in real-time collaboration environment, its effects become asynchronous as the editor will first synchronize
	 * with the remote editing session, before the root is added to the editor.
	 *
	 * If the root has been already loaded by any other client, the additional data passed in `loadRoot()` parameters will be ignored.
	 *
	 * @param rootName Name of the root to load.
	 * @param options Additional options for the loaded root.
	 * @fires loadRoot
	 */ loadRoot(rootName, { data = '', attributes = {} } = {}) {
        // `root` will be defined as it is guaranteed by a check in a higher priority callback.
        const root = this.model.document.getRoot(rootName);
        this.model.enqueueChange({
            isUndoable: false
        }, (writer)=>{
            if (data) {
                writer.insert(this.data.parse(data, root), root, 0);
            }
            for (const key of Object.keys(attributes)){
                this.registerRootAttribute(key);
                writer.setAttribute(key, attributes[key], root);
            }
            root._isLoaded = true;
            this.model.document.differ._bufferRootLoad(root);
        });
    }
    /**
	 * Returns the document data for all attached roots.
	 *
	 * @param options Additional configuration for the retrieved data.
	 * Editor features may introduce more configuration options that can be set through this parameter.
	 * @param options.trim Whether returned data should be trimmed. This option is set to `'empty'` by default,
	 * which means that whenever editor content is considered empty, an empty string is returned. To turn off trimming
	 * use `'none'`. In such cases exact content will be returned (for example `'<p>&nbsp;</p>'` for an empty editor).
	 * @returns The full document data.
	 */ getFullData(options) {
        const data = {};
        for (const rootName of this.model.document.getRootNames()){
            data[rootName] = this.data.get({
                ...options,
                rootName
            });
        }
        return data;
    }
    /**
	 * Returns attributes for all attached roots.
	 *
	 * Note: all and only {@link ~MultiRootEditor#registerRootAttribute registered} roots attributes will be returned.
	 * If a registered root attribute is not set for a given root, `null` will be returned.
	 *
	 * @returns Object with roots attributes. Keys are roots names, while values are attributes set on given root.
	 */ getRootsAttributes() {
        const rootsAttributes = {};
        for (const rootName of this.model.document.getRootNames()){
            rootsAttributes[rootName] = this.getRootAttributes(rootName);
        }
        return rootsAttributes;
    }
    /**
	 * Returns attributes for the specified root.
	 *
	 * Note: all and only {@link ~MultiRootEditor#registerRootAttribute registered} roots attributes will be returned.
	 * If a registered root attribute is not set for a given root, `null` will be returned.
	 */ getRootAttributes(rootName) {
        const rootAttributes = {};
        const root = this.model.document.getRoot(rootName);
        for (const key of this._registeredRootsAttributesKeys){
            rootAttributes[key] = root.hasAttribute(key) ? root.getAttribute(key) : null;
        }
        return rootAttributes;
    }
    /**
	 * Registers given string as a root attribute key. Registered root attributes are added to
	 * {@link module:engine/model/schema~Schema schema}, and also returned by
	 * {@link ~MultiRootEditor#getRootAttributes `getRootAttributes()`} and
	 * {@link ~MultiRootEditor#getRootsAttributes `getRootsAttributes()`}.
	 *
	 * Note: attributes passed in {@link module:core/editor/editorconfig~EditorConfig#rootsAttributes `config.rootsAttributes`} are
	 * automatically registered as the editor is initialized. However, registering the same attribute twice does not have any negative
	 * impact, so it is recommended to use this method in any feature that uses roots attributes.
	 */ registerRootAttribute(key) {
        if (this._registeredRootsAttributesKeys.has(key)) {
            return;
        }
        this._registeredRootsAttributesKeys.add(key);
        this.editing.model.schema.extend('$root', {
            allowAttributes: key
        });
    }
    /**
	 * Switches given editor root to the read-only mode.
	 *
	 * In contrary to {@link module:core/editor/editor~Editor#enableReadOnlyMode `enableReadOnlyMode()`}, which switches the whole editor
	 * to the read-only mode, this method turns only a particular root to the read-only mode. This can be useful when you want to prevent
	 * editing only a part of the editor content.
	 *
	 * When you switch a root to the read-only mode, you need provide a unique identifier (`lockId`) that will identify this request. You
	 * will need to provide the same `lockId` when you will want to
	 * {@link module:editor-multi-root/multirooteditor~MultiRootEditor#enableRoot re-enable} the root.
	 *
	 * ```ts
	 * const model = editor.model;
	 * const myRoot = model.document.getRoot( 'myRoot' );
	 *
	 * editor.disableRoot( 'myRoot', 'my-lock' );
	 * model.canEditAt( myRoot ); // `false`
	 *
	 * editor.disableRoot( 'myRoot', 'other-lock' );
	 * editor.disableRoot( 'myRoot', 'other-lock' ); // Multiple locks with the same ID have no effect.
	 * model.canEditAt( myRoot ); // `false`
	 *
	 * editor.enableRoot( 'myRoot', 'my-lock' );
	 * model.canEditAt( myRoot ); // `false`
	 *
	 * editor.enableRoot( 'myRoot', 'other-lock' );
	 * model.canEditAt( myRoot ); // `true`
	 * ```
	 *
	 * See also {@link module:core/editor/editor~Editor#enableReadOnlyMode `Editor#enableReadOnlyMode()`} and
	 * {@link module:editor-multi-root/multirooteditor~MultiRootEditor#enableRoot `MultiRootEditor#enableRoot()`}.
	 *
	 * @param rootName Name of the root to switch to read-only mode.
	 * @param lockId A unique ID for setting the editor to the read-only state.
	 */ disableRoot(rootName, lockId) {
        if (rootName == '$graveyard') {
            /**
			 * You cannot disable the `$graveyard` root.
			 *
			 * @error multi-root-editor-cannot-disable-graveyard-root
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('multi-root-editor-cannot-disable-graveyard-root', this);
        }
        const locksForGivenRoot = this._readOnlyRootLocks.get(rootName);
        if (locksForGivenRoot) {
            locksForGivenRoot.add(lockId);
        } else {
            this._readOnlyRootLocks.set(rootName, new Set([
                lockId
            ]));
            const editableRootElement = this.editing.view.document.getRoot(rootName);
            editableRootElement.isReadOnly = true;
            // Since one of the roots has changed read-only state, we need to refresh all commands that affect data.
            Array.from(this.commands.commands()).forEach((command)=>command.affectsData && command.refresh());
        }
    }
    /**
	 * Removes given read-only lock from the given root.
	 *
	 * See {@link module:editor-multi-root/multirooteditor~MultiRootEditor#disableRoot `disableRoot()`}.
	 *
	 * @param rootName Name of the root to switch back from the read-only mode.
	 * @param lockId A unique ID for setting the editor to the read-only state.
	 */ enableRoot(rootName, lockId) {
        const locksForGivenRoot = this._readOnlyRootLocks.get(rootName);
        if (!locksForGivenRoot || !locksForGivenRoot.has(lockId)) {
            return;
        }
        if (locksForGivenRoot.size === 1) {
            this._readOnlyRootLocks.delete(rootName);
            const editableRootElement = this.editing.view.document.getRoot(rootName);
            editableRootElement.isReadOnly = this.isReadOnly;
            // Since one of the roots has changed read-only state, we need to refresh all commands that affect data.
            Array.from(this.commands.commands()).forEach((command)=>command.affectsData && command.refresh());
        } else {
            locksForGivenRoot.delete(lockId);
        }
    }
    /**
	 * Creates a new multi-root editor instance.
	 *
	 * **Note:** remember that `MultiRootEditor` does not append the toolbar element to your web page, so you have to do it manually
	 * after the editor has been initialized.
	 *
	 * There are a few different ways to initialize the multi-root editor.
	 *
	 * # Using existing DOM elements:
	 *
	 * ```ts
	 * MultiRootEditor.create( {
	 * 	intro: document.querySelector( '#editor-intro' ),
	 * 	content: document.querySelector( '#editor-content' ),
	 * 	sidePanelLeft: document.querySelector( '#editor-side-left' ),
	 * 	sidePanelRight: document.querySelector( '#editor-side-right' ),
	 * 	outro: document.querySelector( '#editor-outro' )
	 * } )
	 * .then( editor => {
	 * 	console.log( 'Editor was initialized', editor );
	 *
	 * 	// Append the toolbar inside a provided DOM element.
	 * 	document.querySelector( '#toolbar-container' ).appendChild( editor.ui.view.toolbar.element );
	 * } )
	 * .catch( err => {
	 * 	console.error( err.stack );
	 * } );
	 * ```
	 *
	 * The elements' content will be used as the editor data and elements will become editable elements.
	 *
	 * # Creating a detached editor
	 *
	 * Alternatively, you can initialize the editor by passing the initial data directly as strings.
	 * In this case, you will have to manually append both the toolbar element and the editable elements to your web page.
	 *
	 * ```ts
	 * MultiRootEditor.create( {
	 * 	intro: '<p><strong>Exciting</strong> intro text to an article.</p>',
	 * 	content: '<p>Lorem ipsum dolor sit amet.</p>',
	 * 	sidePanelLeft: '<blockquote>Strong quotation from article.</blockquote>',
	 * 	sidePanelRight: '<p>List of similar articles...</p>',
	 * 	outro: '<p>Closing text.</p>'
	 * } )
	 * .then( editor => {
	 * 	console.log( 'Editor was initialized', editor );
	 *
	 * 	// Append the toolbar inside a provided DOM element.
	 * 	document.querySelector( '#toolbar-container' ).appendChild( editor.ui.view.toolbar.element );
	 *
	 * 	// Append DOM editable elements created by the editor.
	 * 	const editables = editor.ui.view.editables;
	 * 	const container = document.querySelector( '#editable-container' );
	 *
	 * 	container.appendChild( editables.intro.element );
	 * 	container.appendChild( editables.content.element );
	 * 	container.appendChild( editables.outro.element );
	 * } )
	 * .catch( err => {
	 * 	console.error( err.stack );
	 * } );
	 * ```
	 *
	 * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
	 * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
	 *
	 * # Using an existing DOM element (and data provided in `config.initialData`)
	 *
	 * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
	 *
	 * ```ts
	 * MultiRootEditor.create( {
	 * 	intro: document.querySelector( '#editor-intro' ),
	 * 	content: document.querySelector( '#editor-content' ),
	 * 	sidePanelLeft: document.querySelector( '#editor-side-left' ),
	 * 	sidePanelRight: document.querySelector( '#editor-side-right' ),
	 * 	outro: document.querySelector( '#editor-outro' )
	 * }, {
	 * 	initialData: {
	 * 		intro: '<p><strong>Exciting</strong> intro text to an article.</p>',
	 * 		content: '<p>Lorem ipsum dolor sit amet.</p>',
	 * 		sidePanelLeft '<blockquote>Strong quotation from article.</blockquote>':
	 * 		sidePanelRight '<p>List of similar articles...</p>':
	 * 		outro: '<p>Closing text.</p>'
	 * 	}
	 * } )
	 * .then( editor => {
	 * 	console.log( 'Editor was initialized', editor );
	 *
	 * 	// Append the toolbar inside a provided DOM element.
	 * 	document.querySelector( '#toolbar-container' ).appendChild( editor.ui.view.toolbar.element );
	 * } )
	 * .catch( err => {
	 * 	console.error( err.stack );
	 * } );
	 * ```
	 *
	 * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
	 * makes it difficult to set the content of the source element.
	 *
	 * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
	 *
	 * # Configuring the editor
	 *
	 * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
	 * customizing plugins, toolbar and more.
	 *
	 * @param sourceElementsOrData The DOM elements that will be the source for the created editor
	 * or the editor's initial data. The editor will initialize multiple roots with names according to the keys in the passed object.
	 *
	 * If DOM elements are passed, their content will be automatically loaded to the editor upon initialization and the elements will be
	 * used as the editor's editable areas. The editor data will be set back to the original element once the editor is destroyed if the
	 * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy} option
	 * is set to `true`.
	 *
	 * If the initial data is passed, a detached editor will be created. For each entry in the passed object, one editor root and one
	 * editable DOM element will be created. You will need to attach the editable elements into the DOM manually. The elements are available
	 * through the {@link module:editor-multi-root/multirooteditorui~MultiRootEditorUI#getEditableElement `editor.ui.getEditableElement()`}
	 * method.
	 * @param config The editor configuration.
	 * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
	 */ static create(sourceElementsOrData, config = {}) {
        return new Promise((resolve)=>{
            for (const sourceItem of Object.values(sourceElementsOrData)){
                if (isElement(sourceItem) && sourceItem.tagName === 'TEXTAREA') {
                    // Documented in core/editor/editor.js
                    // eslint-disable-next-line ckeditor5-rules/ckeditor-error-message
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('editor-wrong-element', null);
                }
            }
            const editor = new this(sourceElementsOrData, config);
            resolve(editor.initPlugins().then(()=>editor.ui.init()).then(()=>{
                // This is checked directly before setting the initial data,
                // as plugins may change `EditorConfig#initialData` value.
                editor._verifyRootsWithInitialData();
                return editor.data.init(editor.config.get('initialData'));
            }).then(()=>editor.fire('ready')).then(()=>editor));
        });
    }
    /**
	 * @internal
	 */ _verifyRootsWithInitialData() {
        const initialData = this.config.get('initialData');
        // Roots that are not in the initial data.
        for (const rootName of this.model.document.getRootNames()){
            if (!(rootName in initialData)) {
                /**
				 * Editor roots do not match the
				 * {@link module:core/editor/editorconfig~EditorConfig#initialData `initialData` configuration}.
				 *
				 * This may happen for one of the two reasons:
				 *
				 * * Configuration error. The `sourceElementsOrData` parameter in
				 * {@link module:editor-multi-root/multirooteditor~MultiRootEditor.create `MultiRootEditor.create()`} contains different
				 * roots than {@link module:core/editor/editorconfig~EditorConfig#initialData `initialData` configuration}.
				 * * As the editor was initialized, the {@link module:core/editor/editorconfig~EditorConfig#initialData `initialData`}
				 * configuration value or the state of the editor roots has been changed.
				 *
				 * @error multi-root-editor-root-initial-data-mismatch
				 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('multi-root-editor-root-initial-data-mismatch', null);
            }
        }
        // Roots that are not in the editor.
        for (const rootName of Object.keys(initialData)){
            const root = this.model.document.getRoot(rootName);
            if (!root || !root.isAttached()) {
                // eslint-disable-next-line ckeditor5-rules/ckeditor-error-message
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('multi-root-editor-root-initial-data-mismatch', null);
            }
        }
    }
}
function getInitialData(sourceElementOrData) {
    return isElement(sourceElementOrData) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDataFromElement"])(sourceElementOrData) : sourceElementOrData;
}
function isElement(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__["isElement"])(value);
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-select-all/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "SelectAll": (()=>SelectAll),
    "SelectAllEditing": (()=>SelectAllEditing),
    "SelectAllUI": (()=>SelectAllUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
;
;
;
/**
 * The select all command.
 *
 * It is used by the {@link module:select-all/selectallediting~SelectAllEditing select all editing feature} to handle
 * the <kbd>Ctrl/⌘</kbd>+<kbd>A</kbd> keystroke.
 *
 * Executing this command changes the {@glink framework/architecture/editing-engine#model model}
 * selection so it contains the entire content of the editable root of the editor the selection is
 * {@link module:engine/model/selection~Selection#anchor anchored} in.
 *
 * If the selection was anchored in a {@glink framework/tutorials/widgets/implementing-a-block-widget nested editable}
 * (e.g. a caption of an image), the new selection will contain its entire content. Successive executions of this command
 * will expand the selection to encompass more and more content up to the entire editable root of the editor.
 */ class SelectAllCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        // It does not affect data so should be enabled in read-only mode.
        this.affectsData = false;
    }
    /**
	 * @inheritDoc
	 */ execute() {
        const model = this.editor.model;
        const selection = model.document.selection;
        let scopeElement = model.schema.getLimitElement(selection);
        // If an entire scope is selected, or the selection's ancestor is not a scope yet,
        // browse through ancestors to find the enclosing parent scope.
        if (selection.containsEntireContent(scopeElement) || !isSelectAllScope(model.schema, scopeElement)) {
            do {
                scopeElement = scopeElement.parent;
                // Do nothing, if the entire `root` is already selected.
                if (!scopeElement) {
                    return;
                }
            }while (!isSelectAllScope(model.schema, scopeElement))
        }
        model.change((writer)=>{
            writer.setSelection(scopeElement, 'in');
        });
    }
}
/**
 * Checks whether the element is a valid select-all scope. Returns true, if the element is a
 * {@link module:engine/model/schema~Schema#isLimit limit}, and can contain any text or paragraph.
 *
 * @param schema Schema to check against.
 * @param element Model element.
 */ function isSelectAllScope(schema, element) {
    return schema.isLimit(element) && (schema.checkChild(element, '$text') || schema.checkChild(element, 'paragraph'));
}
const SELECT_ALL_KEYSTROKE = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseKeystroke"])('Ctrl+A');
/**
 * The select all editing feature.
 *
 * It registers the `'selectAll'` {@link module:select-all/selectallcommand~SelectAllCommand command}
 * and the <kbd>Ctrl/⌘</kbd>+<kbd>A</kbd> keystroke listener which executes it.
 */ class SelectAllEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SelectAllEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        const view = editor.editing.view;
        const viewDocument = view.document;
        editor.commands.add('selectAll', new SelectAllCommand(editor));
        this.listenTo(viewDocument, 'keydown', (eventInfo, domEventData)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCode"])(domEventData) === SELECT_ALL_KEYSTROKE) {
                editor.execute('selectAll');
                domEventData.preventDefault();
            }
        });
        // Add the information about the keystroke to the accessibility database.
        editor.accessibility.addKeystrokeInfos({
            keystrokes: [
                {
                    label: t('Select all'),
                    keystroke: 'CTRL+A'
                }
            ]
        });
    }
}
var selectAllIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\"><path d=\"M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z\"/></svg>";
/**
 * The select all UI feature.
 *
 * It registers the `'selectAll'` UI button in the editor's
 * {@link module:ui/componentfactory~ComponentFactory component factory}. When clicked, the button
 * executes the {@link module:select-all/selectallcommand~SelectAllCommand select all command}.
 */ class SelectAllUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SelectAllUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.ui.componentFactory.add('selectAll', ()=>{
            const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
            buttonView.set({
                tooltip: true
            });
            return buttonView;
        });
        editor.ui.componentFactory.add('menuBar:selectAll', ()=>{
            return this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
        });
    }
    /**
	 * Creates a button for select all command to use either in toolbar or in menu bar.
	 */ _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = editor.commands.get('selectAll');
        const view = new ButtonClass(editor.locale);
        const t = locale.t;
        view.set({
            label: t('Select all'),
            icon: selectAllIcon,
            keystroke: 'Ctrl+A'
        });
        view.bind('isEnabled').to(command, 'isEnabled');
        // Execute the command.
        this.listenTo(view, 'execute', ()=>{
            editor.execute('selectAll');
            editor.editing.view.focus();
        });
        return view;
    }
}
/**
 * The select all feature.
 *
 * This is a "glue" plugin which loads the {@link module:select-all/selectallediting~SelectAllEditing select all editing feature}
 * and the {@link module:select-all/selectallui~SelectAllUI select all UI feature}.
 *
 * Please refer to the documentation of individual features to learn more.
 */ class SelectAll extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            SelectAllEditing,
            SelectAllUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SelectAll';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-undo/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Undo": (()=>Undo),
    "UndoEditing": (()=>UndoEditing),
    "UndoUI": (()=>UndoUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
;
;
;
/**
 * Base class for the undo feature commands: {@link module:undo/undocommand~UndoCommand} and {@link module:undo/redocommand~RedoCommand}.
 */ class BaseCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * Stack of items stored by the command. These are pairs of:
	 *
	 * * {@link module:engine/model/batch~Batch batch} saved by the command,
	 * * {@link module:engine/model/selection~Selection selection} state at the moment of saving the batch.
	 */ _stack = [];
    /**
	 * Stores all batches that were created by this command.
	 *
	 * @internal
	 */ _createdBatches = new WeakSet();
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        // Refresh state, so the command is inactive right after initialization.
        this.refresh();
        // This command should not depend on selection change.
        this._isEnabledBasedOnSelection = false;
        // Set the transparent batch for the `editor.data.set()` call if the
        // batch type is not set already.
        this.listenTo(editor.data, 'set', (evt, data)=>{
            // Create a shallow copy of the options to not change the original args.
            // And make sure that an object is assigned to data[ 1 ].
            data[1] = {
                ...data[1]
            };
            const options = data[1];
            // If batch type is not set, default to non-undoable batch.
            if (!options.batchType) {
                options.batchType = {
                    isUndoable: false
                };
            }
        }, {
            priority: 'high'
        });
        // Clear the stack for the `transparent` batches.
        this.listenTo(editor.data, 'set', (evt, data)=>{
            // We can assume that the object exists and it has a `batchType` property.
            // It was ensured with a higher priority listener before.
            const options = data[1];
            if (!options.batchType.isUndoable) {
                this.clearStack();
            }
        });
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        this.isEnabled = this._stack.length > 0;
    }
    /**
	 * Returns all batches created by this command.
	 */ get createdBatches() {
        return this._createdBatches;
    }
    /**
	 * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}
	 * created by the editor which this command is registered to.
	 *
	 * @param batch The batch to add.
	 */ addBatch(batch) {
        const docSelection = this.editor.model.document.selection;
        const selection = {
            ranges: docSelection.hasOwnRange ? Array.from(docSelection.getRanges()) : [],
            isBackward: docSelection.isBackward
        };
        this._stack.push({
            batch,
            selection
        });
        this.refresh();
    }
    /**
	 * Removes all items from the stack.
	 */ clearStack() {
        this._stack = [];
        this.refresh();
    }
    /**
	 * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.
	 *
	 * @param ranges Ranges to be restored.
	 * @param isBackward A flag describing whether the restored range was selected forward or backward.
	 * @param operations Operations which has been applied since selection has been stored.
	 */ _restoreSelection(ranges, isBackward, operations) {
        const model = this.editor.model;
        const document = model.document;
        // This will keep the transformed selection ranges.
        const selectionRanges = [];
        // Transform all ranges from the restored selection.
        const transformedRangeGroups = ranges.map((range)=>range.getTransformedByOperations(operations));
        const allRanges = transformedRangeGroups.flat();
        for (const rangeGroup of transformedRangeGroups){
            // While transforming there could appear ranges that are contained by other ranges, we shall ignore them.
            const transformed = rangeGroup.filter((range)=>range.root != document.graveyard).filter((range)=>!isRangeContainedByAnyOtherRange(range, allRanges));
            // All the transformed ranges ended up in graveyard.
            if (!transformed.length) {
                continue;
            }
            // After the range got transformed, we have an array of ranges. Some of those
            // ranges may be "touching" -- they can be next to each other and could be merged.
            normalizeRanges(transformed);
            // For each `range` from `ranges`, we take only one transformed range.
            // This is because we want to prevent situation where single-range selection
            // got transformed to multi-range selection.
            selectionRanges.push(transformed[0]);
        }
        // @if CK_DEBUG_ENGINE // console.log( `Restored selection by undo: ${ selectionRanges.join( ', ' ) }` );
        // `selectionRanges` may be empty if all ranges ended up in graveyard. If that is the case, do not restore selection.
        if (selectionRanges.length) {
            model.change((writer)=>{
                writer.setSelection(selectionRanges, {
                    backward: isBackward
                });
            });
        }
    }
    /**
	 * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.
	 * This is a helper method for {@link #execute}.
	 *
	 * @param batchToUndo The batch to be undone.
	 * @param undoingBatch The batch that will contain undoing changes.
	 */ _undo(batchToUndo, undoingBatch) {
        const model = this.editor.model;
        const document = model.document;
        // All changes done by the command execution will be saved as one batch.
        this._createdBatches.add(undoingBatch);
        const operationsToUndo = batchToUndo.operations.slice().filter((operation)=>operation.isDocumentOperation);
        operationsToUndo.reverse();
        // We will process each operation from `batchToUndo`, in reverse order. If there were operations A, B and C in undone batch,
        // we need to revert them in reverse order, so first C' (reversed C), then B', then A'.
        for (const operationToUndo of operationsToUndo){
            const nextBaseVersion = operationToUndo.baseVersion + 1;
            const historyOperations = Array.from(document.history.getOperations(nextBaseVersion));
            const transformedSets = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformSets"])([
                operationToUndo.getReversed()
            ], historyOperations, {
                useRelations: true,
                document: this.editor.model.document,
                padWithNoOps: false,
                forceWeakRemove: true
            });
            const reversedOperations = transformedSets.operationsA;
            // After reversed operation has been transformed by all history operations, apply it.
            for (let operation of reversedOperations){
                // Do not apply any operation on non-editable space.
                const affectedSelectable = operation.affectedSelectable;
                if (affectedSelectable && !model.canEditAt(affectedSelectable)) {
                    operation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NoOperation"](operation.baseVersion);
                }
                // Before applying, add the operation to the `undoingBatch`.
                undoingBatch.addOperation(operation);
                model.applyOperation(operation);
                document.history.setOperationAsUndone(operationToUndo, operation);
            }
        }
    }
}
/**
 * Normalizes list of ranges by joining intersecting or "touching" ranges.
 *
 * @param ranges Ranges to be normalized.
 */ function normalizeRanges(ranges) {
    ranges.sort((a, b)=>a.start.isBefore(b.start) ? -1 : 1);
    for(let i = 1; i < ranges.length; i++){
        const previousRange = ranges[i - 1];
        const joinedRange = previousRange.getJoined(ranges[i], true);
        if (joinedRange) {
            // Replace the ranges on the list with the new joined range.
            i--;
            ranges.splice(i, 2, joinedRange);
        }
    }
}
function isRangeContainedByAnyOtherRange(range, ranges) {
    return ranges.some((otherRange)=>otherRange !== range && otherRange.containsRange(range, true));
}
/**
 * The undo command stores {@link module:engine/model/batch~Batch batches} applied to the
 * {@link module:engine/model/document~Document document} and is able to undo a batch by reversing it and transforming by
 * batches from {@link module:engine/model/document~Document#history history} that happened after the reversed batch.
 *
 * The undo command also takes care of restoring the {@link module:engine/model/document~Document#selection document selection}.
 */ class UndoCommand extends BaseCommand {
    /**
	 * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms
	 * and applies the reverted version on the {@link module:engine/model/document~Document document} and removes the batch from the stack.
	 * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
	 *
	 * @fires execute
	 * @fires revert
	 * @param batch A batch that should be undone. If not set, the last added batch will be undone.
	 */ execute(batch = null) {
        // If batch is not given, set `batchIndex` to the last index in command stack.
        const batchIndex = batch ? this._stack.findIndex((a)=>a.batch == batch) : this._stack.length - 1;
        const item = this._stack.splice(batchIndex, 1)[0];
        const undoingBatch = this.editor.model.createBatch({
            isUndo: true
        });
        // All changes have to be done in one `enqueueChange` callback so other listeners will not
        // step between consecutive operations, or won't do changes to the document before selection is properly restored.
        this.editor.model.enqueueChange(undoingBatch, ()=>{
            this._undo(item.batch, undoingBatch);
            const operations = this.editor.model.document.history.getOperations(item.batch.baseVersion);
            this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations);
        });
        // Firing `revert` event after the change block to make sure that it includes all changes from post-fixers
        // and make sure that the selection is "stabilized" (the selection range is saved after undo is executed and then
        // restored on redo, so it is important that the selection range is saved after post-fixers are done).
        this.fire('revert', item.batch, undoingBatch);
        this.refresh();
    }
}
/**
 * The redo command stores {@link module:engine/model/batch~Batch batches} that were used to undo a batch by
 * {@link module:undo/undocommand~UndoCommand}. It is able to redo a previously undone batch by reversing the undoing
 * batches created by `UndoCommand`. The reversed batch is transformed by all the batches from
 * {@link module:engine/model/document~Document#history history} that happened after the reversed undo batch.
 *
 * The redo command also takes care of restoring the {@link module:engine/model/document~Document#selection document selection}.
 */ class RedoCommand extends BaseCommand {
    /**
	 * Executes the command. This method reverts the last {@link module:engine/model/batch~Batch batch} added to
	 * the command's stack, applies the reverted and transformed version on the
	 * {@link module:engine/model/document~Document document} and removes the batch from the stack.
	 * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
	 *
	 * @fires execute
	 */ execute() {
        const item = this._stack.pop();
        const redoingBatch = this.editor.model.createBatch({
            isUndo: true
        });
        // All changes have to be done in one `enqueueChange` callback so other listeners will not step between consecutive
        // operations, or won't do changes to the document before selection is properly restored.
        this.editor.model.enqueueChange(redoingBatch, ()=>{
            const lastOperation = item.batch.operations[item.batch.operations.length - 1];
            const nextBaseVersion = lastOperation.baseVersion + 1;
            const operations = this.editor.model.document.history.getOperations(nextBaseVersion);
            this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations);
            this._undo(item.batch, redoingBatch);
        });
        this.refresh();
    }
}
/**
 * The undo engine feature.
 *
 * It introduces the `'undo'` and `'redo'` commands to the editor.
 */ class UndoEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * The command that manages the undo {@link module:engine/model/batch~Batch batches} stack (history).
	 * Created and registered during the {@link #init feature initialization}.
	 */ _undoCommand;
    /**
	 * The command that manages the redo {@link module:engine/model/batch~Batch batches} stack (history).
	 * Created and registered during the {@link #init feature initialization}.
	 */ _redoCommand;
    /**
	 * Keeps track of which batches were registered in undo.
	 */ _batchRegistry = new WeakSet();
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'UndoEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        // Create commands.
        this._undoCommand = new UndoCommand(editor);
        this._redoCommand = new RedoCommand(editor);
        // Register command to the editor.
        editor.commands.add('undo', this._undoCommand);
        editor.commands.add('redo', this._redoCommand);
        this.listenTo(editor.model, 'applyOperation', (evt, args)=>{
            const operation = args[0];
            // Do not register batch if the operation is not a document operation.
            // This prevents from creating empty undo steps, where all operations where non-document operations.
            // Non-document operations creates and alters content in detached tree fragments (for example, document fragments).
            // Most of time this is preparing data before it is inserted into actual tree (for example during copy & paste).
            // Such operations should not be reversed.
            if (!operation.isDocumentOperation) {
                return;
            }
            const batch = operation.batch;
            const isRedoBatch = this._redoCommand.createdBatches.has(batch);
            const isUndoBatch = this._undoCommand.createdBatches.has(batch);
            const wasProcessed = this._batchRegistry.has(batch);
            // Skip the batch if it was already processed.
            if (wasProcessed) {
                return;
            }
            // Add the batch to the registry so it will not be processed again.
            this._batchRegistry.add(batch);
            if (!batch.isUndoable) {
                return;
            }
            if (isRedoBatch) {
                // If this batch comes from `redoCommand`, add it to the `undoCommand` stack.
                this._undoCommand.addBatch(batch);
            } else if (!isUndoBatch) {
                // If the batch comes neither  from `redoCommand` nor from `undoCommand` then it is a new, regular batch.
                // Add the batch to the `undoCommand` stack and clear the `redoCommand` stack.
                this._undoCommand.addBatch(batch);
                this._redoCommand.clearStack();
            }
        }, {
            priority: 'highest'
        });
        this.listenTo(this._undoCommand, 'revert', (evt, undoneBatch, undoingBatch)=>{
            this._redoCommand.addBatch(undoingBatch);
        });
        editor.keystrokes.set('CTRL+Z', 'undo');
        editor.keystrokes.set('CTRL+Y', 'redo');
        editor.keystrokes.set('CTRL+SHIFT+Z', 'redo');
        // Add the information about the keystrokes to the accessibility database.
        editor.accessibility.addKeystrokeInfos({
            keystrokes: [
                {
                    label: t('Undo'),
                    keystroke: 'CTRL+Z'
                },
                {
                    label: t('Redo'),
                    keystroke: [
                        [
                            'CTRL+Y'
                        ],
                        [
                            'CTRL+SHIFT+Z'
                        ]
                    ]
                }
            ]
        });
    }
}
/**
 * The undo UI feature. It introduces the `'undo'` and `'redo'` buttons to the editor.
 */ class UndoUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'UndoUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const locale = editor.locale;
        const t = editor.t;
        const localizedUndoIcon = locale.uiLanguageDirection == 'ltr' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].undo : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].redo;
        const localizedRedoIcon = locale.uiLanguageDirection == 'ltr' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].redo : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].undo;
        this._addButtonsToFactory('undo', t('Undo'), 'CTRL+Z', localizedUndoIcon);
        this._addButtonsToFactory('redo', t('Redo'), 'CTRL+Y', localizedRedoIcon);
    }
    /**
	 * Creates a button for the specified command.
	 *
	 * @param name Command name.
	 * @param label Button label.
	 * @param keystroke Command keystroke.
	 * @param Icon Source of the icon.
	 */ _addButtonsToFactory(name, label, keystroke, Icon) {
        const editor = this.editor;
        editor.ui.componentFactory.add(name, ()=>{
            const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"], name, label, keystroke, Icon);
            buttonView.set({
                tooltip: true
            });
            return buttonView;
        });
        editor.ui.componentFactory.add('menuBar:' + name, ()=>{
            return this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"], name, label, keystroke, Icon);
        });
    }
    /**
	 * TODO
	 */ _createButton(ButtonClass, name, label, keystroke, Icon) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = editor.commands.get(name);
        const view = new ButtonClass(locale);
        view.set({
            label,
            icon: Icon,
            keystroke
        });
        view.bind('isEnabled').to(command, 'isEnabled');
        this.listenTo(view, 'execute', ()=>{
            editor.execute(name);
            editor.editing.view.focus();
        });
        return view;
    }
}
/**
 * The undo feature.
 *
 * This is a "glue" plugin which loads the {@link module:undo/undoediting~UndoEditing undo editing feature}
 * and the {@link module:undo/undoui~UndoUI undo UI feature}.
 *
 * Below is an explanation of the undo mechanism working together with {@link module:engine/model/history~History History}:
 *
 * Whenever an {@link module:engine/model/operation/operation~Operation operation} is applied to the
 * {@link module:engine/model/document~Document document}, it is saved to `History` as is.
 * The {@link module:engine/model/batch~Batch batch} that owns that operation is also saved, in
 * {@link module:undo/undocommand~UndoCommand}, together with the selection that was present in the document before the
 * operation was applied. A batch is saved instead of the operation because changes are undone batch-by-batch, not operation-by-operation
 * and a batch is seen as one undo step.
 *
 * After changes happen to the document, the `History` and `UndoCommand` stack can be represented as follows:
 *
 * ```
 *    History                            Undo stack
 * ==============             ==================================
 * [operation A1]                      [  batch A  ]
 * [operation B1]                      [  batch B  ]
 * [operation B2]                      [  batch C  ]
 * [operation C1]
 * [operation C2]
 * [operation B3]
 * [operation C3]
 * ```
 *
 * Where operations starting with the same letter are from same batch.
 *
 * Undoing a batch means that a set of operations which will reverse the effects of that batch needs to be generated.
 * For example, if a batch added several letters, undoing the batch should remove them. It is important to apply undoing
 * operations in the reversed order, so if a batch has operation `X`, `Y`, `Z`, reversed operations `Zr`, `Yr` and `Xr`
 * need to be applied. Otherwise reversed operation `Xr` would operate on a wrong document state, because operation `X`
 * does not know that operations `Y` and `Z` happened.
 *
 * After operations from an undone batch got {@link module:engine/model/operation/operation~Operation#getReversed reversed},
 * one needs to make sure if they are ready to be applied. In the scenario above, operation `C3` is the last operation and `C3r`
 * bases on up-to-date document state, so it can be applied to the document.
 *
 * ```
 *      History                             Undo stack
 * =================             ==================================
 * [ operation A1  ]                      [  batch A  ]
 * [ operation B1  ]                      [  batch B  ]
 * [ operation B2  ]             [   processing undoing batch C   ]
 * [ operation C1  ]
 * [ operation C2  ]
 * [ operation B3  ]
 * [ operation C3  ]
 * [ operation C3r ]
 * ```
 *
 * Next is operation `C2`, reversed to `C2r`. `C2r` bases on `C2`, so it bases on the wrong document state. It needs to be
 * transformed by operations from history that happened after it, so it "knows" about them. Let us assume that `C2' = C2r * B3 * C3 * C3r`,
 * where `*` means "transformed by". Rest of operations from that batch are processed in the same fashion.
 *
 * ```
 *      History                             Undo stack                                      Redo stack
 * =================             ==================================             ==================================
 * [ operation A1  ]                      [  batch A  ]                                    [ batch Cr ]
 * [ operation B1  ]                      [  batch B  ]
 * [ operation B2  ]
 * [ operation C1  ]
 * [ operation C2  ]
 * [ operation B3  ]
 * [ operation C3  ]
 * [ operation C3r ]
 * [ operation C2' ]
 * [ operation C1' ]
 * ```
 *
 * Selective undo works on the same basis, however, instead of undoing the last batch in the undo stack, any batch can be undone.
 * The same algorithm applies: operations from a batch (i.e. `A1`) are reversed and then transformed by operations stored in history.
 *
 * Redo also is very similar to undo. It has its own stack that is filled with undoing (reversed batches). Operations from
 * the batch that is re-done are reversed-back, transformed in proper order and applied to the document.
 *
 * ```
 *      History                             Undo stack                                      Redo stack
 * =================             ==================================             ==================================
 * [ operation A1  ]                      [  batch A  ]
 * [ operation B1  ]                      [  batch B  ]
 * [ operation B2  ]                      [ batch Crr ]
 * [ operation C1  ]
 * [ operation C2  ]
 * [ operation B3  ]
 * [ operation C3  ]
 * [ operation C3r ]
 * [ operation C2' ]
 * [ operation C1' ]
 * [ operation C1'r]
 * [ operation C2'r]
 * [ operation C3rr]
 * ```
 */ class Undo extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            UndoEditing,
            UndoUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Undo';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-essentials/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Essentials": (()=>Essentials)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$clipboard$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-clipboard/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$enter$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-enter/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$select$2d$all$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-select-all/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-typing/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$undo$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-undo/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
/**
 * A plugin including all essential editing features. It represents a set of features that enables similar functionalities
 * to a `<textarea>` element.
 *
 * It includes:
 *
 * * {@link module:ui/editorui/accessibilityhelp/accessibilityhelp~AccessibilityHelp},
 * * {@link module:clipboard/clipboard~Clipboard},
 * * {@link module:enter/enter~Enter},
 * * {@link module:select-all/selectall~SelectAll},
 * * {@link module:enter/shiftenter~ShiftEnter},
 * * {@link module:typing/typing~Typing},
 * * {@link module:undo/undo~Undo}.
 *
 * This plugin set does not define any block-level containers (such as {@link module:paragraph/paragraph~Paragraph}).
 * If your editor is supposed to handle block content, make sure to include it.
 */ class Essentials extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AccessibilityHelp"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$clipboard$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Clipboard"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$enter$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Enter"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$select$2d$all$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SelectAll"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$enter$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShiftEnter"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Typing"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$undo$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Undo"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Essentials';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-find-and-replace/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "FindAndReplace": (()=>FindAndReplace),
    "FindAndReplaceEditing": (()=>FindAndReplaceEditing),
    "FindAndReplaceUI": (()=>FindAndReplaceUI),
    "FindAndReplaceUtils": (()=>FindAndReplaceUtils),
    "FindCommand": (()=>FindCommand),
    "FindNextCommand": (()=>FindNextCommand),
    "FindPreviousCommand": (()=>FindPreviousCommand),
    "ReplaceAllCommand": (()=>ReplaceAllCommand),
    "ReplaceCommand": (()=>ReplaceCommand)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$debounce$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__debounce$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/debounce.js [app-client] (ecmascript) <export default as debounce>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$escapeRegExp$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__escapeRegExp$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/escapeRegExp.js [app-client] (ecmascript) <export default as escapeRegExp>");
;
;
;
;
/**
 * The find and replace form view class.
 *
 * See {@link module:find-and-replace/ui/findandreplaceformview~FindAndReplaceFormView}.
 */ class FindAndReplaceFormView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * A collection of child views.
	 */ children;
    /**
	 * The find in text input view that stores the searched string.
	 *
	 * @internal
	 */ _findInputView;
    /**
	 * The replace input view.
	 */ _replaceInputView;
    /**
	 * The find button view that initializes the search process.
	 */ _findButtonView;
    /**
	 * The find previous button view.
	 */ _findPrevButtonView;
    /**
	 * The find next button view.
	 */ _findNextButtonView;
    /**
	 * A collapsible view aggregating the advanced search options.
	 */ _advancedOptionsCollapsibleView;
    /**
	 * A switch button view controlling the "Match case" option.
	 */ _matchCaseSwitchView;
    /**
	 * A switch button view controlling the "Whole words only" option.
	 */ _wholeWordsOnlySwitchView;
    /**
	 * The replace button view.
	 */ _replaceButtonView;
    /**
	 * The replace all button view.
	 */ _replaceAllButtonView;
    /**
	 * The `div` aggregating the inputs.
	 */ _inputsDivView;
    /**
	 * The `div` aggregating the action buttons.
	 */ _actionButtonsDivView;
    /**
	 * Tracks information about the DOM focus in the form.
	 */ _focusTracker;
    /**
	 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
	 */ _keystrokes;
    /**
	 * A collection of views that can be focused in the form.
	 */ _focusables;
    /**
	 * Helps cycling over {@link #_focusables} in the form.
	 */ focusCycler;
    /**
	 * Creates a view of find and replace form.
	 *
	 * @param locale The localization services instance.
	 */ constructor(locale){
        super(locale);
        const t = locale.t;
        this.children = this.createCollection();
        this.set('matchCount', 0);
        this.set('highlightOffset', 0);
        this.set('isDirty', false);
        this.set('_areCommandsEnabled', {});
        this.set('_resultsCounterText', '');
        this.set('_matchCase', false);
        this.set('_wholeWordsOnly', false);
        this.bind('_searchResultsFound').to(this, 'matchCount', this, 'isDirty', (matchCount, isDirty)=>{
            return matchCount > 0 && !isDirty;
        });
        this._findInputView = this._createInputField(t('Find in text…'));
        this._findPrevButtonView = this._createButton({
            label: t('Previous result'),
            class: 'ck-button-prev',
            icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].previousArrow,
            keystroke: 'Shift+F3',
            tooltip: true
        });
        this._findNextButtonView = this._createButton({
            label: t('Next result'),
            class: 'ck-button-next',
            icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].previousArrow,
            keystroke: 'F3',
            tooltip: true
        });
        this._replaceInputView = this._createInputField(t('Replace with…'), 'ck-labeled-field-replace');
        this._inputsDivView = this._createInputsDiv();
        this._matchCaseSwitchView = this._createMatchCaseSwitch();
        this._wholeWordsOnlySwitchView = this._createWholeWordsOnlySwitch();
        this._advancedOptionsCollapsibleView = this._createAdvancedOptionsCollapsible();
        this._replaceAllButtonView = this._createButton({
            label: t('Replace all'),
            class: 'ck-button-replaceall',
            withText: true
        });
        this._replaceButtonView = this._createButton({
            label: t('Replace'),
            class: 'ck-button-replace',
            withText: true
        });
        this._findButtonView = this._createButton({
            label: t('Find'),
            class: 'ck-button-find ck-button-action',
            withText: true
        });
        this._actionButtonsDivView = this._createActionButtonsDiv();
        this._focusTracker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusTracker"]();
        this._keystrokes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeystrokeHandler"]();
        this._focusables = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewCollection"]();
        this.focusCycler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusCycler"]({
            focusables: this._focusables,
            focusTracker: this._focusTracker,
            keystrokeHandler: this._keystrokes,
            actions: {
                // Navigate form fields backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
                focusPrevious: 'shift + tab',
                // Navigate form fields forwards using the <kbd>Tab</kbd> key.
                focusNext: 'tab'
            }
        });
        this.children.addMany([
            this._inputsDivView,
            this._advancedOptionsCollapsibleView,
            this._actionButtonsDivView
        ]);
        this.setTemplate({
            tag: 'form',
            attributes: {
                class: [
                    'ck',
                    'ck-find-and-replace-form'
                ],
                tabindex: '-1'
            },
            children: this.children
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["submitHandler"])({
            view: this
        });
        this._initFocusCycling();
        this._initKeystrokeHandling();
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this._focusTracker.destroy();
        this._keystrokes.destroy();
    }
    /**
	 * @inheritDoc
	 */ focus(direction) {
        if (direction === -1) {
            this.focusCycler.focusLast();
        } else {
            this.focusCycler.focusFirst();
        }
    }
    /**
	 * Resets the form before re-appearing.
	 *
	 * It clears error messages, hides the match counter and disables the replace feature
	 * until the next hit of the "Find" button.
	 *
	 * **Note**: It does not reset inputs and options, though. This way the form works better in editors with
	 * disappearing toolbar (e.g. BalloonEditor): hiding the toolbar by accident (together with the find and replace UI)
	 * does not require filling the entire form again.
	 */ reset() {
        this._findInputView.errorText = null;
        this.isDirty = true;
    }
    /**
	 * Returns the value of the find input.
	 */ get _textToFind() {
        return this._findInputView.fieldView.element.value;
    }
    /**
	 * Returns the value of the replace input.
	 */ get _textToReplace() {
        return this._replaceInputView.fieldView.element.value;
    }
    /**
	 * Configures and returns the `<div>` aggregating all form inputs.
	 */ _createInputsDiv() {
        const locale = this.locale;
        const t = locale.t;
        const inputsDivView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"](locale);
        // Typing in the find field invalidates all previous results (the form is "dirty").
        this._findInputView.fieldView.on('input', ()=>{
            this.isDirty = true;
        });
        // Pressing prev/next buttons fires related event on the form.
        this._findPrevButtonView.delegate('execute').to(this, 'findPrevious');
        this._findNextButtonView.delegate('execute').to(this, 'findNext');
        // Prev/next buttons will be disabled when related editor command gets disabled.
        this._findPrevButtonView.bind('isEnabled').to(this, '_areCommandsEnabled', ({ findPrevious })=>findPrevious);
        this._findNextButtonView.bind('isEnabled').to(this, '_areCommandsEnabled', ({ findNext })=>findNext);
        this._injectFindResultsCounter();
        this._replaceInputView.bind('isEnabled').to(this, '_areCommandsEnabled', this, '_searchResultsFound', ({ replace }, resultsFound)=>replace && resultsFound);
        this._replaceInputView.bind('infoText').to(this._replaceInputView, 'isEnabled', this._replaceInputView, 'isFocused', (isEnabled, isFocused)=>{
            if (isEnabled || !isFocused) {
                return '';
            }
            return t('Tip: Find some text first in order to replace it.');
        });
        inputsDivView.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-find-and-replace-form__inputs'
                ]
            },
            children: [
                this._findInputView,
                this._findPrevButtonView,
                this._findNextButtonView,
                this._replaceInputView
            ]
        });
        return inputsDivView;
    }
    /**
	 * The action performed when the {@link #_findButtonView} is pressed.
	 */ _onFindButtonExecute() {
        // When hitting "Find" in an empty input, an error should be displayed.
        // Also, if the form was "dirty", it should remain so.
        if (!this._textToFind) {
            const t = this.t;
            this._findInputView.errorText = t('Text to find must not be empty.');
            return;
        }
        // Hitting "Find" automatically clears the dirty state.
        this.isDirty = false;
        this.fire('findNext', {
            searchText: this._textToFind,
            matchCase: this._matchCase,
            wholeWords: this._wholeWordsOnly
        });
    }
    /**
	 * Configures an injects the find results counter displaying a "N of M" label of the {@link #_findInputView}.
	 */ _injectFindResultsCounter() {
        const locale = this.locale;
        const t = locale.t;
        const bind = this.bindTemplate;
        const resultsCounterView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"](this.locale);
        this.bind('_resultsCounterText').to(this, 'highlightOffset', this, 'matchCount', (highlightOffset, matchCount)=>t('%0 of %1', [
                highlightOffset,
                matchCount
            ]));
        resultsCounterView.setTemplate({
            tag: 'span',
            attributes: {
                class: [
                    'ck',
                    'ck-results-counter',
                    // The counter only makes sense when the field text corresponds to search results in the editing.
                    bind.if('isDirty', 'ck-hidden')
                ]
            },
            children: [
                {
                    text: bind.to('_resultsCounterText')
                }
            ]
        });
        // The whole idea is that when the text of the counter changes, its width also increases/decreases and
        // it consumes more or less space over the input. The input, on the other hand, should adjust it's right
        // padding so its *entire* text always remains visible and available to the user.
        const updateFindInputPadding = ()=>{
            const inputElement = this._findInputView.fieldView.element;
            // Don't adjust the padding if the input (also: counter) were not rendered or not inserted into DOM yet.
            if (!inputElement || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isVisible"])(inputElement)) {
                return;
            }
            const counterWidth = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](resultsCounterView.element).width;
            const paddingPropertyName = locale.uiLanguageDirection === 'ltr' ? 'paddingRight' : 'paddingLeft';
            if (!counterWidth) {
                inputElement.style[paddingPropertyName] = '';
            } else {
                inputElement.style[paddingPropertyName] = `calc( 2 * var(--ck-spacing-standard) + ${counterWidth}px )`;
            }
        };
        // Adjust the input padding when the text of the counter changes, for instance "1 of 200" is narrower than "123 of 200".
        // Using "low" priority to let the text be set by the template binding first.
        this.on('change:_resultsCounterText', updateFindInputPadding, {
            priority: 'low'
        });
        // Adjust the input padding when the counter shows or hides. When hidden, there should be no padding. When it shows, the
        // padding should be set according to the text of the counter.
        // Using "low" priority to let the text be set by the template binding first.
        this.on('change:isDirty', updateFindInputPadding, {
            priority: 'low'
        });
        // Put the counter element next to the <input> in the find field.
        this._findInputView.template.children[0].children.push(resultsCounterView);
    }
    /**
	 * Creates the collapsible view aggregating the advanced search options.
	 */ _createAdvancedOptionsCollapsible() {
        const t = this.locale.t;
        const collapsible = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CollapsibleView"](this.locale, [
            this._matchCaseSwitchView,
            this._wholeWordsOnlySwitchView
        ]);
        collapsible.set({
            label: t('Advanced options'),
            isCollapsed: true
        });
        return collapsible;
    }
    /**
	 * Configures and returns the `<div>` element aggregating all form action buttons.
	 */ _createActionButtonsDiv() {
        const actionsDivView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"](this.locale);
        this._replaceButtonView.bind('isEnabled').to(this, '_areCommandsEnabled', this, '_searchResultsFound', ({ replace }, resultsFound)=>replace && resultsFound);
        this._replaceAllButtonView.bind('isEnabled').to(this, '_areCommandsEnabled', this, '_searchResultsFound', ({ replaceAll }, resultsFound)=>replaceAll && resultsFound);
        this._replaceButtonView.on('execute', ()=>{
            this.fire('replace', {
                searchText: this._textToFind,
                replaceText: this._textToReplace
            });
        });
        this._replaceAllButtonView.on('execute', ()=>{
            this.fire('replaceAll', {
                searchText: this._textToFind,
                replaceText: this._textToReplace
            });
            this.focus();
        });
        this._findButtonView.on('execute', this._onFindButtonExecute.bind(this));
        actionsDivView.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-find-and-replace-form__actions'
                ]
            },
            children: [
                this._replaceAllButtonView,
                this._replaceButtonView,
                this._findButtonView
            ]
        });
        return actionsDivView;
    }
    /**
	 * Creates, configures and returns and instance of a dropdown allowing users to narrow
	 * the search criteria down. The dropdown has a list with switch buttons for each option.
	 */ _createMatchCaseSwitch() {
        const t = this.locale.t;
        const matchCaseSwitchButton = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SwitchButtonView"](this.locale);
        matchCaseSwitchButton.set({
            label: t('Match case'),
            withText: true
        });
        // Let the switch be controlled by form's observable property.
        matchCaseSwitchButton.bind('isOn').to(this, '_matchCase');
        // // Update the state of the form when a switch is toggled.
        matchCaseSwitchButton.on('execute', ()=>{
            this._matchCase = !this._matchCase;
            // Toggling a switch makes the form dirty because this changes search criteria
            // just like typing text of the find input.
            this.isDirty = true;
        });
        return matchCaseSwitchButton;
    }
    /**
	 * Creates, configures and returns and instance of a dropdown allowing users to narrow
	 * the search criteria down. The dropdown has a list with switch buttons for each option.
	 */ _createWholeWordsOnlySwitch() {
        const t = this.locale.t;
        const wholeWordsOnlySwitchButton = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SwitchButtonView"](this.locale);
        wholeWordsOnlySwitchButton.set({
            label: t('Whole words only'),
            withText: true
        });
        // Let the switch be controlled by form's observable property.
        wholeWordsOnlySwitchButton.bind('isOn').to(this, '_wholeWordsOnly');
        // // Update the state of the form when a switch is toggled.
        wholeWordsOnlySwitchButton.on('execute', ()=>{
            this._wholeWordsOnly = !this._wholeWordsOnly;
            // Toggling a switch makes the form dirty because this changes search criteria
            // just like typing text of the find input.
            this.isDirty = true;
        });
        return wholeWordsOnlySwitchButton;
    }
    /**
	 * Initializes the {@link #_focusables} and {@link #_focusTracker} to allow navigation
	 * using <kbd>Tab</kbd> and <kbd>Shift</kbd>+<kbd>Tab</kbd> keystrokes in the right order.
	 */ _initFocusCycling() {
        const childViews = [
            this._findInputView,
            this._findPrevButtonView,
            this._findNextButtonView,
            this._replaceInputView,
            this._advancedOptionsCollapsibleView.buttonView,
            this._matchCaseSwitchView,
            this._wholeWordsOnlySwitchView,
            this._replaceAllButtonView,
            this._replaceButtonView,
            this._findButtonView
        ];
        childViews.forEach((v)=>{
            // Register the view as focusable.
            this._focusables.add(v);
            // Register the view in the focus tracker.
            this._focusTracker.add(v.element);
        });
    }
    /**
	 * Initializes the keystroke handling in the form.
	 */ _initKeystrokeHandling() {
        const stopPropagation = (data)=>data.stopPropagation();
        const stopPropagationAndPreventDefault = (data)=>{
            data.stopPropagation();
            data.preventDefault();
        };
        // Start listening for the keystrokes coming from #element.
        this._keystrokes.listenTo(this.element);
        // Find the next result upon F3.
        this._keystrokes.set('f3', (event)=>{
            stopPropagationAndPreventDefault(event);
            this._findNextButtonView.fire('execute');
        });
        // Find the previous result upon F3.
        this._keystrokes.set('shift+f3', (event)=>{
            stopPropagationAndPreventDefault(event);
            this._findPrevButtonView.fire('execute');
        });
        // Find or replace upon pressing Enter in the find and replace fields.
        this._keystrokes.set('enter', (event)=>{
            const target = event.target;
            if (target === this._findInputView.fieldView.element) {
                if (this._areCommandsEnabled.findNext) {
                    this._findNextButtonView.fire('execute');
                } else {
                    this._findButtonView.fire('execute');
                }
                stopPropagationAndPreventDefault(event);
            } else if (target === this._replaceInputView.fieldView.element && !this.isDirty) {
                this._replaceButtonView.fire('execute');
                stopPropagationAndPreventDefault(event);
            }
        });
        // Find previous upon pressing Shift+Enter in the find field.
        this._keystrokes.set('shift+enter', (event)=>{
            const target = event.target;
            if (target !== this._findInputView.fieldView.element) {
                return;
            }
            if (this._areCommandsEnabled.findPrevious) {
                this._findPrevButtonView.fire('execute');
            } else {
                this._findButtonView.fire('execute');
            }
            stopPropagationAndPreventDefault(event);
        });
        // Since the form is in the dropdown panel which is a child of the toolbar, the toolbar's
        // keystroke handler would take over the key management in the URL input.
        // We need to prevent this ASAP. Otherwise, the basic caret movement using the arrow keys will be impossible.
        this._keystrokes.set('arrowright', stopPropagation);
        this._keystrokes.set('arrowleft', stopPropagation);
        this._keystrokes.set('arrowup', stopPropagation);
        this._keystrokes.set('arrowdown', stopPropagation);
    }
    /**
	 * Creates a button view.
	 *
	 * @param options The properties of the `ButtonView`.
	 * @returns The button view instance.
	 */ _createButton(options) {
        const button = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](this.locale);
        button.set(options);
        return button;
    }
    /**
	 * Creates a labeled input view.
	 *
	 * @param label The input label.
	 * @returns The labeled input view instance.
	 */ _createInputField(label, className) {
        const labeledInput = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LabeledFieldView"](this.locale, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLabeledInputText"]);
        labeledInput.label = label;
        labeledInput.class = className;
        return labeledInput;
    }
}
var loupeIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m12.87 13.786 1.532-1.286 3.857 4.596a1 1 0 1 1-1.532 1.286l-3.857-4.596z\"/><path d=\"M16.004 8.5a6.5 6.5 0 0 1-9.216 5.905c-1.154-.53-.863-1.415-.663-1.615.194-.194.564-.592 1.635-.141a4.5 4.5 0 0 0 5.89-5.904l-.104-.227 1.332-1.331c.045-.046.196-.041.224.007a6.47 6.47 0 0 1 .902 3.306zm-3.4-5.715c.562.305.742 1.106.354 1.494-.388.388-.995.414-1.476.178a4.5 4.5 0 0 0-6.086 5.882l.114.236-1.348 1.349c-.038.037-.17.022-.198-.023a6.5 6.5 0 0 1 5.54-9.9 6.469 6.469 0 0 1 3.1.784z\"/><path d=\"M4.001 11.93.948 8.877a.2.2 0 0 1 .141-.341h6.106a.2.2 0 0 1 .141.341L4.283 11.93a.2.2 0 0 1-.282 0zm11.083-6.789 3.053 3.053a.2.2 0 0 1-.14.342H11.89a.2.2 0 0 1-.14-.342l3.052-3.053a.2.2 0 0 1 .282 0z\"/></svg>";
/**
 * The default find and replace UI.
 *
 * It registers the `'findAndReplace'` UI button in the editor's {@link module:ui/componentfactory~ComponentFactory component factory}.
 * that uses the {@link module:find-and-replace/findandreplace~FindAndReplace FindAndReplace} plugin API.
 */ class FindAndReplaceUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Dialog"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FindAndReplaceUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * A reference to the find and replace form view.
	 */ formView;
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('findAndReplace.uiType', 'dialog');
        this.formView = null;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const isUiUsingDropdown = editor.config.get('findAndReplace.uiType') === 'dropdown';
        const findCommand = editor.commands.get('find');
        const t = this.editor.t;
        // Register the toolbar component: dropdown or button (that opens a dialog).
        editor.ui.componentFactory.add('findAndReplace', ()=>{
            let view;
            if (isUiUsingDropdown) {
                view = this._createDropdown();
                // Button should be disabled when in source editing mode. See #10001.
                view.bind('isEnabled').to(findCommand);
            } else {
                view = this._createDialogButtonForToolbar();
            }
            editor.keystrokes.set('Ctrl+F', (data, cancelEvent)=>{
                if (!findCommand.isEnabled) {
                    return;
                }
                if (view instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DropdownView"]) {
                    const dropdownButtonView = view.buttonView;
                    if (!dropdownButtonView.isOn) {
                        dropdownButtonView.fire('execute');
                    }
                } else {
                    if (view.isOn) {
                        // If the dialog is open, do not close it. Instead focus it.
                        // Unfortunately we can't simply use:
                        // 	this.formView!.focus();
                        // because it would always move focus to the first input field, which we don't want.
                        editor.plugins.get('Dialog').view.focus();
                    } else {
                        view.fire('execute');
                    }
                }
                cancelEvent();
            });
            return view;
        });
        if (!isUiUsingDropdown) {
            editor.ui.componentFactory.add('menuBar:findAndReplace', ()=>{
                return this._createDialogButtonForMenuBar();
            });
        }
        // Add the information about the keystroke to the accessibility database.
        editor.accessibility.addKeystrokeInfos({
            keystrokes: [
                {
                    label: t('Find in the document'),
                    keystroke: 'CTRL+F'
                }
            ]
        });
    }
    /**
	 * Creates a dropdown containing the find and replace form.
	 */ _createDropdown() {
        const editor = this.editor;
        const t = editor.locale.t;
        const dropdownView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDropdown"])(editor.locale);
        dropdownView.once('change:isOpen', ()=>{
            this.formView = this._createFormView();
            this.formView.children.add(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FormHeaderView"](editor.locale, {
                label: t('Find and replace')
            }), 0);
            dropdownView.panelView.children.add(this.formView);
        });
        // Every time a dropdown is opened, the search text field should get focused and selected for better UX.
        // Note: Using the low priority here to make sure the following listener starts working after
        // the default action of the drop-down is executed (i.e. the panel showed up). Otherwise,
        // the invisible form/input cannot be focused/selected.
        //
        // Each time a dropdown is closed, move the focus back to the find and replace toolbar button
        // and let the find and replace editing feature know that all search results can be invalidated
        // and no longer should be marked in the content.
        dropdownView.on('change:isOpen', (event, name, isOpen)=>{
            if (isOpen) {
                this._setupFormView();
            } else {
                this.fire('searchReseted');
            }
        }, {
            priority: 'low'
        });
        dropdownView.buttonView.set({
            icon: loupeIcon,
            label: t('Find and replace'),
            keystroke: 'CTRL+F',
            tooltip: true
        });
        return dropdownView;
    }
    /**
	 * Creates a button that opens a dialog with the find and replace form.
	 */ _createDialogButtonForToolbar() {
        const editor = this.editor;
        const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
        const dialog = editor.plugins.get('Dialog');
        buttonView.set({
            tooltip: true
        });
        // Button should be on when the find and replace dialog is opened.
        buttonView.bind('isOn').to(dialog, 'id', (id)=>id === 'findAndReplace');
        // Every time a dialog is opened, the search text field should get focused and selected for better UX.
        // Each time a dialog is closed, move the focus back to the find and replace toolbar button
        // and let the find and replace editing feature know that all search results can be invalidated
        // and no longer should be marked in the content.
        buttonView.on('execute', ()=>{
            if (buttonView.isOn) {
                dialog.hide();
            } else {
                this._showDialog();
            }
        });
        return buttonView;
    }
    /**
	 * Creates a button for for menu bar that will show find and replace dialog.
	 */ _createDialogButtonForMenuBar() {
        const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
        const dialogPlugin = this.editor.plugins.get('Dialog');
        const dialog = this.editor.plugins.get('Dialog');
        buttonView.set({
            role: 'menuitemcheckbox',
            isToggleable: true
        });
        // Button should be on when the find and replace dialog is opened.
        buttonView.bind('isOn').to(dialog, 'id', (id)=>id === 'findAndReplace');
        buttonView.on('execute', ()=>{
            if (dialogPlugin.id === 'findAndReplace') {
                dialogPlugin.hide();
                return;
            }
            this._showDialog();
        });
        return buttonView;
    }
    /**
	 * Creates a button for find and replace command to use either in toolbar or in menu bar.
	 */ _createButton(ButtonClass) {
        const editor = this.editor;
        const findCommand = editor.commands.get('find');
        const buttonView = new ButtonClass(editor.locale);
        const t = editor.locale.t;
        // Button should be disabled when in source editing mode. See #10001.
        buttonView.bind('isEnabled').to(findCommand);
        buttonView.set({
            icon: loupeIcon,
            label: t('Find and replace'),
            keystroke: 'CTRL+F'
        });
        return buttonView;
    }
    /**
	 * Shows the find and replace dialog.
	 */ _showDialog() {
        const editor = this.editor;
        const dialog = editor.plugins.get('Dialog');
        const t = editor.locale.t;
        if (!this.formView) {
            this.formView = this._createFormView();
        }
        dialog.show({
            id: 'findAndReplace',
            title: t('Find and replace'),
            content: this.formView,
            position: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DialogViewPosition"].EDITOR_TOP_SIDE,
            onShow: ()=>{
                this._setupFormView();
            },
            onHide: ()=>{
                this.fire('searchReseted');
            }
        });
    }
    /**
	 * Sets up the form view for the find and replace.
	 *
	 * @param formView A related form view.
	 */ _createFormView() {
        const editor = this.editor;
        const formView = new ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CssTransitionDisablerMixin"])(FindAndReplaceFormView))(editor.locale);
        const commands = editor.commands;
        const findAndReplaceEditing = this.editor.plugins.get('FindAndReplaceEditing');
        const editingState = findAndReplaceEditing.state;
        formView.bind('highlightOffset').to(editingState, 'highlightedOffset');
        // Let the form know how many results were found in total.
        formView.listenTo(editingState.results, 'change', ()=>{
            formView.matchCount = editingState.results.length;
        });
        // Command states are used to enable/disable individual form controls.
        // To keep things simple, instead of binding 4 individual observables, there's only one that combines every
        // commands' isEnabled state. Yes, it will change more often but this simplifies the structure of the form.
        const findNextCommand = commands.get('findNext');
        const findPreviousCommand = commands.get('findPrevious');
        const replaceCommand = commands.get('replace');
        const replaceAllCommand = commands.get('replaceAll');
        formView.bind('_areCommandsEnabled').to(findNextCommand, 'isEnabled', findPreviousCommand, 'isEnabled', replaceCommand, 'isEnabled', replaceAllCommand, 'isEnabled', (findNext, findPrevious, replace, replaceAll)=>({
                findNext,
                findPrevious,
                replace,
                replaceAll
            }));
        // The UI plugin works as an interface between the form and the editing part of the feature.
        formView.delegate('findNext', 'findPrevious', 'replace', 'replaceAll').to(this);
        // Let the feature know that search results are no longer relevant because the user changed the searched phrase
        // (or options) but didn't hit the "Find" button yet (e.g. still typing).
        formView.on('change:isDirty', (evt, data, isDirty)=>{
            if (isDirty) {
                this.fire('searchReseted');
            }
        });
        return formView;
    }
    /**
	 * Clears the find and replace form and focuses the search text field.
	 */ _setupFormView() {
        this.formView.disableCssTransitions();
        this.formView.reset();
        this.formView._findInputView.fieldView.select();
        this.formView.enableCssTransitions();
    }
}
/**
 * The find command. It is used by the {@link module:find-and-replace/findandreplace~FindAndReplace find and replace feature}.
 */ class FindCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * The find and replace state object used for command operations.
	 */ _state;
    /**
	 * Creates a new `FindCommand` instance.
	 *
	 * @param editor The editor on which this command will be used.
	 * @param state An object to hold plugin state.
	 */ constructor(editor, state){
        super(editor);
        // The find command is always enabled.
        this.isEnabled = true;
        // It does not affect data so should be enabled in read-only mode.
        this.affectsData = false;
        this._state = state;
    }
    /**
	 * Executes the command.
	 *
	 * @param callbackOrText
	 * @param options Options object.
	 * @param options.matchCase If set to `true`, the letter case will be matched.
	 * @param options.wholeWords If set to `true`, only whole words that match `callbackOrText` will be matched.
	 *
	 * @fires execute
	 */ execute(callbackOrText, { matchCase, wholeWords } = {}) {
        const { editor } = this;
        const { model } = editor;
        const findAndReplaceUtils = editor.plugins.get('FindAndReplaceUtils');
        let findCallback;
        let callbackSearchText = '';
        // Allow to execute `find()` on a plugin with a keyword only.
        if (typeof callbackOrText === 'string') {
            findCallback = (...args)=>({
                    results: findAndReplaceUtils.findByTextCallback(callbackOrText, {
                        matchCase,
                        wholeWords
                    })(...args),
                    searchText: callbackOrText
                });
        } else {
            findCallback = callbackOrText;
        }
        // Wrap the callback to get the search text that will be assigned to the state.
        const oldCallback = findCallback;
        findCallback = (...args)=>{
            const result = oldCallback(...args);
            if (result && 'searchText' in result) {
                callbackSearchText = result.searchText;
            }
            return result;
        };
        // Initial search is done on all nodes in all roots inside the content.
        const results = model.document.getRootNames().reduce((currentResults, rootName)=>findAndReplaceUtils.updateFindResultFromRange(model.createRangeIn(model.document.getRoot(rootName)), model, findCallback, currentResults), null);
        this._state.clear(model);
        this._state.results.addMany(results);
        this._state.highlightedResult = results.get(0);
        this._state.searchText = callbackSearchText;
        if (findCallback) {
            this._state.lastSearchCallback = findCallback;
        }
        this._state.matchCase = !!matchCase;
        this._state.matchWholeWords = !!wholeWords;
        return {
            results,
            findCallback
        };
    }
}
/**
 * The object storing find and replace plugin state for a given editor instance.
 */ class FindAndReplaceState extends /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObservableMixin"])() {
    /**
	 * Creates an instance of the state.
	 */ constructor(model){
        super();
        this.set('results', new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"]());
        this.set('highlightedResult', null);
        this.set('highlightedOffset', 0);
        this.set('searchText', '');
        this.set('replaceText', '');
        this.set('lastSearchCallback', null);
        this.set('matchCase', false);
        this.set('matchWholeWords', false);
        this.results.on('change', (eventInfo, { removed, index })=>{
            if (Array.from(removed).length) {
                let highlightedResultRemoved = false;
                model.change((writer)=>{
                    for (const removedResult of removed){
                        if (this.highlightedResult === removedResult) {
                            highlightedResultRemoved = true;
                        }
                        if (model.markers.has(removedResult.marker.name)) {
                            writer.removeMarker(removedResult.marker);
                        }
                    }
                });
                if (highlightedResultRemoved) {
                    const nextHighlightedIndex = index >= this.results.length ? 0 : index;
                    this.highlightedResult = this.results.get(nextHighlightedIndex);
                }
            }
        });
        this.on('change:highlightedResult', ()=>{
            this.refreshHighlightOffset(model);
        });
    }
    /**
	 * Cleans the state up and removes markers from the model.
	 */ clear(model) {
        this.searchText = '';
        model.change((writer)=>{
            if (this.highlightedResult) {
                const oldMatchId = this.highlightedResult.marker.name.split(':')[1];
                const oldMarker = model.markers.get(`findResultHighlighted:${oldMatchId}`);
                if (oldMarker) {
                    writer.removeMarker(oldMarker);
                }
            }
            [
                ...this.results
            ].forEach(({ marker })=>{
                writer.removeMarker(marker);
            });
        });
        this.results.clear();
    }
    /**
	 * Refreshes the highlight result offset based on it's index within the result list.
	 */ refreshHighlightOffset(model) {
        const { highlightedResult, results } = this;
        if (highlightedResult) {
            this.highlightedOffset = sortSearchResultsByMarkerPositions(model, [
                ...results
            ]).indexOf(highlightedResult) + 1;
        } else {
            this.highlightedOffset = 0;
        }
    }
}
/**
 * Sorts search results by marker positions. Make sure that the results are sorted in the same order as they appear in the document
 * to avoid issues with the `find next` command. Apparently, the order of the results in the state might be different than the order
 * of the markers in the model.
 */ function sortSearchResultsByMarkerPositions(model, results) {
    const sortMapping = {
        before: -1,
        same: 0,
        after: 1,
        different: 1
    };
    // `compareWith` doesn't play well with multi-root documents, so we need to sort results by root name first
    // and then sort them within each root. It prevents "random" order of results when the document has multiple roots.
    // See more: https://github.com/ckeditor/ckeditor5/pull/17292#issuecomment-2442084549
    return model.document.getRootNames().flatMap((rootName)=>results.filter((result)=>result.marker.getStart().root.rootName === rootName).sort((a, b)=>sortMapping[a.marker.getStart().compareWith(b.marker.getStart())]));
}
class ReplaceCommandBase extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * The find and replace state object used for command operations.
	 */ _state;
    /**
	 * Creates a new `ReplaceCommand` instance.
	 *
	 * @param editor Editor on which this command will be used.
	 * @param state An object to hold plugin state.
	 */ constructor(editor, state){
        super(editor);
        // The replace command is always enabled.
        this.isEnabled = true;
        this._state = state;
        // Since this command executes on particular result independent of selection, it should be checked directly in execute block.
        this._isEnabledBasedOnSelection = false;
    }
    /**
	 * Common logic for both `replace` commands.
	 * Replace a given find result by a string or a callback.
	 *
	 * @param result A single result from the find command.
	 */ _replace(replacementText, result) {
        const { model } = this.editor;
        const range = result.marker.getRange();
        // Don't replace a result that is in non-editable place.
        if (!model.canEditAt(range)) {
            return;
        }
        model.change((writer)=>{
            // Don't replace a result (marker) that found its way into the $graveyard (e.g. removed by collaborators).
            if (range.root.rootName === '$graveyard') {
                this._state.results.remove(result);
                return;
            }
            let textAttributes = {};
            for (const item of range.getItems()){
                if (item.is('$text') || item.is('$textProxy')) {
                    textAttributes = item.getAttributes();
                    break;
                }
            }
            model.insertContent(writer.createText(replacementText, textAttributes), range);
            if (this._state.results.has(result)) {
                this._state.results.remove(result);
            }
        });
    }
}
/**
 * The replace command. It is used by the {@link module:find-and-replace/findandreplace~FindAndReplace find and replace feature}.
 */ class ReplaceCommand extends ReplaceCommandBase {
    /**
	 * Replace a given find result by a string or a callback.
	 *
	 * @param result A single result from the find command.
	 *
	 * @fires execute
	 */ execute(replacementText, result) {
        // We save highlight offset here, as the information about the highlighted result will be lost after the changes.
        //
        // It happens because result list is partially regenerated if the result is removed from the paragraph.
        // Partially means that all sibling result items that are placed in the same paragraph are removed and added again,
        // which causes the highlighted result to be malformed (usually it's set to first but it's not guaranteed).
        //
        // While this saving can be done in editing state, it's better to keep it here, as it's a part of the command logic
        // and might be super tricky to implement in multi-root documents.
        //
        // Keep in mind that the highlighted offset is indexed from 1, as it's displayed to the user. It's why we subtract 1 here.
        //
        // More info: https://github.com/ckeditor/ckeditor5/issues/16648
        const oldHighlightOffset = Math.max(this._state.highlightedOffset - 1, 0);
        this._replace(replacementText, result);
        // Let's revert the highlight offset to the previous value.
        if (this._state.results.length) {
            // Highlight offset operates on sorted array, so we need to sort the results first.
            // It's not guaranteed that items in state results are sorted, usually they are, but it's not guaranteed when
            // the result is removed from the paragraph with other highlighted results.
            const sortedResults = sortSearchResultsByMarkerPositions(this.editor.model, [
                ...this._state.results
            ]);
            // Just make sure that we don't overflow the results array, so use modulo.
            this._state.highlightedResult = sortedResults[oldHighlightOffset % sortedResults.length];
        }
    }
}
/**
 * The replace all command. It is used by the {@link module:find-and-replace/findandreplace~FindAndReplace find and replace feature}.
 */ class ReplaceAllCommand extends ReplaceCommandBase {
    /**
	 * Replaces all the occurrences of `textToReplace` with a given `newText` string.
	 *
	 * ```ts
	 *	replaceAllCommand.execute( 'replaceAll', 'new text replacement', 'text to replace' );
	 * ```
	 *
	 * Alternatively you can call it from editor instance:
	 *
	 * ```ts
	 *	editor.execute( 'replaceAll', 'new text', 'old text' );
	 * ```
	 *
	 * @param newText Text that will be inserted to the editor for each match.
	 * @param textToReplace Text to be replaced or a collection of matches
	 * as returned by the find command.
	 *
	 * @fires module:core/command~Command#event:execute
	 */ execute(newText, textToReplace) {
        const { editor } = this;
        const { model } = editor;
        const findAndReplaceUtils = editor.plugins.get('FindAndReplaceUtils');
        const results = textToReplace instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"] ? textToReplace : model.document.getRootNames().reduce((currentResults, rootName)=>findAndReplaceUtils.updateFindResultFromRange(model.createRangeIn(model.document.getRoot(rootName)), model, findAndReplaceUtils.findByTextCallback(textToReplace, this._state), currentResults), null);
        if (results.length) {
            // Wrapped in single change will batch it into one transaction.
            model.change(()=>{
                [
                    ...results
                ].forEach((searchResult)=>{
                    // Just reuse logic from the replace command to replace a single match.
                    this._replace(newText, searchResult);
                });
            });
        }
    }
}
/**
 * The find next command. Moves the highlight to the next search result.
 *
 * It is used by the {@link module:find-and-replace/findandreplace~FindAndReplace find and replace feature}.
 */ class FindNextCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * The find and replace state object used for command operations.
	 */ _state;
    /**
	 * Creates a new `FindNextCommand` instance.
	 *
	 * @param editor The editor on which this command will be used.
	 * @param state An object to hold plugin state.
	 */ constructor(editor, state){
        super(editor);
        // It does not affect data so should be enabled in read-only mode.
        this.affectsData = false;
        this._state = state;
        this.isEnabled = false;
        this.listenTo(this._state.results, 'change', ()=>{
            this.isEnabled = this._state.results.length > 1;
        });
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        this.isEnabled = this._state.results.length > 1;
    }
    /**
	 * @inheritDoc
	 */ execute() {
        const results = this._state.results;
        const currentIndex = results.getIndex(this._state.highlightedResult);
        const nextIndex = currentIndex + 1 >= results.length ? 0 : currentIndex + 1;
        this._state.highlightedResult = this._state.results.get(nextIndex);
    }
}
/**
 * The find previous command. Moves the highlight to the previous search result.
 *
 * It is used by the {@link module:find-and-replace/findandreplace~FindAndReplace find and replace feature}.
 */ class FindPreviousCommand extends FindNextCommand {
    /**
	 * @inheritDoc
	 */ execute() {
        const results = this._state.results;
        const currentIndex = results.getIndex(this._state.highlightedResult);
        const previousIndex = currentIndex - 1 < 0 ? this._state.results.length - 1 : currentIndex - 1;
        this._state.highlightedResult = this._state.results.get(previousIndex);
    }
}
/**
 * A set of helpers related to find and replace.
 */ class FindAndReplaceUtils extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FindAndReplaceUtils';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * Executes findCallback and updates search results list.
	 *
	 * @param range The model range to scan for matches.
	 * @param model The model.
	 * @param findCallback The callback that should return `true` if provided text matches the search term.
	 * @param startResults An optional collection of find matches that the function should
	 * start with. This would be a collection returned by a previous `updateFindResultFromRange()` call.
	 * @returns A collection of objects describing find match.
	 *
	 * An example structure:
	 *
	 * ```js
	 * {
	 *	id: resultId,
	 *	label: foundItem.label,
	 *	marker
	 *	}
	 * ```
	 */ updateFindResultFromRange(range, model, findCallback, startResults) {
        const results = startResults || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"]();
        const checkIfResultAlreadyOnList = (marker)=>results.find((markerItem)=>{
                const { marker: resultsMarker } = markerItem;
                const resultRange = resultsMarker.getRange();
                const markerRange = marker.getRange();
                return resultRange.isEqual(markerRange);
            });
        model.change((writer)=>{
            [
                ...range
            ].forEach(({ type, item })=>{
                if (type === 'elementStart') {
                    if (model.schema.checkChild(item, '$text')) {
                        let foundItems = findCallback({
                            item,
                            text: this.rangeToText(model.createRangeIn(item))
                        });
                        if (!foundItems) {
                            return;
                        }
                        if ('results' in foundItems) {
                            foundItems = foundItems.results;
                        }
                        foundItems.forEach((foundItem)=>{
                            const resultId = `findResult:${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])()}`;
                            const marker = writer.addMarker(resultId, {
                                usingOperation: false,
                                affectsData: false,
                                range: writer.createRange(writer.createPositionAt(item, foundItem.start), writer.createPositionAt(item, foundItem.end))
                            });
                            const index = findInsertIndex(results, marker);
                            if (!checkIfResultAlreadyOnList(marker)) {
                                results.add({
                                    id: resultId,
                                    label: foundItem.label,
                                    marker
                                }, index);
                            }
                        });
                    }
                }
            });
        });
        return results;
    }
    /**
	 * Returns text representation of a range. The returned text length should be the same as range length.
	 * In order to achieve this, this function will replace inline elements (text-line) as new line character ("\n").
	 *
	 * @param range The model range.
	 * @returns The text content of the provided range.
	 */ rangeToText(range) {
        return Array.from(range.getItems({
            shallow: true
        })).reduce((rangeText, node)=>{
            // Trim text to a last occurrence of an inline element and update range start.
            if (!(node.is('$text') || node.is('$textProxy'))) {
                // Editor has only one inline element defined in schema: `<softBreak>` which is treated as new line character in blocks.
                // Special handling might be needed for other inline elements (inline widgets).
                return `${rangeText}\n`;
            }
            return rangeText + node.data;
        }, '');
    }
    /**
	 * Creates a text matching callback for a specified search term and matching options.
	 *
	 * @param searchTerm The search term.
	 * @param options Matching options.
	 * 	- options.matchCase=false If set to `true` letter casing will be ignored.
	 * 	- options.wholeWords=false If set to `true` only whole words that match `callbackOrText` will be matched.
	 */ findByTextCallback(searchTerm, options) {
        let flags = 'gu';
        if (!options.matchCase) {
            flags += 'i';
        }
        let regExpQuery = `(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$escapeRegExp$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__escapeRegExp$3e$__["escapeRegExp"])(searchTerm)})`;
        if (options.wholeWords) {
            const nonLetterGroup = '[^a-zA-Z\u00C0-\u024F\u1E00-\u1EFF]';
            if (!new RegExp('^' + nonLetterGroup).test(searchTerm)) {
                regExpQuery = `(^|${nonLetterGroup}|_)${regExpQuery}`;
            }
            if (!new RegExp(nonLetterGroup + '$').test(searchTerm)) {
                regExpQuery = `${regExpQuery}(?=_|${nonLetterGroup}|$)`;
            }
        }
        const regExp = new RegExp(regExpQuery, flags);
        function findCallback({ text }) {
            const matches = [
                ...text.matchAll(regExp)
            ];
            return matches.map(regexpMatchToFindResult);
        }
        return findCallback;
    }
}
// Finds the appropriate index in the resultsList Collection.
function findInsertIndex(resultsList, markerToInsert) {
    const result = resultsList.find(({ marker })=>{
        return markerToInsert.getStart().isBefore(marker.getStart());
    });
    return result ? resultsList.getIndex(result) : resultsList.length;
}
/**
 *  Maps RegExp match result to find result.
 */ function regexpMatchToFindResult(matchResult) {
    const lastGroupIndex = matchResult.length - 1;
    let startOffset = matchResult.index;
    // Searches with match all flag have an extra matching group with empty string or white space matched before the word.
    // If the search term starts with the space already, there is no extra group even with match all flag on.
    if (matchResult.length === 3) {
        startOffset += matchResult[1].length;
    }
    return {
        label: matchResult[lastGroupIndex],
        start: startOffset,
        end: startOffset + matchResult[lastGroupIndex].length
    };
}
const HIGHLIGHT_CLASS = 'ck-find-result_selected';
/**
 * Implements the editing part for find and replace plugin. For example conversion, commands etc.
 */ class FindAndReplaceEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            FindAndReplaceUtils
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FindAndReplaceEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * An object storing the find and replace state within a given editor instance.
	 */ state;
    /**
	 * @inheritDoc
	 */ init() {
        this.state = new FindAndReplaceState(this.editor.model);
        this.set('_isSearchActive', false);
        this._defineConverters();
        this._defineCommands();
        this.listenTo(this.state, 'change:highlightedResult', (eventInfo, name, newValue, oldValue)=>{
            const { model } = this.editor;
            model.change((writer)=>{
                if (oldValue) {
                    const oldMatchId = oldValue.marker.name.split(':')[1];
                    const oldMarker = model.markers.get(`findResultHighlighted:${oldMatchId}`);
                    if (oldMarker) {
                        writer.removeMarker(oldMarker);
                    }
                }
                if (newValue) {
                    const newMatchId = newValue.marker.name.split(':')[1];
                    writer.addMarker(`findResultHighlighted:${newMatchId}`, {
                        usingOperation: false,
                        affectsData: false,
                        range: newValue.marker.getRange()
                    });
                }
            });
        });
        /* istanbul ignore next -- @preserve */ const scrollToHighlightedResult = (eventInfo, name, newValue)=>{
            if (newValue) {
                const domConverter = this.editor.editing.view.domConverter;
                const viewRange = this.editor.editing.mapper.toViewRange(newValue.marker.getRange());
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scrollViewportToShowTarget"])({
                    target: domConverter.viewRangeToDom(viewRange),
                    viewportOffset: 40
                });
            }
        };
        const debouncedScrollListener = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$debounce$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__debounce$3e$__["debounce"])(scrollToHighlightedResult.bind(this), 32);
        // Debounce scroll as highlight might be changed very frequently, e.g. when there's a replace all command.
        this.listenTo(this.state, 'change:highlightedResult', debouncedScrollListener, {
            priority: 'low'
        });
        // It's possible that the editor will get destroyed before debounced call kicks in.
        // This would result with accessing a view three that is no longer in DOM.
        this.listenTo(this.editor, 'destroy', debouncedScrollListener.cancel);
        this.on('change:_isSearchActive', (evt, name, isSearchActive)=>{
            if (isSearchActive) {
                this.listenTo(this.editor.model.document, 'change:data', this._onDocumentChange);
            } else {
                this.stopListening(this.editor.model.document, 'change:data', this._onDocumentChange);
            }
        });
    }
    /**
	 * Initiate a search.
	 */ find(callbackOrText, findAttributes) {
        this._isSearchActive = true;
        this.editor.execute('find', callbackOrText, findAttributes);
        return this.state.results;
    }
    /**
	 * Stops active results from updating, and clears out the results.
	 */ stop() {
        this.state.clear(this.editor.model);
        this._isSearchActive = false;
    }
    /**
	 * Sets up the commands.
	 */ _defineCommands() {
        this.editor.commands.add('find', new FindCommand(this.editor, this.state));
        this.editor.commands.add('findNext', new FindNextCommand(this.editor, this.state));
        this.editor.commands.add('findPrevious', new FindPreviousCommand(this.editor, this.state));
        this.editor.commands.add('replace', new ReplaceCommand(this.editor, this.state));
        this.editor.commands.add('replaceAll', new ReplaceAllCommand(this.editor, this.state));
    }
    /**
	 * Sets up the marker downcast converters for search results highlighting.
	 */ _defineConverters() {
        const { editor } = this;
        // Setup the marker highlighting conversion.
        editor.conversion.for('editingDowncast').markerToHighlight({
            model: 'findResult',
            view: ({ markerName })=>{
                const [, id] = markerName.split(':');
                // Marker removal from the view has a bug: https://github.com/ckeditor/ckeditor5/issues/7499
                // A minimal option is to return a new object for each converted marker...
                return {
                    name: 'span',
                    classes: [
                        'ck-find-result'
                    ],
                    attributes: {
                        // ...however, adding a unique attribute should be future-proof..
                        'data-find-result': id
                    }
                };
            }
        });
        editor.conversion.for('editingDowncast').markerToHighlight({
            model: 'findResultHighlighted',
            view: ({ markerName })=>{
                const [, id] = markerName.split(':');
                // Marker removal from the view has a bug: https://github.com/ckeditor/ckeditor5/issues/7499
                // A minimal option is to return a new object for each converted marker...
                return {
                    name: 'span',
                    classes: [
                        HIGHLIGHT_CLASS
                    ],
                    attributes: {
                        // ...however, adding a unique attribute should be future-proof..
                        'data-find-result': id
                    }
                };
            }
        });
    }
    /**
	 * Reacts to document changes in order to update search list.
	 */ _onDocumentChange = ()=>{
        const changedNodes = new Set();
        const removedMarkers = new Set();
        const model = this.editor.model;
        const { results } = this.state;
        const changes = model.document.differ.getChanges();
        const changedMarkers = model.document.differ.getChangedMarkers();
        // Get nodes in which changes happened to re-run a search callback on them.
        changes.forEach((change)=>{
            if (!change.position) {
                return;
            }
            if (change.name === '$text' || change.position.nodeAfter && model.schema.isInline(change.position.nodeAfter)) {
                changedNodes.add(change.position.parent);
                [
                    ...model.markers.getMarkersAtPosition(change.position)
                ].forEach((markerAtChange)=>{
                    removedMarkers.add(markerAtChange.name);
                });
            } else if (change.type === 'insert' && change.position.nodeAfter) {
                changedNodes.add(change.position.nodeAfter);
            }
        });
        // Get markers from removed nodes also.
        changedMarkers.forEach(({ name, data: { newRange } })=>{
            if (newRange && newRange.start.root.rootName === '$graveyard') {
                removedMarkers.add(name);
            }
        });
        // Get markers from the updated nodes and remove all (search will be re-run on these nodes).
        changedNodes.forEach((node)=>{
            const markersInNode = [
                ...model.markers.getMarkersIntersectingRange(model.createRangeIn(node))
            ];
            markersInNode.forEach((marker)=>removedMarkers.add(marker.name));
        });
        // Remove results from the changed part of content.
        removedMarkers.forEach((markerName)=>{
            if (!results.has(markerName)) {
                return;
            }
            if (results.get(markerName) === this.state.highlightedResult) {
                this.state.highlightedResult = null;
            }
            results.remove(markerName);
        });
        // Run search callback again on updated nodes.
        const changedSearchResults = [];
        const findAndReplaceUtils = this.editor.plugins.get('FindAndReplaceUtils');
        changedNodes.forEach((nodeToCheck)=>{
            const changedNodeSearchResults = findAndReplaceUtils.updateFindResultFromRange(model.createRangeOn(nodeToCheck), model, this.state.lastSearchCallback, results);
            changedSearchResults.push(...changedNodeSearchResults);
        });
        changedMarkers.forEach((markerToCheck)=>{
            // Handle search result highlight update when T&C plugin is active.
            // Lookup is performed only on newly inserted markers.
            if (markerToCheck.data.newRange) {
                const changedNodeSearchResults = findAndReplaceUtils.updateFindResultFromRange(markerToCheck.data.newRange, model, this.state.lastSearchCallback, results);
                changedSearchResults.push(...changedNodeSearchResults);
            }
        });
        if (!this.state.highlightedResult && changedSearchResults.length) {
            // If there are found phrases but none is selected, select the first one.
            this.state.highlightedResult = changedSearchResults[0];
        } else {
            // If there is already highlight item then refresh highlight offset after appending new items.
            this.state.refreshHighlightOffset(model);
        }
    };
}
/**
 * The find and replace plugin.
 *
 * For a detailed overview, check the {@glink features/find-and-replace Find and replace feature documentation}.
 *
 * This is a "glue" plugin which loads the following plugins:
 *
 * * The {@link module:find-and-replace/findandreplaceediting~FindAndReplaceEditing find and replace editing feature},
 * * The {@link module:find-and-replace/findandreplaceui~FindAndReplaceUI find and replace UI feature}
 */ class FindAndReplace extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            FindAndReplaceEditing,
            FindAndReplaceUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FindAndReplace';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const ui = this.editor.plugins.get('FindAndReplaceUI');
        const findAndReplaceEditing = this.editor.plugins.get('FindAndReplaceEditing');
        const state = findAndReplaceEditing.state;
        ui.on('findNext', (event, data)=>{
            // Data is contained only for the "find" button.
            if (data) {
                state.searchText = data.searchText;
                findAndReplaceEditing.find(data.searchText, data);
            } else {
                // Find next arrow button press.
                this.editor.execute('findNext');
            }
        });
        ui.on('findPrevious', (event, data)=>{
            if (data && state.searchText !== data.searchText) {
                findAndReplaceEditing.find(data.searchText);
            } else {
                // Subsequent calls.
                this.editor.execute('findPrevious');
            }
        });
        ui.on('replace', (event, data)=>{
            if (state.searchText !== data.searchText) {
                findAndReplaceEditing.find(data.searchText);
            }
            const highlightedResult = state.highlightedResult;
            if (highlightedResult) {
                this.editor.execute('replace', data.replaceText, highlightedResult);
            }
        });
        ui.on('replaceAll', (event, data)=>{
            // The state hadn't been yet built for this search text.
            if (state.searchText !== data.searchText) {
                findAndReplaceEditing.find(data.searchText);
            }
            this.editor.execute('replaceAll', data.replaceText, state.results);
        });
        // Reset the state when the user invalidated last search results, for instance,
        // by starting typing another search query or changing options.
        ui.on('searchReseted', ()=>{
            state.clear(this.editor.model);
            findAndReplaceEditing.stop();
        });
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-font/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Font": (()=>Font),
    "FontBackgroundColor": (()=>FontBackgroundColor),
    "FontBackgroundColorEditing": (()=>FontBackgroundColorEditing),
    "FontBackgroundColorUI": (()=>FontBackgroundColorUI),
    "FontColor": (()=>FontColor),
    "FontColorEditing": (()=>FontColorEditing),
    "FontColorUI": (()=>FontColorUI),
    "FontFamily": (()=>FontFamily),
    "FontFamilyEditing": (()=>FontFamilyEditing),
    "FontFamilyUI": (()=>FontFamilyUI),
    "FontSize": (()=>FontSize),
    "FontSizeEditing": (()=>FontSizeEditing),
    "FontSizeUI": (()=>FontSizeUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
;
;
;
;
/**
 * The base font command.
 */ class FontCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * A model attribute on which this command operates.
	 */ attributeKey;
    /**
	 * Creates an instance of the command.
	 *
	 * @param editor Editor instance.
	 * @param attributeKey The name of a model attribute on which this command operates.
	 */ constructor(editor, attributeKey){
        super(editor);
        this.attributeKey = attributeKey;
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const doc = model.document;
        this.value = doc.selection.getAttribute(this.attributeKey);
        this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, this.attributeKey);
    }
    /**
	 * Executes the command. Applies the `value` of the {@link #attributeKey} to the selection.
	 * If no `value` is passed, it removes the attribute from the selection.
	 *
	 * @param options Options for the executed command.
	 * @param options.value The value to apply.
	 * @fires execute
	 */ execute(options = {}) {
        const model = this.editor.model;
        const document = model.document;
        const selection = document.selection;
        const value = options.value;
        const batch = options.batch;
        const updateAttribute = (writer)=>{
            if (selection.isCollapsed) {
                if (value) {
                    writer.setSelectionAttribute(this.attributeKey, value);
                } else {
                    writer.removeSelectionAttribute(this.attributeKey);
                }
            } else {
                const ranges = model.schema.getValidRanges(selection.getRanges(), this.attributeKey);
                for (const range of ranges){
                    if (value) {
                        writer.setAttribute(this.attributeKey, value, range);
                    } else {
                        writer.removeAttribute(this.attributeKey, range);
                    }
                }
            }
        };
        // In some scenarios, you may want to use a single undo step for multiple changes (e.g. in color picker).
        if (batch) {
            model.enqueueChange(batch, (writer)=>{
                updateAttribute(writer);
            });
        } else {
            model.change((writer)=>{
                updateAttribute(writer);
            });
        }
    }
}
/**
 * The name of the font size plugin.
 */ const FONT_SIZE = 'fontSize';
/**
 * The name of the font family plugin.
 */ const FONT_FAMILY = 'fontFamily';
/**
 * The name of the font color plugin.
 */ const FONT_COLOR = 'fontColor';
/**
 * The name of the font background color plugin.
 */ const FONT_BACKGROUND_COLOR = 'fontBackgroundColor';
/**
 * Builds a proper converter definition out of input data.
 */ function buildDefinition(modelAttributeKey, options) {
    const definition = {
        model: {
            key: modelAttributeKey,
            values: []
        },
        view: {},
        upcastAlso: {}
    };
    for (const option of options){
        definition.model.values.push(option.model);
        definition.view[option.model] = option.view;
        if (option.upcastAlso) {
            definition.upcastAlso[option.model] = option.upcastAlso;
        }
    }
    return definition;
}
/**
 * A {@link module:font/fontcolor~FontColor font color} and
 * {@link module:font/fontbackgroundcolor~FontBackgroundColor font background color} helper
 * responsible for upcasting data to the model.
 *
 * **Note**: The `styleAttr` parameter should be either `'color'` or `'background-color'`.
 */ function renderUpcastAttribute(styleAttr) {
    return (viewElement)=>normalizeColorCode(viewElement.getStyle(styleAttr));
}
/**
 * A {@link module:font/fontcolor~FontColor font color} and
 * {@link module:font/fontbackgroundcolor~FontBackgroundColor font background color} helper
 * responsible for downcasting a color attribute to a `<span>` element.
 *
 * **Note**: The `styleAttr` parameter should be either `'color'` or `'background-color'`.
 */ function renderDowncastElement(styleAttr) {
    return (modelAttributeValue, { writer })=>writer.createAttributeElement('span', {
            style: `${styleAttr}:${modelAttributeValue}`
        }, {
            priority: 7
        });
}
/**
 * A helper that adds {@link module:ui/colorselector/colorselectorview~ColorSelectorView} to the color dropdown with proper initial values.
 *
 * @param config.dropdownView The dropdown view to which a {@link module:ui/colorselector/colorselectorview~ColorSelectorView}
 * will be added.
 * @param config.colors An array with definitions representing colors to be displayed in the color selector.
 * @param config.removeButtonLabel The label for the button responsible for removing the color.
 * @param config.documentColorsLabel The label for the section with document colors.
 * @param config.documentColorsCount The number of document colors inside the dropdown.
 * @param config.colorPickerViewConfig Configuration of the color picker view.
 * @returns The new color selector view.
 */ function addColorSelectorToDropdown({ dropdownView, colors, columns, removeButtonLabel, colorPickerLabel, documentColorsLabel, documentColorsCount, colorPickerViewConfig }) {
    const locale = dropdownView.locale;
    const colorSelectorView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ColorSelectorView"](locale, {
        colors,
        columns,
        removeButtonLabel,
        colorPickerLabel,
        documentColorsLabel,
        documentColorsCount,
        colorPickerViewConfig
    });
    dropdownView.colorSelectorView = colorSelectorView;
    dropdownView.panelView.children.add(colorSelectorView);
    return colorSelectorView;
}
/**
 * Fixes the color value string.
 */ function normalizeColorCode(value) {
    return value.replace(/\s/g, '');
}
/**
 * The font family command. It is used by {@link module:font/fontfamily/fontfamilyediting~FontFamilyEditing}
 * to apply the font family.
 *
 * ```ts
 * editor.execute( 'fontFamily', { value: 'Arial' } );
 * ```
 *
 * **Note**: Executing the command without the value removes the attribute from the model.
 */ class FontFamilyCommand extends FontCommand {
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor, FONT_FAMILY);
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module font/fontfamily/utils
 */ /**
 * Normalizes the {@link module:font/fontconfig~FontFamilyConfig#options configuration options}
 * to the {@link module:font/fontconfig~FontFamilyOption} format.
 *
 * @param configuredOptions An array of options taken from the configuration.
 */ function normalizeOptions$1(configuredOptions) {
    // Convert options to objects.
    return configuredOptions.map(getOptionDefinition$1) // Filter out undefined values that `getOptionDefinition` might return.
    .filter((option)=>option !== undefined);
}
/**
 * Returns an option definition either created from string shortcut.
 * If object is passed then this method will return it without alternating it. Returns undefined for item than cannot be parsed.
 *
 */ function getOptionDefinition$1(option) {
    // Treat any object as full item definition provided by user in configuration.
    if (typeof option === 'object') {
        return option;
    }
    // Handle 'default' string as a special case. It will be used to remove the fontFamily attribute.
    if (option === 'default') {
        return {
            title: 'Default',
            model: undefined
        };
    }
    // Ignore values that we cannot parse to a definition.
    if (typeof option !== 'string') {
        return undefined;
    }
    // Return font family definition from font string.
    return generateFontPreset(option);
}
/**
 * Creates a predefined preset for pixel size. It deconstructs font-family like string into full configuration option.
 * A font definition is passed as coma delimited set of font family names. Font names might be quoted.
 *
 * @param fontDefinition A font definition form configuration.
 */ function generateFontPreset(fontDefinition) {
    // Remove quotes from font names. They will be normalized later.
    const fontNames = fontDefinition.replace(/"|'/g, '').split(',');
    // The first matched font name will be used as dropdown list item title and as model value.
    const firstFontName = fontNames[0];
    // CSS-compatible font names.
    const cssFontNames = fontNames.map(normalizeFontNameForCSS).join(', ');
    return {
        title: firstFontName,
        model: cssFontNames,
        view: {
            name: 'span',
            styles: {
                'font-family': cssFontNames
            },
            priority: 7
        }
    };
}
/**
 * Normalizes font name for the style attribute. It adds braces (') if font name contains spaces.
 */ function normalizeFontNameForCSS(fontName) {
    fontName = fontName.trim();
    // Compound font names should be quoted.
    if (fontName.indexOf(' ') > 0) {
        fontName = `'${fontName}'`;
    }
    return fontName;
}
/**
 * The font family editing feature.
 *
 * It introduces the {@link module:font/fontfamily/fontfamilycommand~FontFamilyCommand command} and
 * the `fontFamily` attribute in the {@link module:engine/model/model~Model model} which renders
 * in the {@link module:engine/view/view view} as an inline `<span>` element (`<span style="font-family: Arial">`),
 * depending on the {@link module:font/fontconfig~FontFamilyConfig configuration}.
 */ class FontFamilyEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FontFamilyEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        // Define default configuration using font families shortcuts.
        editor.config.define(FONT_FAMILY, {
            options: [
                'default',
                'Arial, Helvetica, sans-serif',
                'Courier New, Courier, monospace',
                'Georgia, serif',
                'Lucida Sans Unicode, Lucida Grande, sans-serif',
                'Tahoma, Geneva, sans-serif',
                'Times New Roman, Times, serif',
                'Trebuchet MS, Helvetica, sans-serif',
                'Verdana, Geneva, sans-serif'
            ],
            supportAllValues: false
        });
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        // Allow fontFamily attribute on text nodes.
        editor.model.schema.extend('$text', {
            allowAttributes: FONT_FAMILY
        });
        editor.model.schema.setAttributeProperties(FONT_FAMILY, {
            isFormatting: true,
            copyOnEnter: true
        });
        // Get configured font family options without "default" option.
        const options = normalizeOptions$1(editor.config.get('fontFamily.options')).filter((item)=>item.model);
        const definition = buildDefinition(FONT_FAMILY, options);
        // Set-up the two-way conversion.
        if (editor.config.get('fontFamily.supportAllValues')) {
            this._prepareAnyValueConverters();
            this._prepareCompatibilityConverter();
        } else {
            editor.conversion.attributeToElement(definition);
        }
        editor.commands.add(FONT_FAMILY, new FontFamilyCommand(editor));
    }
    /**
	 * These converters enable keeping any value found as `style="font-family: *"` as a value of an attribute on a text even
	 * if it is not defined in the plugin configuration.
	 */ _prepareAnyValueConverters() {
        const editor = this.editor;
        editor.conversion.for('downcast').attributeToElement({
            model: FONT_FAMILY,
            view: (attributeValue, { writer })=>{
                return writer.createAttributeElement('span', {
                    style: 'font-family:' + attributeValue
                }, {
                    priority: 7
                });
            }
        });
        editor.conversion.for('upcast').elementToAttribute({
            model: {
                key: FONT_FAMILY,
                value: (viewElement)=>viewElement.getStyle('font-family')
            },
            view: {
                name: 'span',
                styles: {
                    'font-family': /.*/
                }
            }
        });
    }
    /**
	 * Adds support for legacy `<font face="..">` formatting.
	 */ _prepareCompatibilityConverter() {
        const editor = this.editor;
        editor.conversion.for('upcast').elementToAttribute({
            view: {
                name: 'font',
                attributes: {
                    'face': /.*/
                }
            },
            model: {
                key: FONT_FAMILY,
                value: (viewElement)=>viewElement.getAttribute('face')
            }
        });
    }
}
var fontFamilyIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514L11.03 3zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244L12.3 6zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973L13.57 9zm-2.754 2.5L8.038 4.785 5.261 11.5h5.555zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663L11.436 13z\"/></svg>";
/**
 * The font family UI plugin. It introduces the `'fontFamily'` dropdown.
 */ class FontFamilyUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FontFamilyUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        const options = this._getLocalizedOptions();
        const command = editor.commands.get(FONT_FAMILY);
        const accessibleLabel = t('Font Family');
        const listOptions = _prepareListOptions$1(options, command);
        // Register UI component.
        editor.ui.componentFactory.add(FONT_FAMILY, (locale)=>{
            const dropdownView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDropdown"])(locale);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addListToDropdown"])(dropdownView, listOptions, {
                role: 'menu',
                ariaLabel: accessibleLabel
            });
            dropdownView.buttonView.set({
                label: accessibleLabel,
                icon: fontFamilyIcon,
                tooltip: true
            });
            dropdownView.extendTemplate({
                attributes: {
                    class: 'ck-font-family-dropdown'
                }
            });
            dropdownView.bind('isEnabled').to(command);
            // Execute command when an item from the dropdown is selected.
            this.listenTo(dropdownView, 'execute', (evt)=>{
                editor.execute(evt.source.commandName, {
                    value: evt.source.commandParam
                });
                editor.editing.view.focus();
            });
            return dropdownView;
        });
        editor.ui.componentFactory.add(`menuBar:${FONT_FAMILY}`, (locale)=>{
            const menuView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuView"](locale);
            menuView.buttonView.set({
                label: accessibleLabel,
                icon: fontFamilyIcon
            });
            menuView.bind('isEnabled').to(command);
            const listView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListView"](locale);
            for (const definition of listOptions){
                const listItemView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemView"](locale, menuView);
                const buttonView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"](locale);
                buttonView.set({
                    role: 'menuitemradio',
                    isToggleable: true
                });
                buttonView.bind(...Object.keys(definition.model)).to(definition.model);
                buttonView.delegate('execute').to(menuView);
                buttonView.on('execute', ()=>{
                    editor.execute(definition.model.commandName, {
                        value: definition.model.commandParam
                    });
                    editor.editing.view.focus();
                });
                listItemView.children.add(buttonView);
                listView.items.add(listItemView);
            }
            menuView.panelView.children.add(listView);
            return menuView;
        });
    }
    /**
	 * Returns options as defined in `config.fontFamily.options` but processed to account for
	 * editor localization, i.e. to display {@link module:font/fontconfig~FontFamilyOption}
	 * in the correct language.
	 *
	 * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
	 * when the user configuration is defined because the editor does not exist yet.
	 */ _getLocalizedOptions() {
        const editor = this.editor;
        const t = editor.t;
        const options = normalizeOptions$1(editor.config.get(FONT_FAMILY).options);
        return options.map((option)=>{
            // The only title to localize is "Default" others are font names.
            if (option.title === 'Default') {
                option.title = t('Default');
            }
            return option;
        });
    }
}
/**
 * Prepares FontFamily dropdown items.
 */ function _prepareListOptions$1(options, command) {
    const itemDefinitions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"]();
    // Create dropdown items.
    for (const option of options){
        const def = {
            type: 'button',
            model: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewModel"]({
                commandName: FONT_FAMILY,
                commandParam: option.model,
                label: option.title,
                role: 'menuitemradio',
                withText: true
            })
        };
        def.model.bind('isOn').to(command, 'value', (value)=>{
            // "Default" or check in strict font-family converters mode.
            if (value === option.model) {
                return true;
            }
            if (!value || !option.model) {
                return false;
            }
            return value.split(',')[0].replace(/'/g, '').toLowerCase() === option.model.toLowerCase();
        });
        // Try to set a dropdown list item style.
        if (option.view && typeof option.view !== 'string' && option.view.styles) {
            def.model.set('labelStyle', `font-family: ${option.view.styles['font-family']}`);
        }
        itemDefinitions.add(def);
    }
    return itemDefinitions;
}
/**
 * The font family plugin.
 *
 * For a detailed overview, check the {@glink features/font font feature} documentatiom
 * and the {@glink api/font package page}.
 *
 * This is a "glue" plugin which loads the {@link module:font/fontfamily/fontfamilyediting~FontFamilyEditing} and
 * {@link module:font/fontfamily/fontfamilyui~FontFamilyUI} features in the editor.
 */ class FontFamily extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            FontFamilyEditing,
            FontFamilyUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FontFamily';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
/**
 * The font size command. It is used by {@link module:font/fontsize/fontsizeediting~FontSizeEditing}
 * to apply the font size.
 *
 * ```ts
 * editor.execute( 'fontSize', { value: 'small' } );
 * ```
 *
 * **Note**: Executing the command without the value removes the attribute from the model.
 */ class FontSizeCommand extends FontCommand {
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor, FONT_SIZE);
    }
}
/**
 * Normalizes and translates the {@link module:font/fontconfig~FontSizeConfig#options configuration options}
 * to the {@link module:font/fontconfig~FontSizeOption} format.
 *
 * @param configuredOptions An array of options taken from the configuration.
 */ function normalizeOptions(configuredOptions) {
    // Convert options to objects.
    return configuredOptions.map((item)=>getOptionDefinition(item)) // Filter out undefined values that `getOptionDefinition` might return.
    .filter((option)=>option !== undefined);
}
// Default named presets map. Always create a new instance of the preset object in order to avoid modifying references.
const namedPresets = {
    get tiny () {
        return {
            title: 'Tiny',
            model: 'tiny',
            view: {
                name: 'span',
                classes: 'text-tiny',
                priority: 7
            }
        };
    },
    get small () {
        return {
            title: 'Small',
            model: 'small',
            view: {
                name: 'span',
                classes: 'text-small',
                priority: 7
            }
        };
    },
    get big () {
        return {
            title: 'Big',
            model: 'big',
            view: {
                name: 'span',
                classes: 'text-big',
                priority: 7
            }
        };
    },
    get huge () {
        return {
            title: 'Huge',
            model: 'huge',
            view: {
                name: 'span',
                classes: 'text-huge',
                priority: 7
            }
        };
    }
};
/**
 * Returns an option definition either from preset or creates one from number shortcut.
 * If object is passed then this method will return it without alternating it. Returns undefined for item than cannot be parsed.
 */ function getOptionDefinition(option) {
    if (typeof option === 'number') {
        option = String(option);
    }
    // Check whether passed option is a full item definition provided by user in configuration.
    if (typeof option === 'object' && isFullItemDefinition(option)) {
        return attachPriority(option);
    }
    const preset = findPreset(option);
    // Item is a named preset.
    if (preset) {
        return attachPriority(preset);
    }
    // 'Default' font size. It will be used to remove the fontSize attribute.
    if (option === 'default') {
        return {
            model: undefined,
            title: 'Default'
        };
    }
    // At this stage we probably have numerical value to generate a preset so parse it's value.
    // Discard any faulty values.
    if (isNumericalDefinition(option)) {
        return undefined;
    }
    // Return font size definition from size value.
    return generatePixelPreset(option);
}
/**
 * Creates a predefined preset for pixel size.
 * @param definition Font size in pixels.
 * @returns
 */ function generatePixelPreset(definition) {
    // Extend a short (numeric value) definition.
    if (typeof definition === 'string') {
        definition = {
            title: definition,
            model: `${parseFloat(definition)}px`
        };
    }
    definition.view = {
        name: 'span',
        styles: {
            'font-size': definition.model
        }
    };
    return attachPriority(definition);
}
/**
 * Adds the priority to the view element definition if missing. It's required due to ckeditor/ckeditor5#2291
 */ function attachPriority(definition) {
    if (definition.view && typeof definition.view !== 'string' && !definition.view.priority) {
        definition.view.priority = 7;
    }
    return definition;
}
/**
 * Returns a prepared preset definition. If passed an object, a name of preset should be defined as `model` value.
 *
 * @param definition.model A preset name.
 */ function findPreset(definition) {
    return typeof definition === 'string' ? namedPresets[definition] : namedPresets[definition.model];
}
/**
 * We treat `definition` as completed if it is an object that contains `title`, `model` and `view` values.
 */ function isFullItemDefinition(definition) {
    return definition.title && definition.model && definition.view;
}
function isNumericalDefinition(definition) {
    let numberValue;
    if (typeof definition === 'object') {
        if (!definition.model) {
            /**
			 * Provided value as an option for {@link module:font/fontsize~FontSize} seems to invalid.
			 *
			 * See valid examples described in the {@link module:font/fontconfig~FontSizeConfig#options plugin configuration}.
			 *
			 * @error font-size-invalid-definition
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('font-size-invalid-definition', null, definition);
        } else {
            numberValue = parseFloat(definition.model);
        }
    } else {
        numberValue = parseFloat(definition);
    }
    return isNaN(numberValue);
}
// Mapping of `<font size="..">` styling to CSS's `font-size` values.
const styleFontSize = [
    'x-small',
    'x-small',
    'small',
    'medium',
    'large',
    'x-large',
    'xx-large',
    'xxx-large'
];
/**
 * The font size editing feature.
 *
 * It introduces the {@link module:font/fontsize/fontsizecommand~FontSizeCommand command} and the `fontSize`
 * attribute in the {@link module:engine/model/model~Model model} which renders in the {@link module:engine/view/view view}
 * as a `<span>` element with either:
 * * a style attribute (`<span style="font-size:12px">...</span>`),
 * * or a class attribute (`<span class="text-small">...</span>`)
 *
 * depending on the {@link module:font/fontconfig~FontSizeConfig configuration}.
 */ class FontSizeEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FontSizeEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        // Define default configuration using named presets.
        editor.config.define(FONT_SIZE, {
            options: [
                'tiny',
                'small',
                'default',
                'big',
                'huge'
            ],
            supportAllValues: false
        });
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        // Allow fontSize attribute on text nodes.
        editor.model.schema.extend('$text', {
            allowAttributes: FONT_SIZE
        });
        editor.model.schema.setAttributeProperties(FONT_SIZE, {
            isFormatting: true,
            copyOnEnter: true
        });
        const supportAllValues = editor.config.get('fontSize.supportAllValues');
        // Define view to model conversion.
        const options = normalizeOptions(this.editor.config.get('fontSize.options')).filter((item)=>item.model);
        const definition = buildDefinition(FONT_SIZE, options);
        // Set-up the two-way conversion.
        if (supportAllValues) {
            this._prepareAnyValueConverters(definition);
            this._prepareCompatibilityConverter();
        } else {
            editor.conversion.attributeToElement(definition);
        }
        // Add FontSize command.
        editor.commands.add(FONT_SIZE, new FontSizeCommand(editor));
    }
    /**
	 * These converters enable keeping any value found as `style="font-size: *"` as a value of an attribute on a text even
	 * if it is not defined in the plugin configuration.
	 *
	 * @param definition Converter definition out of input data.
	 */ _prepareAnyValueConverters(definition) {
        const editor = this.editor;
        // If `fontSize.supportAllValues=true`, we do not allow to use named presets in the plugin's configuration.
        const presets = definition.model.values.filter((value)=>{
            return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLength"])(String(value)) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPercentage"])(String(value));
        });
        if (presets.length) {
            /**
			 * If {@link module:font/fontconfig~FontSizeConfig#supportAllValues `config.fontSize.supportAllValues`} is `true`,
			 * you need to use numerical values as font size options.
			 *
			 * See valid examples described in the {@link module:font/fontconfig~FontSizeConfig#options plugin configuration}.
			 *
			 * @error font-size-invalid-use-of-named-presets
			 * @param {Array.<String>} presets Invalid values.
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('font-size-invalid-use-of-named-presets', null, {
                presets
            });
        }
        editor.conversion.for('downcast').attributeToElement({
            model: FONT_SIZE,
            view: (attributeValue, { writer })=>{
                if (!attributeValue) {
                    return;
                }
                return writer.createAttributeElement('span', {
                    style: 'font-size:' + attributeValue
                }, {
                    priority: 7
                });
            }
        });
        editor.conversion.for('upcast').elementToAttribute({
            model: {
                key: FONT_SIZE,
                value: (viewElement)=>viewElement.getStyle('font-size')
            },
            view: {
                name: 'span',
                styles: {
                    'font-size': /.*/
                }
            }
        });
    }
    /**
	 * Adds support for legacy `<font size="..">` formatting.
	 */ _prepareCompatibilityConverter() {
        const editor = this.editor;
        editor.conversion.for('upcast').elementToAttribute({
            view: {
                name: 'font',
                attributes: {
                    // Documentation mentions sizes from 1 to 7. To handle old content we support all values
                    // up to 999 but clamp it to the valid range. Why 999? It should cover accidental values
                    // similar to percentage, e.g. 100%, 200% which could be the usual mistake for font size.
                    'size': /^[+-]?\d{1,3}$/
                }
            },
            model: {
                key: FONT_SIZE,
                value: (viewElement)=>{
                    const value = viewElement.getAttribute('size');
                    const isRelative = value[0] === '-' || value[0] === '+';
                    let size = parseInt(value, 10);
                    if (isRelative) {
                        // Add relative size (which can be negative) to the default size = 3.
                        size = 3 + size;
                    }
                    const maxSize = styleFontSize.length - 1;
                    const clampedSize = Math.min(Math.max(size, 0), maxSize);
                    return styleFontSize[clampedSize];
                }
            }
        });
    }
}
var fontSizeIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.816 11.5 7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z\"/></svg>";
/**
 * The font size UI plugin. It introduces the `'fontSize'` dropdown.
 */ class FontSizeUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FontSizeUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        const options = this._getLocalizedOptions();
        const command = editor.commands.get(FONT_SIZE);
        const accessibleLabel = t('Font Size');
        const listOptions = _prepareListOptions(options, command);
        // Register UI component.
        editor.ui.componentFactory.add(FONT_SIZE, (locale)=>{
            const dropdownView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDropdown"])(locale);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addListToDropdown"])(dropdownView, listOptions, {
                role: 'menu',
                ariaLabel: accessibleLabel
            });
            // Create dropdown model.
            dropdownView.buttonView.set({
                label: accessibleLabel,
                icon: fontSizeIcon,
                tooltip: true
            });
            dropdownView.extendTemplate({
                attributes: {
                    class: [
                        'ck-font-size-dropdown'
                    ]
                }
            });
            dropdownView.bind('isEnabled').to(command);
            // Execute command when an item from the dropdown is selected.
            this.listenTo(dropdownView, 'execute', (evt)=>{
                editor.execute(evt.source.commandName, {
                    value: evt.source.commandParam
                });
                editor.editing.view.focus();
            });
            return dropdownView;
        });
        editor.ui.componentFactory.add(`menuBar:${FONT_SIZE}`, (locale)=>{
            const menuView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuView"](locale);
            menuView.buttonView.set({
                label: accessibleLabel,
                icon: fontSizeIcon
            });
            menuView.bind('isEnabled').to(command);
            const listView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListView"](locale);
            for (const definition of listOptions){
                const listItemView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemView"](locale, menuView);
                const buttonView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"](locale);
                buttonView.set({
                    role: 'menuitemradio',
                    isToggleable: true
                });
                buttonView.bind(...Object.keys(definition.model)).to(definition.model);
                buttonView.delegate('execute').to(menuView);
                buttonView.on('execute', ()=>{
                    editor.execute(definition.model.commandName, {
                        value: definition.model.commandParam
                    });
                    editor.editing.view.focus();
                });
                listItemView.children.add(buttonView);
                listView.items.add(listItemView);
            }
            menuView.panelView.children.add(listView);
            return menuView;
        });
    }
    /**
	 * Returns options as defined in `config.fontSize.options` but processed to account for
	 * editor localization, i.e. to display {@link module:font/fontconfig~FontSizeOption}
	 * in the correct language.
	 *
	 * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
	 * when the user configuration is defined because the editor does not exist yet.
	 */ _getLocalizedOptions() {
        const editor = this.editor;
        const t = editor.t;
        const localizedTitles = {
            Default: t('Default'),
            Tiny: t('Tiny'),
            Small: t('Small'),
            Big: t('Big'),
            Huge: t('Huge')
        };
        const options = normalizeOptions(editor.config.get(FONT_SIZE).options);
        return options.map((option)=>{
            const title = localizedTitles[option.title];
            if (title && title != option.title) {
                // Clone the option to avoid altering the original `namedPresets` from `./utils.js`.
                option = Object.assign({}, option, {
                    title
                });
            }
            return option;
        });
    }
}
/**
 * Prepares FontSize dropdown items.
 */ function _prepareListOptions(options, command) {
    const itemDefinitions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"]();
    for (const option of options){
        const def = {
            type: 'button',
            model: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewModel"]({
                commandName: FONT_SIZE,
                commandParam: option.model,
                label: option.title,
                class: 'ck-fontsize-option',
                role: 'menuitemradio',
                withText: true
            })
        };
        if (option.view && typeof option.view !== 'string') {
            if (option.view.styles) {
                def.model.set('labelStyle', `font-size:${option.view.styles['font-size']}`);
            }
            if (option.view.classes) {
                def.model.set('class', `${def.model.class} ${option.view.classes}`);
            }
        }
        def.model.bind('isOn').to(command, 'value', (value)=>value === option.model);
        // Add the option to the collection.
        itemDefinitions.add(def);
    }
    return itemDefinitions;
}
/**
 * The font size plugin.
 *
 * For a detailed overview, check the {@glink features/font font feature} documentation
 * and the {@glink api/font package page}.
 *
 * This is a "glue" plugin which loads the {@link module:font/fontsize/fontsizeediting~FontSizeEditing} and
 * {@link module:font/fontsize/fontsizeui~FontSizeUI} features in the editor.
 */ class FontSize extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            FontSizeEditing,
            FontSizeUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FontSize';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * Normalizes and translates the {@link module:font/fontconfig~FontSizeConfig#options configuration options}
	 * to the {@link module:font/fontconfig~FontSizeOption} format.
	 *
	 * @param configuredOptions An array of options taken from the configuration.
	 */ normalizeSizeOptions(options) {
        return normalizeOptions(options);
    }
}
/**
 * The font color command. It is used by {@link module:font/fontcolor/fontcolorediting~FontColorEditing}
 * to apply the font color.
 *
 * ```ts
 * editor.execute( 'fontColor', { value: 'rgb(250, 20, 20)' } );
 * ```
 *
 * **Note**: Executing the command with the `null` value removes the attribute from the model.
 */ class FontColorCommand extends FontCommand {
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor, FONT_COLOR);
    }
}
/**
 * The font color editing feature.
 *
 * It introduces the {@link module:font/fontcolor/fontcolorcommand~FontColorCommand command} and
 * the `fontColor` attribute in the {@link module:engine/model/model~Model model} which renders
 * in the {@link module:engine/view/view view} as a `<span>` element (`<span style="color: ...">`),
 * depending on the {@link module:font/fontconfig~FontColorConfig configuration}.
 */ class FontColorEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FontColorEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define(FONT_COLOR, {
            colors: [
                {
                    color: 'hsl(0, 0%, 0%)',
                    label: 'Black'
                },
                {
                    color: 'hsl(0, 0%, 30%)',
                    label: 'Dim grey'
                },
                {
                    color: 'hsl(0, 0%, 60%)',
                    label: 'Grey'
                },
                {
                    color: 'hsl(0, 0%, 90%)',
                    label: 'Light grey'
                },
                {
                    color: 'hsl(0, 0%, 100%)',
                    label: 'White',
                    hasBorder: true
                },
                {
                    color: 'hsl(0, 75%, 60%)',
                    label: 'Red'
                },
                {
                    color: 'hsl(30, 75%, 60%)',
                    label: 'Orange'
                },
                {
                    color: 'hsl(60, 75%, 60%)',
                    label: 'Yellow'
                },
                {
                    color: 'hsl(90, 75%, 60%)',
                    label: 'Light green'
                },
                {
                    color: 'hsl(120, 75%, 60%)',
                    label: 'Green'
                },
                {
                    color: 'hsl(150, 75%, 60%)',
                    label: 'Aquamarine'
                },
                {
                    color: 'hsl(180, 75%, 60%)',
                    label: 'Turquoise'
                },
                {
                    color: 'hsl(210, 75%, 60%)',
                    label: 'Light blue'
                },
                {
                    color: 'hsl(240, 75%, 60%)',
                    label: 'Blue'
                },
                {
                    color: 'hsl(270, 75%, 60%)',
                    label: 'Purple'
                }
            ],
            columns: 5
        });
        editor.conversion.for('upcast').elementToAttribute({
            view: {
                name: 'span',
                styles: {
                    'color': /[\s\S]+/
                }
            },
            model: {
                key: FONT_COLOR,
                value: renderUpcastAttribute('color')
            }
        });
        // Support legacy `<font color="..">` formatting.
        editor.conversion.for('upcast').elementToAttribute({
            view: {
                name: 'font',
                attributes: {
                    'color': /^#?\w+$/
                }
            },
            model: {
                key: FONT_COLOR,
                value: (viewElement)=>viewElement.getAttribute('color')
            }
        });
        editor.conversion.for('downcast').attributeToElement({
            model: FONT_COLOR,
            view: renderDowncastElement('color')
        });
        editor.commands.add(FONT_COLOR, new FontColorCommand(editor));
        // Allow the font color attribute on text nodes.
        editor.model.schema.extend('$text', {
            allowAttributes: FONT_COLOR
        });
        editor.model.schema.setAttributeProperties(FONT_COLOR, {
            isFormatting: true,
            copyOnEnter: true
        });
    }
}
/**
 * The color UI plugin which isolates the common logic responsible for displaying dropdowns with color grids.
 *
 * It is used to create the `'fontBackgroundColor'` and `'fontColor'` dropdowns, each hosting
 * a {@link module:ui/colorselector/colorselectorview~ColorSelectorView}.
 */ class ColorUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * The name of the command which will be executed when a color tile is clicked.
	 */ commandName;
    /**
	 * The name of this component in the {@link module:ui/componentfactory~ComponentFactory}.
	 * Also the configuration scope name in `editor.config`.
	 */ componentName;
    /**
	 * The SVG icon used by the dropdown.
	 */ icon;
    /**
	 * The label used by the dropdown.
	 */ dropdownLabel;
    /**
	 * The number of columns in the color grid.
	 */ columns;
    /**
	 * Creates a plugin which introduces a dropdown with a pre–configured
	 * {@link module:ui/colorselector/colorselectorview~ColorSelectorView}.
	 *
	 * @param config The configuration object.
	 * @param config.commandName The name of the command which will be executed when a color tile is clicked.
	 * @param config.componentName The name of the dropdown in the {@link module:ui/componentfactory~ComponentFactory}
	 * and the configuration scope name in `editor.config`.
	 * @param config.icon The SVG icon used by the dropdown.
	 * @param config.dropdownLabel The label used by the dropdown.
	 */ constructor(editor, { commandName, componentName, icon, dropdownLabel }){
        super(editor);
        this.commandName = commandName;
        this.componentName = componentName;
        this.icon = icon;
        this.dropdownLabel = dropdownLabel;
        this.columns = editor.config.get(`${this.componentName}.columns`);
    }
    /**
	* @inheritDoc
	*/ init() {
        const editor = this.editor;
        const locale = editor.locale;
        const t = locale.t;
        const command = editor.commands.get(this.commandName);
        const componentConfig = editor.config.get(this.componentName);
        const colorsConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeColorOptions"])(componentConfig.colors);
        const localizedColors = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLocalizedColorOptions"])(locale, colorsConfig);
        const documentColorsCount = componentConfig.documentColors;
        const hasColorPicker = componentConfig.colorPicker !== false;
        // Register the UI component.
        editor.ui.componentFactory.add(this.componentName, (locale)=>{
            const dropdownView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDropdown"])(locale);
            // Font color dropdown rendering is deferred once it gets open to improve performance (#6192).
            let dropdownContentRendered = false;
            const colorSelectorView = addColorSelectorToDropdown({
                dropdownView,
                colors: localizedColors.map((option)=>({
                        label: option.label,
                        color: option.model,
                        options: {
                            hasBorder: option.hasBorder
                        }
                    })),
                columns: this.columns,
                removeButtonLabel: t('Remove color'),
                colorPickerLabel: t('Color picker'),
                documentColorsLabel: documentColorsCount !== 0 ? t('Document colors') : '',
                documentColorsCount: documentColorsCount === undefined ? this.columns : documentColorsCount,
                colorPickerViewConfig: hasColorPicker ? componentConfig.colorPicker || {} : false
            });
            colorSelectorView.bind('selectedColor').to(command, 'value');
            dropdownView.buttonView.set({
                label: this.dropdownLabel,
                icon: this.icon,
                tooltip: true
            });
            dropdownView.extendTemplate({
                attributes: {
                    class: 'ck-color-ui-dropdown'
                }
            });
            dropdownView.bind('isEnabled').to(command);
            colorSelectorView.on('execute', (evt, data)=>{
                if (dropdownView.isOpen) {
                    editor.execute(this.commandName, {
                        value: data.value,
                        batch: this._undoStepBatch
                    });
                }
                if (data.source !== 'colorPicker') {
                    editor.editing.view.focus();
                }
                if (data.source === 'colorPickerSaveButton') {
                    dropdownView.isOpen = false;
                }
            });
            colorSelectorView.on('colorPicker:show', ()=>{
                this._undoStepBatch = editor.model.createBatch();
            });
            colorSelectorView.on('colorPicker:cancel', ()=>{
                if (this._undoStepBatch.operations.length) {
                    // We need to close the dropdown before the undo batch.
                    // Otherwise, ColorUI treats undo as a selected color change,
                    // propagating the update to the whole selection.
                    // That's an issue if spans with various colors were selected.
                    dropdownView.isOpen = false;
                    editor.execute('undo', this._undoStepBatch);
                }
                editor.editing.view.focus();
            });
            dropdownView.on('change:isOpen', (evt, name, isVisible)=>{
                if (!dropdownContentRendered) {
                    dropdownContentRendered = true;
                    dropdownView.colorSelectorView.appendUI();
                }
                if (isVisible) {
                    if (documentColorsCount !== 0) {
                        colorSelectorView.updateDocumentColors(editor.model, this.componentName);
                    }
                    colorSelectorView.updateSelectedColors();
                    colorSelectorView.showColorGridsFragment();
                }
            });
            // Accessibility: focus the first active color when opening the dropdown.
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["focusChildOnDropdownOpen"])(dropdownView, ()=>dropdownView.colorSelectorView.colorGridsFragmentView.staticColorsGrid.items.find((item)=>item.isOn));
            return dropdownView;
        });
        // Register menu bar button..
        editor.ui.componentFactory.add(`menuBar:${this.componentName}`, (locale)=>{
            const menuView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuView"](locale);
            menuView.buttonView.set({
                label: this.dropdownLabel,
                icon: this.icon
            });
            menuView.bind('isEnabled').to(command);
            // Font color sub-menu rendering is deferred once it gets open to improve performance (#6192).
            let contentRendered = false;
            const colorSelectorView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ColorSelectorView"](locale, {
                colors: localizedColors.map((option)=>({
                        label: option.label,
                        color: option.model,
                        options: {
                            hasBorder: option.hasBorder
                        }
                    })),
                columns: this.columns,
                removeButtonLabel: t('Remove color'),
                colorPickerLabel: t('Color picker'),
                documentColorsLabel: documentColorsCount !== 0 ? t('Document colors') : '',
                documentColorsCount: documentColorsCount === undefined ? this.columns : documentColorsCount,
                colorPickerViewConfig: false
            });
            colorSelectorView.bind('selectedColor').to(command, 'value');
            colorSelectorView.delegate('execute').to(menuView);
            colorSelectorView.on('execute', (evt, data)=>{
                editor.execute(this.commandName, {
                    value: data.value,
                    batch: this._undoStepBatch
                });
                editor.editing.view.focus();
            });
            menuView.on('change:isOpen', (evt, name, isVisible)=>{
                if (!contentRendered) {
                    contentRendered = true;
                    colorSelectorView.appendUI();
                }
                if (isVisible) {
                    if (documentColorsCount !== 0) {
                        colorSelectorView.updateDocumentColors(editor.model, this.componentName);
                    }
                    colorSelectorView.updateSelectedColors();
                    colorSelectorView.showColorGridsFragment();
                }
            });
            menuView.panelView.children.add(colorSelectorView);
            return menuView;
        });
    }
}
var fontColorIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z\"/></svg>";
/**
 * The font color UI plugin. It introduces the `'fontColor'` dropdown.
 */ class FontColorUI extends ColorUI {
    /**
	 * @inheritDoc
	 */ constructor(editor){
        const t = editor.locale.t;
        super(editor, {
            commandName: FONT_COLOR,
            componentName: FONT_COLOR,
            icon: fontColorIcon,
            dropdownLabel: t('Font Color')
        });
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FontColorUI';
    }
}
/**
 * The font color plugin.
 *
 * For a detailed overview, check the {@glink features/font font feature} documentation
 * and the {@glink api/font package page}.
 *
 * This is a "glue" plugin which loads the {@link module:font/fontcolor/fontcolorediting~FontColorEditing} and
 * {@link module:font/fontcolor/fontcolorui~FontColorUI} features in the editor.
 */ class FontColor extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            FontColorEditing,
            FontColorUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FontColor';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
/**
 * The font background color command. It is used by
 * {@link module:font/fontbackgroundcolor/fontbackgroundcolorediting~FontBackgroundColorEditing}
 * to apply the font background color.
 *
 * ```ts
 * editor.execute( 'fontBackgroundColor', { value: 'rgb(250, 20, 20)' } );
 * ```
 *
 * **Note**: Executing the command with the `null` value removes the attribute from the model.
 */ class FontBackgroundColorCommand extends FontCommand {
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor, FONT_BACKGROUND_COLOR);
    }
}
/**
 * The font background color editing feature.
 *
 * It introduces the {@link module:font/fontbackgroundcolor/fontbackgroundcolorcommand~FontBackgroundColorCommand command} and
 * the `fontBackgroundColor` attribute in the {@link module:engine/model/model~Model model} which renders
 * in the {@link module:engine/view/view view} as a `<span>` element (`<span style="background-color: ...">`),
 * depending on the {@link module:font/fontconfig~FontColorConfig configuration}.
 */ class FontBackgroundColorEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FontBackgroundColorEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define(FONT_BACKGROUND_COLOR, {
            colors: [
                {
                    color: 'hsl(0, 0%, 0%)',
                    label: 'Black'
                },
                {
                    color: 'hsl(0, 0%, 30%)',
                    label: 'Dim grey'
                },
                {
                    color: 'hsl(0, 0%, 60%)',
                    label: 'Grey'
                },
                {
                    color: 'hsl(0, 0%, 90%)',
                    label: 'Light grey'
                },
                {
                    color: 'hsl(0, 0%, 100%)',
                    label: 'White',
                    hasBorder: true
                },
                {
                    color: 'hsl(0, 75%, 60%)',
                    label: 'Red'
                },
                {
                    color: 'hsl(30, 75%, 60%)',
                    label: 'Orange'
                },
                {
                    color: 'hsl(60, 75%, 60%)',
                    label: 'Yellow'
                },
                {
                    color: 'hsl(90, 75%, 60%)',
                    label: 'Light green'
                },
                {
                    color: 'hsl(120, 75%, 60%)',
                    label: 'Green'
                },
                {
                    color: 'hsl(150, 75%, 60%)',
                    label: 'Aquamarine'
                },
                {
                    color: 'hsl(180, 75%, 60%)',
                    label: 'Turquoise'
                },
                {
                    color: 'hsl(210, 75%, 60%)',
                    label: 'Light blue'
                },
                {
                    color: 'hsl(240, 75%, 60%)',
                    label: 'Blue'
                },
                {
                    color: 'hsl(270, 75%, 60%)',
                    label: 'Purple'
                }
            ],
            columns: 5
        });
        editor.data.addStyleProcessorRules(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addBackgroundRules"]);
        editor.conversion.for('upcast').elementToAttribute({
            view: {
                name: 'span',
                styles: {
                    'background-color': /[\s\S]+/
                }
            },
            model: {
                key: FONT_BACKGROUND_COLOR,
                value: renderUpcastAttribute('background-color')
            }
        });
        editor.conversion.for('downcast').attributeToElement({
            model: FONT_BACKGROUND_COLOR,
            view: renderDowncastElement('background-color')
        });
        editor.commands.add(FONT_BACKGROUND_COLOR, new FontBackgroundColorCommand(editor));
        // Allow the font backgroundColor attribute on text nodes.
        editor.model.schema.extend('$text', {
            allowAttributes: FONT_BACKGROUND_COLOR
        });
        editor.model.schema.setAttributeProperties(FONT_BACKGROUND_COLOR, {
            isFormatting: true,
            copyOnEnter: true
        });
    }
}
var fontBackgroundColorIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z\"/></svg>";
/**
 * The font background color UI plugin. It introduces the `'fontBackgroundColor'` dropdown.
 */ class FontBackgroundColorUI extends ColorUI {
    /**
	 * @inheritDoc
	 */ constructor(editor){
        const t = editor.locale.t;
        super(editor, {
            commandName: FONT_BACKGROUND_COLOR,
            componentName: FONT_BACKGROUND_COLOR,
            icon: fontBackgroundColorIcon,
            dropdownLabel: t('Font Background Color')
        });
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FontBackgroundColorUI';
    }
}
/**
 * The font background color plugin.
 *
 * For a detailed overview, check the {@glink features/font font feature} documentation
 * and the {@glink api/font package page}.
 *
 * This is a "glue" plugin which loads
 * the {@link module:font/fontbackgroundcolor/fontbackgroundcolorediting~FontBackgroundColorEditing} and
 * {@link module:font/fontbackgroundcolor/fontbackgroundcolorui~FontBackgroundColorUI} features in the editor.
 */ class FontBackgroundColor extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            FontBackgroundColorEditing,
            FontBackgroundColorUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'FontBackgroundColor';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
/**
 * A plugin that enables a set of text styling features:
 *
 * * {@link module:font/fontsize~FontSize},
 * * {@link module:font/fontfamily~FontFamily}.
 * * {@link module:font/fontcolor~FontColor},
 * * {@link module:font/fontbackgroundcolor~FontBackgroundColor}.
 *
 * For a detailed overview, check the {@glink features/font Font feature} documentation
 * and the {@glink api/font package page}.
 */ class Font extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            FontFamily,
            FontSize,
            FontColor,
            FontBackgroundColor
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Font';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-paragraph/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Paragraph": (()=>Paragraph),
    "ParagraphButtonUI": (()=>ParagraphButtonUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
;
;
;
/**
 * The paragraph command.
 */ class ParagraphCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    constructor(editor){
        super(editor);
        // Since this command may pass selection in execution block, it should be checked directly.
        this._isEnabledBasedOnSelection = false;
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const document = model.document;
        const block = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(document.selection.getSelectedBlocks());
        this.value = !!block && block.is('element', 'paragraph');
        this.isEnabled = !!block && checkCanBecomeParagraph(block, model.schema);
    }
    /**
	 * Executes the command. All the blocks (see {@link module:engine/model/schema~Schema}) in the selection
	 * will be turned to paragraphs.
	 *
	 * @fires execute
	 * @param options Options for the executed command.
	 * @param options.selection The selection that the command should be applied to. By default,
	 * if not provided, the command is applied to the {@link module:engine/model/document~Document#selection}.
	 */ execute(options = {}) {
        const model = this.editor.model;
        const document = model.document;
        const selection = options.selection || document.selection;
        // Don't execute command if selection is in non-editable place.
        if (!model.canEditAt(selection)) {
            return;
        }
        model.change((writer)=>{
            const blocks = selection.getSelectedBlocks();
            for (const block of blocks){
                if (!block.is('element', 'paragraph') && checkCanBecomeParagraph(block, model.schema)) {
                    writer.rename(block, 'paragraph');
                }
            }
        });
    }
}
/**
 * Checks whether the given block can be replaced by a paragraph.
 *
 * @param block A block to be tested.
 * @param schema The schema of the document.
 */ function checkCanBecomeParagraph(block, schema) {
    return schema.checkChild(block.parent, 'paragraph') && !schema.isObject(block);
}
/**
 * The insert paragraph command. It inserts a new paragraph at a specific
 * {@link module:engine/model/position~Position document position}.
 *
 * ```ts
 * // Insert a new paragraph before an element in the document.
 * editor.execute( 'insertParagraph', {
 *   position: editor.model.createPositionBefore( element )
 * } );
 * ```
 *
 * If a paragraph is disallowed in the context of the specific position, the command
 * will attempt to split position ancestors to find a place where it is possible
 * to insert a paragraph.
 *
 * **Note**: This command moves the selection to the inserted paragraph.
 */ class InsertParagraphCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    constructor(editor){
        super(editor);
        // Since this command passes position in execution block instead of selection, it should be checked directly.
        this._isEnabledBasedOnSelection = false;
    }
    /**
	 * Executes the command.
	 *
	 * @param options Options for the executed command.
	 * @param options.position The model position at which the new paragraph will be inserted.
	 * @param options.attributes Attributes keys and values to set on a inserted paragraph.
	 * @fires execute
	 */ execute(options) {
        const model = this.editor.model;
        const attributes = options.attributes;
        let position = options.position;
        // Don't execute command if position is in non-editable place.
        if (!model.canEditAt(position)) {
            return null;
        }
        return model.change((writer)=>{
            position = this._findPositionToInsertParagraph(position, writer);
            if (!position) {
                return null;
            }
            const paragraph = writer.createElement('paragraph');
            if (attributes) {
                model.schema.setAllowedAttributes(paragraph, attributes, writer);
            }
            model.insertContent(paragraph, position);
            writer.setSelection(paragraph, 'in');
            return writer.createPositionAt(paragraph, 0);
        });
    }
    /**
	 * Returns the best position to insert a new paragraph.
	 */ _findPositionToInsertParagraph(position, writer) {
        const model = this.editor.model;
        if (model.schema.checkChild(position, 'paragraph')) {
            return position;
        }
        const allowedParent = model.schema.findAllowedParent(position, 'paragraph');
        // It could be there's no ancestor limit that would allow paragraph.
        // In theory, "paragraph" could be disallowed even in the "$root".
        if (!allowedParent) {
            return null;
        }
        const positionParent = position.parent;
        const isTextAllowed = model.schema.checkChild(positionParent, '$text');
        // At empty $block or at the end of $block.
        // <paragraph>[]</paragraph> ---> <paragraph></paragraph><paragraph>[]</paragraph>
        // <paragraph>foo[]</paragraph> ---> <paragraph>foo</paragraph><paragraph>[]</paragraph>
        if (positionParent.isEmpty || isTextAllowed && position.isAtEnd) {
            return model.createPositionAfter(positionParent);
        }
        // At the start of $block with text.
        // <paragraph>[]foo</paragraph> ---> <paragraph>[]</paragraph><paragraph>foo</paragraph>
        if (!positionParent.isEmpty && isTextAllowed && position.isAtStart) {
            return model.createPositionBefore(positionParent);
        }
        return writer.split(position, allowedParent).position;
    }
}
/**
 * The paragraph feature for the editor.
 *
 * It introduces the `<paragraph>` element in the model which renders as a `<p>` element in the DOM and data.
 *
 * It also brings two editors commands:
 *
 * * The {@link module:paragraph/paragraphcommand~ParagraphCommand `'paragraph'`} command that converts all
 * blocks in the model selection into paragraphs.
 * * The {@link module:paragraph/insertparagraphcommand~InsertParagraphCommand `'insertParagraph'`} command
 * that inserts a new paragraph at a specified location in the model.
 */ class Paragraph extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Paragraph';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const model = editor.model;
        editor.commands.add('paragraph', new ParagraphCommand(editor));
        editor.commands.add('insertParagraph', new InsertParagraphCommand(editor));
        // Schema.
        model.schema.register('paragraph', {
            inheritAllFrom: '$block'
        });
        editor.conversion.elementToElement({
            model: 'paragraph',
            view: 'p'
        });
        // Conversion for paragraph-like elements which has not been converted by any plugin.
        editor.conversion.for('upcast').elementToElement({
            model: (viewElement, { writer })=>{
                if (!Paragraph.paragraphLikeElements.has(viewElement.name)) {
                    return null;
                }
                // Do not auto-paragraph empty elements.
                if (viewElement.isEmpty) {
                    return null;
                }
                return writer.createElement('paragraph');
            },
            view: /.+/,
            converterPriority: 'low'
        });
    }
    /**
	 * A list of element names which should be treated by the autoparagraphing algorithms as
	 * paragraph-like. This means that e.g. the following content:
	 *
	 * ```html
	 * <h1>Foo</h1>
	 * <table>
	 *   <tr>
	 *     <td>X</td>
	 *     <td>
	 *       <ul>
	 *         <li>Y</li>
	 *         <li>Z</li>
	 *       </ul>
	 *     </td>
	 *   </tr>
	 * </table>
	 * ```
	 *
	 * contains five paragraph-like elements: `<h1>`, two `<td>`s and two `<li>`s.
	 * Hence, if none of the features is going to convert those elements the above content will be automatically handled
	 * by the paragraph feature and converted to:
	 *
	 * ```html
	 * <p>Foo</p>
	 * <p>X</p>
	 * <p>Y</p>
	 * <p>Z</p>
	 * ```
	 *
	 * Note: The `<td>` containing two `<li>` elements was ignored as the innermost paragraph-like elements
	 * have a priority upon conversion.
	 */ static paragraphLikeElements = new Set([
        'blockquote',
        'dd',
        'div',
        'dt',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'li',
        'p',
        'td',
        'th'
    ]);
}
/**
 * This plugin defines the `'paragraph'` button. It can be used together with
 * {@link module:heading/headingbuttonsui~HeadingButtonsUI} to replace the standard heading dropdown.
 *
 * This plugin is not loaded automatically by the {@link module:paragraph/paragraph~Paragraph} plugin. It must
 * be added manually.
 *
 * ```ts
 * ClassicEditor
 *   .create( {
 *     plugins: [ ..., Heading, Paragraph, HeadingButtonsUI, ParagraphButtonUI ]
 *     toolbar: [ 'paragraph', 'heading1', 'heading2', 'heading3' ]
 *   } )
 *   .then( ... )
 *   .catch( ... );
 * ```
 */ class ParagraphButtonUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            Paragraph
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        editor.ui.componentFactory.add('paragraph', (locale)=>{
            const view = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](locale);
            const command = editor.commands.get('paragraph');
            view.label = t('Paragraph');
            view.icon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].paragraph;
            view.tooltip = true;
            view.isToggleable = true;
            view.bind('isEnabled').to(command);
            view.bind('isOn').to(command, 'value');
            view.on('execute', ()=>{
                editor.execute('paragraph');
            });
            return view;
        });
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-heading/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Heading": (()=>Heading),
    "HeadingButtonsUI": (()=>HeadingButtonsUI),
    "HeadingEditing": (()=>HeadingEditing),
    "HeadingUI": (()=>HeadingUI),
    "Title": (()=>Title)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$paragraph$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-paragraph/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * The heading command. It is used by the {@link module:heading/heading~Heading heading feature} to apply headings.
 */ class HeadingCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * Set of defined model's elements names that this command support.
	 * See {@link module:heading/headingconfig~HeadingOption}.
	 */ modelElements;
    /**
	 * Creates an instance of the command.
	 *
	 * @param editor Editor instance.
	 * @param modelElements Names of the element which this command can apply in the model.
	 */ constructor(editor, modelElements){
        super(editor);
        this.modelElements = modelElements;
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        const block = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(this.editor.model.document.selection.getSelectedBlocks());
        this.value = !!block && this.modelElements.includes(block.name) && block.name;
        this.isEnabled = !!block && this.modelElements.some((heading)=>checkCanBecomeHeading(block, heading, this.editor.model.schema));
    }
    /**
	 * Executes the command. Applies the heading to the selected blocks or, if the first selected
	 * block is a heading already, turns selected headings (of this level only) to paragraphs.
	 *
	 * @param options.value Name of the element which this command will apply in the model.
	 * @fires execute
	 */ execute(options) {
        const model = this.editor.model;
        const document = model.document;
        const modelElement = options.value;
        model.change((writer)=>{
            const blocks = Array.from(document.selection.getSelectedBlocks()).filter((block)=>{
                return checkCanBecomeHeading(block, modelElement, model.schema);
            });
            for (const block of blocks){
                if (!block.is('element', modelElement)) {
                    writer.rename(block, modelElement);
                }
            }
        });
    }
}
/**
 * Checks whether the given block can be replaced by a specific heading.
 *
 * @param block A block to be tested.
 * @param heading Command element name in the model.
 * @param schema The schema of the document.
 */ function checkCanBecomeHeading(block, heading, schema) {
    return schema.checkChild(block.parent, heading) && !schema.isObject(block);
}
const defaultModelElement = 'paragraph';
/**
 * The headings engine feature. It handles switching between block formats &ndash; headings and paragraph.
 * This class represents the engine part of the heading feature. See also {@link module:heading/heading~Heading}.
 * It introduces `heading1`-`headingN` commands which allow to convert paragraphs into headings.
 */ class HeadingEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'HeadingEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('heading', {
            options: [
                {
                    model: 'paragraph',
                    title: 'Paragraph',
                    class: 'ck-heading_paragraph'
                },
                {
                    model: 'heading1',
                    view: 'h2',
                    title: 'Heading 1',
                    class: 'ck-heading_heading1'
                },
                {
                    model: 'heading2',
                    view: 'h3',
                    title: 'Heading 2',
                    class: 'ck-heading_heading2'
                },
                {
                    model: 'heading3',
                    view: 'h4',
                    title: 'Heading 3',
                    class: 'ck-heading_heading3'
                }
            ]
        });
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$paragraph$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Paragraph"]
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const options = editor.config.get('heading.options');
        const modelElements = [];
        for (const option of options){
            // Skip paragraph - it is defined in required Paragraph feature.
            if (option.model === 'paragraph') {
                continue;
            }
            // Schema.
            editor.model.schema.register(option.model, {
                inheritAllFrom: '$block'
            });
            editor.conversion.elementToElement(option);
            modelElements.push(option.model);
        }
        this._addDefaultH1Conversion(editor);
        // Register the heading command for this option.
        editor.commands.add('heading', new HeadingCommand(editor, modelElements));
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        // If the enter command is added to the editor, alter its behavior.
        // Enter at the end of a heading element should create a paragraph.
        const editor = this.editor;
        const enterCommand = editor.commands.get('enter');
        const options = editor.config.get('heading.options');
        if (enterCommand) {
            this.listenTo(enterCommand, 'afterExecute', (evt, data)=>{
                const positionParent = editor.model.document.selection.getFirstPosition().parent;
                const isHeading = options.some((option)=>positionParent.is('element', option.model));
                if (isHeading && !positionParent.is('element', defaultModelElement) && positionParent.childCount === 0) {
                    data.writer.rename(positionParent, defaultModelElement);
                }
            });
        }
    }
    /**
	 * Adds default conversion for `h1` -> `heading1` with a low priority.
	 *
	 * @param editor Editor instance on which to add the `h1` conversion.
	 */ _addDefaultH1Conversion(editor) {
        editor.conversion.for('upcast').elementToElement({
            model: 'heading1',
            view: 'h1',
            // With a `low` priority, `paragraph` plugin autoparagraphing mechanism is executed. Make sure
            // this listener is called before it. If not, `h1` will be transformed into a paragraph.
            converterPriority: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["priorities"].low + 1
        });
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module heading/utils
 */ /**
 * Returns heading options as defined in `config.heading.options` but processed to consider
 * the editor localization, i.e. to display {@link module:heading/headingconfig~HeadingOption}
 * in the correct language.
 *
 * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
 * when the user configuration is defined because the editor does not exist yet.
 */ function getLocalizedOptions(editor) {
    const t = editor.t;
    const localizedTitles = {
        'Paragraph': t('Paragraph'),
        'Heading 1': t('Heading 1'),
        'Heading 2': t('Heading 2'),
        'Heading 3': t('Heading 3'),
        'Heading 4': t('Heading 4'),
        'Heading 5': t('Heading 5'),
        'Heading 6': t('Heading 6')
    };
    return editor.config.get('heading.options').map((option)=>{
        const title = localizedTitles[option.title];
        if (title && title != option.title) {
            option.title = title;
        }
        return option;
    });
}
/**
 * The headings UI feature. It introduces the `headings` dropdown.
 */ class HeadingUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'HeadingUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        const options = getLocalizedOptions(editor);
        const defaultTitle = t('Choose heading');
        const accessibleLabel = t('Heading');
        // Register UI component.
        editor.ui.componentFactory.add('heading', (locale)=>{
            const titles = {};
            const itemDefinitions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"]();
            const headingCommand = editor.commands.get('heading');
            const paragraphCommand = editor.commands.get('paragraph');
            const commands = [
                headingCommand
            ];
            for (const option of options){
                const def = {
                    type: 'button',
                    model: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewModel"]({
                        label: option.title,
                        class: option.class,
                        role: 'menuitemradio',
                        withText: true
                    })
                };
                if (option.model === 'paragraph') {
                    def.model.bind('isOn').to(paragraphCommand, 'value');
                    def.model.set('commandName', 'paragraph');
                    commands.push(paragraphCommand);
                } else {
                    def.model.bind('isOn').to(headingCommand, 'value', (value)=>value === option.model);
                    def.model.set({
                        commandName: 'heading',
                        commandValue: option.model
                    });
                }
                // Add the option to the collection.
                itemDefinitions.add(def);
                titles[option.model] = option.title;
            }
            const dropdownView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDropdown"])(locale);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addListToDropdown"])(dropdownView, itemDefinitions, {
                ariaLabel: accessibleLabel,
                role: 'menu'
            });
            dropdownView.buttonView.set({
                ariaLabel: accessibleLabel,
                ariaLabelledBy: undefined,
                isOn: false,
                withText: true,
                tooltip: accessibleLabel
            });
            dropdownView.extendTemplate({
                attributes: {
                    class: [
                        'ck-heading-dropdown'
                    ]
                }
            });
            dropdownView.bind('isEnabled').toMany(commands, 'isEnabled', (...areEnabled)=>{
                return areEnabled.some((isEnabled)=>isEnabled);
            });
            dropdownView.buttonView.bind('label').to(headingCommand, 'value', paragraphCommand, 'value', (heading, paragraph)=>{
                const whichModel = paragraph ? 'paragraph' : heading;
                if (typeof whichModel === 'boolean') {
                    return defaultTitle;
                }
                // If none of the commands is active, display default title.
                if (!titles[whichModel]) {
                    return defaultTitle;
                }
                return titles[whichModel];
            });
            dropdownView.buttonView.bind('ariaLabel').to(headingCommand, 'value', paragraphCommand, 'value', (heading, paragraph)=>{
                const whichModel = paragraph ? 'paragraph' : heading;
                if (typeof whichModel === 'boolean') {
                    return accessibleLabel;
                }
                // If none of the commands is active, display default title.
                if (!titles[whichModel]) {
                    return accessibleLabel;
                }
                return `${titles[whichModel]}, ${accessibleLabel}`;
            });
            // Execute command when an item from the dropdown is selected.
            this.listenTo(dropdownView, 'execute', (evt)=>{
                const { commandName, commandValue } = evt.source;
                editor.execute(commandName, commandValue ? {
                    value: commandValue
                } : undefined);
                editor.editing.view.focus();
            });
            return dropdownView;
        });
        editor.ui.componentFactory.add('menuBar:heading', (locale)=>{
            const menuView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuView"](locale);
            const headingCommand = editor.commands.get('heading');
            const paragraphCommand = editor.commands.get('paragraph');
            const commands = [
                headingCommand
            ];
            const listView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListView"](locale);
            menuView.set({
                class: 'ck-heading-dropdown'
            });
            listView.set({
                ariaLabel: t('Heading'),
                role: 'menu'
            });
            menuView.buttonView.set({
                label: t('Heading')
            });
            menuView.panelView.children.add(listView);
            for (const option of options){
                const listItemView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemView"](locale, menuView);
                const buttonView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"](locale);
                listItemView.children.add(buttonView);
                listView.items.add(listItemView);
                buttonView.set({
                    isToggleable: true,
                    label: option.title,
                    role: 'menuitemradio',
                    class: option.class
                });
                buttonView.delegate('execute').to(menuView);
                buttonView.on('execute', ()=>{
                    const commandName = option.model === 'paragraph' ? 'paragraph' : 'heading';
                    editor.execute(commandName, {
                        value: option.model
                    });
                    editor.editing.view.focus();
                });
                if (option.model === 'paragraph') {
                    buttonView.bind('isOn').to(paragraphCommand, 'value');
                    commands.push(paragraphCommand);
                } else {
                    buttonView.bind('isOn').to(headingCommand, 'value', (value)=>value === option.model);
                }
            }
            menuView.bind('isEnabled').toMany(commands, 'isEnabled', (...areEnabled)=>{
                return areEnabled.some((isEnabled)=>isEnabled);
            });
            return menuView;
        });
    }
}
/**
 * The headings feature.
 *
 * For a detailed overview, check the {@glink features/headings Headings feature} guide
 * and the {@glink api/heading package page}.
 *
 * This is a "glue" plugin which loads the {@link module:heading/headingediting~HeadingEditing heading editing feature}
 * and {@link module:heading/headingui~HeadingUI heading UI feature}.
 *
 * @extends module:core/plugin~Plugin
 */ class Heading extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            HeadingEditing,
            HeadingUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Heading';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
const defaultIcons = /* #__PURE__ */ (()=>({
        heading1: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].heading1,
        heading2: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].heading2,
        heading3: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].heading3,
        heading4: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].heading4,
        heading5: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].heading5,
        heading6: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].heading6
    }))();
/**
 * The `HeadingButtonsUI` plugin defines a set of UI buttons that can be used instead of the
 * standard drop down component.
 *
 * This feature is not enabled by default by the {@link module:heading/heading~Heading} plugin and needs to be
 * installed manually to the editor configuration.
 *
 * Plugin introduces button UI elements, which names are same as `model` property from {@link module:heading/headingconfig~HeadingOption}.
 *
 * ```ts
 * ClassicEditor
 *   .create( {
 *     plugins: [ ..., Heading, Paragraph, HeadingButtonsUI, ParagraphButtonUI ]
 *     heading: {
 *       options: [
 *         { model: 'paragraph', title: 'Paragraph', class: 'ck-heading_paragraph' },
 *         { model: 'heading1', view: 'h2', title: 'Heading 1', class: 'ck-heading_heading1' },
 *         { model: 'heading2', view: 'h3', title: 'Heading 2', class: 'ck-heading_heading2' },
 *         { model: 'heading3', view: 'h4', title: 'Heading 3', class: 'ck-heading_heading3' }
 *       ]
 *      },
 *      toolbar: [ 'paragraph', 'heading1', 'heading2', 'heading3' ]
 *   } )
 *   .then( ... )
 *   .catch( ... );
 * ```
 *
 * NOTE: The `'paragraph'` button is defined in by the {@link module:paragraph/paragraphbuttonui~ParagraphButtonUI} plugin
 * which needs to be loaded manually as well.
 *
 * It is possible to use custom icons by providing `icon` config option in {@link module:heading/headingconfig~HeadingOption}.
 * For the default configuration standard icons are used.
 */ class HeadingButtonsUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ init() {
        const options = getLocalizedOptions(this.editor);
        options.filter((item)=>item.model !== 'paragraph').map((item)=>this._createButton(item));
    }
    /**
	 * Creates single button view from provided configuration option.
	 */ _createButton(option) {
        const editor = this.editor;
        editor.ui.componentFactory.add(option.model, (locale)=>{
            const view = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](locale);
            const command = editor.commands.get('heading');
            view.label = option.title;
            view.icon = option.icon || defaultIcons[option.model];
            view.tooltip = true;
            view.isToggleable = true;
            view.bind('isEnabled').to(command);
            view.bind('isOn').to(command, 'value', (value)=>value == option.model);
            view.on('execute', ()=>{
                editor.execute('heading', {
                    value: option.model
                });
                editor.editing.view.focus();
            });
            return view;
        });
    }
}
// A list of element names that should be treated by the Title plugin as title-like.
// This means that an element of a type from this list will be changed to a title element
// when it is the first element in the root.
const titleLikeElements = new Set([
    'paragraph',
    'heading1',
    'heading2',
    'heading3',
    'heading4',
    'heading5',
    'heading6'
]);
/**
 * The Title plugin.
 *
 * It splits the document into `Title` and `Body` sections.
 */ class Title extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * A reference to an empty paragraph in the body
	 * created when there is no element in the body for the placeholder purposes.
	 */ _bodyPlaceholder = new Map();
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Title';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            'Paragraph'
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const model = editor.model;
        // To use the schema for disabling some features when the selection is inside the title element
        // it is needed to create the following structure:
        //
        // <title>
        //     <title-content>The title text</title-content>
        // </title>
        //
        // See: https://github.com/ckeditor/ckeditor5/issues/2005.
        model.schema.register('title', {
            isBlock: true,
            allowIn: '$root'
        });
        model.schema.register('title-content', {
            isBlock: true,
            allowIn: 'title',
            allowAttributes: [
                'alignment'
            ]
        });
        model.schema.extend('$text', {
            allowIn: 'title-content'
        });
        // Disallow all attributes in `title-content`.
        model.schema.addAttributeCheck((context)=>{
            if (context.endsWith('title-content $text')) {
                return false;
            }
        });
        // Because `title` is represented by two elements in the model
        // but only one in the view, it is needed to adjust Mapper.
        editor.editing.mapper.on('modelToViewPosition', mapModelPositionToView(editor.editing.view));
        editor.data.mapper.on('modelToViewPosition', mapModelPositionToView(editor.editing.view));
        // Conversion.
        editor.conversion.for('downcast').elementToElement({
            model: 'title-content',
            view: 'h1'
        });
        editor.conversion.for('downcast').add((dispatcher)=>dispatcher.on('insert:title', (evt, data, conversionApi)=>{
                conversionApi.consumable.consume(data.item, evt.name);
            }));
        // Custom converter is used for data v -> m conversion to avoid calling post-fixer when setting data.
        // See https://github.com/ckeditor/ckeditor5/issues/2036.
        editor.data.upcastDispatcher.on('element:h1', dataViewModelH1Insertion, {
            priority: 'high'
        });
        editor.data.upcastDispatcher.on('element:h2', dataViewModelH1Insertion, {
            priority: 'high'
        });
        editor.data.upcastDispatcher.on('element:h3', dataViewModelH1Insertion, {
            priority: 'high'
        });
        // Take care about correct `title` element structure.
        model.document.registerPostFixer((writer)=>this._fixTitleContent(writer));
        // Create and take care of correct position of a `title` element.
        model.document.registerPostFixer((writer)=>this._fixTitleElement(writer));
        // Create element for `Body` placeholder if it is missing.
        model.document.registerPostFixer((writer)=>this._fixBodyElement(writer));
        // Prevent from adding extra at the end of the document.
        model.document.registerPostFixer((writer)=>this._fixExtraParagraph(writer));
        // Attach `Title` and `Body` placeholders to the empty title and/or content.
        this._attachPlaceholders();
        // Attach Tab handling.
        this._attachTabPressHandling();
    }
    /**
	 * Returns the title of the document. Note that because this plugin does not allow any formatting inside
	 * the title element, the output of this method will be a plain text, with no HTML tags.
	 *
	 * It is not recommended to use this method together with features that insert markers to the
	 * data output, like comments or track changes features. If such markers start in the title and end in the
	 * body, the result of this method might be incorrect.
	 *
	 * @param options Additional configuration passed to the conversion process.
	 * See {@link module:engine/controller/datacontroller~DataController#get `DataController#get`}.
	 * @returns The title of the document.
	 */ getTitle(options = {}) {
        const rootName = options.rootName ? options.rootName : undefined;
        const titleElement = this._getTitleElement(rootName);
        const titleContentElement = titleElement.getChild(0);
        return this.editor.data.stringify(titleContentElement, options);
    }
    /**
	 * Returns the body of the document.
	 *
	 * Note that it is not recommended to use this method together with features that insert markers to the
	 * data output, like comments or track changes features. If such markers start in the title and end in the
	 * body, the result of this method might be incorrect.
	 *
	 * @param options Additional configuration passed to the conversion process.
	 * See {@link module:engine/controller/datacontroller~DataController#get `DataController#get`}.
	 * @returns The body of the document.
	 */ getBody(options = {}) {
        const editor = this.editor;
        const data = editor.data;
        const model = editor.model;
        const rootName = options.rootName ? options.rootName : undefined;
        const root = editor.model.document.getRoot(rootName);
        const view = editor.editing.view;
        const viewWriter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DowncastWriter"](view.document);
        const rootRange = model.createRangeIn(root);
        const viewDocumentFragment = viewWriter.createDocumentFragment();
        // Find all markers that intersects with body.
        const bodyStartPosition = model.createPositionAfter(root.getChild(0));
        const bodyRange = model.createRange(bodyStartPosition, model.createPositionAt(root, 'end'));
        const markers = new Map();
        for (const marker of model.markers){
            const intersection = bodyRange.getIntersection(marker.getRange());
            if (intersection) {
                markers.set(marker.name, intersection);
            }
        }
        // Convert the entire root to view.
        data.mapper.clearBindings();
        data.mapper.bindElements(root, viewDocumentFragment);
        data.downcastDispatcher.convert(rootRange, markers, viewWriter, options);
        // Remove title element from view.
        viewWriter.remove(viewWriter.createRangeOn(viewDocumentFragment.getChild(0)));
        // view -> data
        return editor.data.processor.toData(viewDocumentFragment);
    }
    /**
	 * Returns the `title` element when it is in the document. Returns `undefined` otherwise.
	 */ _getTitleElement(rootName) {
        const root = this.editor.model.document.getRoot(rootName);
        for (const child of root.getChildren()){
            if (isTitle(child)) {
                return child;
            }
        }
    }
    /**
	 * Model post-fixer callback that ensures that `title` has only one `title-content` child.
	 * All additional children should be moved after the `title` element and renamed to a paragraph.
	 */ _fixTitleContent(writer) {
        let changed = false;
        for (const rootName of this.editor.model.document.getRootNames()){
            const title = this._getTitleElement(rootName);
            // If there is no title in the content it will be created by `_fixTitleElement` post-fixer.
            // If the title has just one element, then it is correct. No fixing.
            if (!title || title.maxOffset === 1) {
                continue;
            }
            const titleChildren = Array.from(title.getChildren());
            // Skip first child because it is an allowed element.
            titleChildren.shift();
            for (const titleChild of titleChildren){
                writer.move(writer.createRangeOn(titleChild), title, 'after');
                writer.rename(titleChild, 'paragraph');
            }
            changed = true;
        }
        return changed;
    }
    /**
	 * Model post-fixer callback that creates a title element when it is missing,
	 * takes care of the correct position of it and removes additional title elements.
	 */ _fixTitleElement(writer) {
        let changed = false;
        const model = this.editor.model;
        for (const modelRoot of this.editor.model.document.getRoots()){
            const titleElements = Array.from(modelRoot.getChildren()).filter(isTitle);
            const firstTitleElement = titleElements[0];
            const firstRootChild = modelRoot.getChild(0);
            // When title element is at the beginning of the document then try to fix additional title elements (if there are any).
            if (firstRootChild.is('element', 'title')) {
                if (titleElements.length > 1) {
                    fixAdditionalTitleElements(titleElements, writer, model);
                    changed = true;
                }
                continue;
            }
            // When there is no title in the document and first element in the document cannot be changed
            // to the title then create an empty title element at the beginning of the document.
            if (!firstTitleElement && !titleLikeElements.has(firstRootChild.name)) {
                const title = writer.createElement('title');
                writer.insert(title, modelRoot);
                writer.insertElement('title-content', title);
                changed = true;
                continue;
            }
            if (titleLikeElements.has(firstRootChild.name)) {
                // Change the first element in the document to the title if it can be changed (is title-like).
                changeElementToTitle(firstRootChild, writer, model);
            } else {
                // Otherwise, move the first occurrence of the title element to the beginning of the document.
                writer.move(writer.createRangeOn(firstTitleElement), modelRoot, 0);
            }
            fixAdditionalTitleElements(titleElements, writer, model);
            changed = true;
        }
        return changed;
    }
    /**
	 * Model post-fixer callback that adds an empty paragraph at the end of the document
	 * when it is needed for the placeholder purposes.
	 */ _fixBodyElement(writer) {
        let changed = false;
        for (const rootName of this.editor.model.document.getRootNames()){
            const modelRoot = this.editor.model.document.getRoot(rootName);
            if (modelRoot.childCount < 2) {
                const placeholder = writer.createElement('paragraph');
                writer.insert(placeholder, modelRoot, 1);
                this._bodyPlaceholder.set(rootName, placeholder);
                changed = true;
            }
        }
        return changed;
    }
    /**
	 * Model post-fixer callback that removes a paragraph from the end of the document
	 * if it was created for the placeholder purposes and is not needed anymore.
	 */ _fixExtraParagraph(writer) {
        let changed = false;
        for (const rootName of this.editor.model.document.getRootNames()){
            const root = this.editor.model.document.getRoot(rootName);
            const placeholder = this._bodyPlaceholder.get(rootName);
            if (shouldRemoveLastParagraph(placeholder, root)) {
                this._bodyPlaceholder.delete(rootName);
                writer.remove(placeholder);
                changed = true;
            }
        }
        return changed;
    }
    /**
	 * Attaches the `Title` and `Body` placeholders to the title and/or content.
	 */ _attachPlaceholders() {
        const editor = this.editor;
        const t = editor.t;
        const view = editor.editing.view;
        const sourceElement = editor.sourceElement;
        const titlePlaceholder = editor.config.get('title.placeholder') || t('Type your title');
        const bodyPlaceholder = editor.config.get('placeholder') || sourceElement && sourceElement.tagName.toLowerCase() === 'textarea' && sourceElement.getAttribute('placeholder') || t('Type or paste your content here.');
        // Attach placeholder to the view title element.
        editor.editing.downcastDispatcher.on('insert:title-content', (evt, data, conversionApi)=>{
            const element = conversionApi.mapper.toViewElement(data.item);
            element.placeholder = titlePlaceholder;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enablePlaceholder"])({
                view,
                element,
                keepOnFocus: true
            });
        });
        // Attach placeholder to first element after a title element and remove it if it's not needed anymore.
        // First element after title can change, so we need to observe all changes keep placeholder in sync.
        const bodyViewElements = new Map();
        // This post-fixer runs after the model post-fixer, so we can assume that the second child in view root will always exist.
        view.document.registerPostFixer((writer)=>{
            let hasChanged = false;
            for (const viewRoot of view.document.roots){
                // `viewRoot` can be empty despite the model post-fixers if the model root was detached.
                if (viewRoot.isEmpty) {
                    continue;
                }
                // If `viewRoot` is not empty, then we can expect at least two elements in it.
                const body = viewRoot.getChild(1);
                const oldBody = bodyViewElements.get(viewRoot.rootName);
                // If body element has changed we need to disable placeholder on the previous element and enable on the new one.
                if (body !== oldBody) {
                    if (oldBody) {
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hidePlaceholder"])(writer, oldBody);
                        writer.removeAttribute('data-placeholder', oldBody);
                    }
                    writer.setAttribute('data-placeholder', bodyPlaceholder, body);
                    bodyViewElements.set(viewRoot.rootName, body);
                    hasChanged = true;
                }
                // Then we need to display placeholder if it is needed.
                // See: https://github.com/ckeditor/ckeditor5/issues/8689.
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["needsPlaceholder"])(body, true) && viewRoot.childCount === 2 && body.name === 'p') {
                    hasChanged = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["showPlaceholder"])(writer, body) ? true : hasChanged;
                } else {
                    // Or hide if it is not needed.
                    hasChanged = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hidePlaceholder"])(writer, body) ? true : hasChanged;
                }
            }
            return hasChanged;
        });
    }
    /**
	 * Creates navigation between the title and body sections using <kbd>Tab</kbd> and <kbd>Shift</kbd>+<kbd>Tab</kbd> keys.
	 */ _attachTabPressHandling() {
        const editor = this.editor;
        const model = editor.model;
        // Pressing <kbd>Tab</kbd> inside the title should move the caret to the body.
        editor.keystrokes.set('TAB', (data, cancel)=>{
            model.change((writer)=>{
                const selection = model.document.selection;
                const selectedElements = Array.from(selection.getSelectedBlocks());
                if (selectedElements.length === 1 && selectedElements[0].is('element', 'title-content')) {
                    const root = selection.getFirstPosition().root;
                    const firstBodyElement = root.getChild(1);
                    writer.setSelection(firstBodyElement, 0);
                    cancel();
                }
            });
        });
        // Pressing <kbd>Shift</kbd>+<kbd>Tab</kbd> at the beginning of the body should move the caret to the title.
        editor.keystrokes.set('SHIFT + TAB', (data, cancel)=>{
            model.change((writer)=>{
                const selection = model.document.selection;
                if (!selection.isCollapsed) {
                    return;
                }
                const selectedElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(selection.getSelectedBlocks());
                const selectionPosition = selection.getFirstPosition();
                const root = editor.model.document.getRoot(selectionPosition.root.rootName);
                const title = root.getChild(0);
                const body = root.getChild(1);
                if (selectedElement === body && selectionPosition.isAtStart) {
                    writer.setSelection(title.getChild(0), 0);
                    cancel();
                }
            });
        });
    }
}
/**
 * A view-to-model converter for the h1 that appears at the beginning of the document (a title element).
 *
 * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element
 * @param evt An object containing information about the fired event.
 * @param data An object containing conversion input, a placeholder for conversion output and possibly other values.
 * @param conversionApi Conversion interface to be used by the callback.
 */ function dataViewModelH1Insertion(evt, data, conversionApi) {
    const modelCursor = data.modelCursor;
    const viewItem = data.viewItem;
    if (!modelCursor.isAtStart || !modelCursor.parent.is('element', '$root')) {
        return;
    }
    if (!conversionApi.consumable.consume(viewItem, {
        name: true
    })) {
        return;
    }
    const modelWriter = conversionApi.writer;
    const title = modelWriter.createElement('title');
    const titleContent = modelWriter.createElement('title-content');
    modelWriter.append(titleContent, title);
    modelWriter.insert(title, modelCursor);
    conversionApi.convertChildren(viewItem, titleContent);
    conversionApi.updateConversionResult(title, data);
}
/**
 * Maps position from the beginning of the model `title` element to the beginning of the view `h1` element.
 *
 * ```html
 * <title>^<title-content>Foo</title-content></title> -> <h1>^Foo</h1>
 * ```
 */ function mapModelPositionToView(editingView) {
    return (evt, data)=>{
        const positionParent = data.modelPosition.parent;
        if (!positionParent.is('element', 'title')) {
            return;
        }
        const modelTitleElement = positionParent.parent;
        const viewElement = data.mapper.toViewElement(modelTitleElement);
        data.viewPosition = editingView.createPositionAt(viewElement, 0);
        evt.stop();
    };
}
/**
 * @returns Returns true when given element is a title. Returns false otherwise.
 */ function isTitle(element) {
    return element.is('element', 'title');
}
/**
 * Changes the given element to the title element.
 */ function changeElementToTitle(element, writer, model) {
    const title = writer.createElement('title');
    writer.insert(title, element, 'before');
    writer.insert(element, title, 0);
    writer.rename(element, 'title-content');
    model.schema.removeDisallowedAttributes([
        element
    ], writer);
}
/**
 * Loops over the list of title elements and fixes additional ones.
 *
 * @returns Returns true when there was any change. Returns false otherwise.
 */ function fixAdditionalTitleElements(titleElements, writer, model) {
    let hasChanged = false;
    for (const title of titleElements){
        if (title.index !== 0) {
            fixTitleElement(title, writer, model);
            hasChanged = true;
        }
    }
    return hasChanged;
}
/**
 * Changes given title element to a paragraph or removes it when it is empty.
 */ function fixTitleElement(title, writer, model) {
    const child = title.getChild(0);
    // Empty title should be removed.
    // It is created as a result of pasting to the title element.
    if (child.isEmpty) {
        writer.remove(title);
        return;
    }
    writer.move(writer.createRangeOn(child), title, 'before');
    writer.rename(child, 'paragraph');
    writer.remove(title);
    model.schema.removeDisallowedAttributes([
        child
    ], writer);
}
/**
 * Returns true when the last paragraph in the document was created only for the placeholder
 * purpose and it's not needed anymore. Returns false otherwise.
 */ function shouldRemoveLastParagraph(placeholder, root) {
    if (!placeholder || !placeholder.is('element', 'paragraph') || placeholder.childCount) {
        return false;
    }
    if (root.childCount <= 2 || root.getChild(root.childCount - 1) !== placeholder) {
        return false;
    }
    return true;
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-highlight/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Highlight": (()=>Highlight),
    "HighlightEditing": (()=>HighlightEditing),
    "HighlightUI": (()=>HighlightUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
;
;
/**
 * The highlight command. It is used by the {@link module:highlight/highlightediting~HighlightEditing highlight feature}
 * to apply the text highlighting.
 *
 * ```ts
 * editor.execute( 'highlight', { value: 'greenMarker' } );
 * ```
 *
 * **Note**: Executing the command without a value removes the attribute from the model. If the selection is collapsed
 * inside a text with the highlight attribute, the command will remove the attribute from the entire range
 * of that text.
 */ class HighlightCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const doc = model.document;
        this.value = doc.selection.getAttribute('highlight');
        this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, 'highlight');
    }
    /**
	 * Executes the command.
	 *
	 * @param options Options for the executed command.
	 * @param options.value The value to apply.
	 *
	 * @fires execute
	 */ execute(options = {}) {
        const model = this.editor.model;
        const document = model.document;
        const selection = document.selection;
        const highlighter = options.value;
        model.change((writer)=>{
            if (selection.isCollapsed) {
                const position = selection.getFirstPosition();
                // When selection is inside text with `highlight` attribute.
                if (selection.hasAttribute('highlight')) {
                    // Find the full highlighted range.
                    const isSameHighlight = (value)=>{
                        return value.item.hasAttribute('highlight') && value.item.getAttribute('highlight') === this.value;
                    };
                    const highlightStart = position.getLastMatchingPosition(isSameHighlight, {
                        direction: 'backward'
                    });
                    const highlightEnd = position.getLastMatchingPosition(isSameHighlight);
                    const highlightRange = writer.createRange(highlightStart, highlightEnd);
                    // Then depending on current value...
                    if (!highlighter || this.value === highlighter) {
                        // ...remove attribute when passing highlighter different then current or executing "eraser".
                        // If we're at the end of the highlighted range, we don't want to remove highlight of the range.
                        if (!position.isEqual(highlightEnd)) {
                            writer.removeAttribute('highlight', highlightRange);
                        }
                        writer.removeSelectionAttribute('highlight');
                    } else {
                        // ...update `highlight` value.
                        // If we're at the end of the highlighted range, we don't want to change the highlight of the range.
                        if (!position.isEqual(highlightEnd)) {
                            writer.setAttribute('highlight', highlighter, highlightRange);
                        }
                        writer.setSelectionAttribute('highlight', highlighter);
                    }
                } else if (highlighter) {
                    writer.setSelectionAttribute('highlight', highlighter);
                }
            } else {
                const ranges = model.schema.getValidRanges(selection.getRanges(), 'highlight');
                for (const range of ranges){
                    if (highlighter) {
                        writer.setAttribute('highlight', highlighter, range);
                    } else {
                        writer.removeAttribute('highlight', range);
                    }
                }
            }
        });
    }
}
/**
 * The highlight editing feature. It introduces the {@link module:highlight/highlightcommand~HighlightCommand command} and the `highlight`
 * attribute in the {@link module:engine/model/model~Model model} which renders in the {@link module:engine/view/view view}
 * as a `<mark>` element with a `class` attribute (`<mark class="marker-green">...</mark>`) depending
 * on the {@link module:highlight/highlightconfig~HighlightConfig configuration}.
 */ class HighlightEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'HighlightEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('highlight', {
            options: [
                {
                    model: 'yellowMarker',
                    class: 'marker-yellow',
                    title: 'Yellow marker',
                    color: 'var(--ck-highlight-marker-yellow)',
                    type: 'marker'
                },
                {
                    model: 'greenMarker',
                    class: 'marker-green',
                    title: 'Green marker',
                    color: 'var(--ck-highlight-marker-green)',
                    type: 'marker'
                },
                {
                    model: 'pinkMarker',
                    class: 'marker-pink',
                    title: 'Pink marker',
                    color: 'var(--ck-highlight-marker-pink)',
                    type: 'marker'
                },
                {
                    model: 'blueMarker',
                    class: 'marker-blue',
                    title: 'Blue marker',
                    color: 'var(--ck-highlight-marker-blue)',
                    type: 'marker'
                },
                {
                    model: 'redPen',
                    class: 'pen-red',
                    title: 'Red pen',
                    color: 'var(--ck-highlight-pen-red)',
                    type: 'pen'
                },
                {
                    model: 'greenPen',
                    class: 'pen-green',
                    title: 'Green pen',
                    color: 'var(--ck-highlight-pen-green)',
                    type: 'pen'
                }
            ]
        });
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        // Allow highlight attribute on text nodes.
        editor.model.schema.extend('$text', {
            allowAttributes: 'highlight'
        });
        const options = editor.config.get('highlight.options');
        // Set-up the two-way conversion.
        editor.conversion.attributeToElement(_buildDefinition(options));
        editor.commands.add('highlight', new HighlightCommand(editor));
    }
}
/**
 * Converts the options array to a converter definition.
 *
 * @param options An array with configured options.
 */ function _buildDefinition(options) {
    const definition = {
        model: {
            key: 'highlight',
            values: []
        },
        view: {}
    };
    for (const option of options){
        definition.model.values.push(option.model);
        definition.view[option.model] = {
            name: 'mark',
            classes: option.class
        };
    }
    return definition;
}
var markerIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path class=\"ck-icon__fill\" d=\"M10.798 1.59 3.002 12.875l1.895 1.852 2.521 1.402 6.997-12.194z\"/><path d=\"m2.556 16.727.234-.348c-.297-.151-.462-.293-.498-.426-.036-.137.002-.416.115-.837.094-.25.15-.449.169-.595a4.495 4.495 0 0 0 0-.725c-.209-.621-.303-1.041-.284-1.26.02-.218.178-.506.475-.862l6.77-9.414c.539-.91 1.605-.85 3.199.18 1.594 1.032 2.188 1.928 1.784 2.686l-5.877 10.36c-.158.412-.333.673-.526.782-.193.108-.604.179-1.232.21-.362.131-.608.237-.738.318-.13.081-.305.238-.526.47-.293.265-.504.397-.632.397-.096 0-.27-.075-.524-.226l-.31.41-1.6-1.12zm-.279.415 1.575 1.103-.392.515H1.19l1.087-1.618zm8.1-13.656-4.953 6.9L8.75 12.57l4.247-7.574c.175-.25-.188-.647-1.092-1.192-.903-.546-1.412-.652-1.528-.32zM8.244 18.5 9.59 17h9.406v1.5H8.245z\"/></svg>";
var penIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path class=\"ck-icon__fill\" d=\"M10.126 2.268 2.002 13.874l1.895 1.852 2.521 1.402L14.47 5.481l-1.543-2.568-2.801-.645z\"/><path d=\"m4.5 18.088-2.645-1.852-.04-2.95-.006-.005.006-.008v-.025l.011.008L8.73 2.97c.165-.233.356-.417.567-.557l-1.212.308L4.604 7.9l-.83-.558 3.694-5.495 2.708-.69 1.65 1.145.046.018.85-1.216 2.16 1.512-.856 1.222c.828.967 1.144 2.141.432 3.158L7.55 17.286l.006.005-3.055.797H4.5zm-.634.166-1.976.516-.026-1.918 2.002 1.402zM9.968 3.817l-.006-.004-6.123 9.184 3.277 2.294 6.108-9.162.005.003c.317-.452-.16-1.332-1.064-1.966-.891-.624-1.865-.776-2.197-.349zM8.245 18.5 9.59 17h9.406v1.5H8.245z\"/></svg>";
/**
 * The default highlight UI plugin. It introduces:
 *
 * * The `'highlight'` dropdown,
 * * The `'removeHighlight'` and `'highlight:*'` buttons.
 *
 * The default configuration includes the following buttons:
 *
 * * `'highlight:yellowMarker'`
 * * `'highlight:greenMarker'`
 * * `'highlight:pinkMarker'`
 * * `'highlight:blueMarker'`
 * * `'highlight:redPen'`
 * * `'highlight:greenPen'`
 *
 * See the {@link module:highlight/highlightconfig~HighlightConfig#options configuration} to learn more
 * about the defaults.
 */ class HighlightUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * Returns the localized option titles provided by the plugin.
	 *
	 * The following localized titles corresponding with default
	 * {@link module:highlight/highlightconfig~HighlightConfig#options} are available:
	 *
	 * * `'Yellow marker'`,
	 * * `'Green marker'`,
	 * * `'Pink marker'`,
	 * * `'Blue marker'`,
	 * * `'Red pen'`,
	 * * `'Green pen'`.
	 */ get localizedOptionTitles() {
        const t = this.editor.t;
        return {
            'Yellow marker': t('Yellow marker'),
            'Green marker': t('Green marker'),
            'Pink marker': t('Pink marker'),
            'Blue marker': t('Blue marker'),
            'Red pen': t('Red pen'),
            'Green pen': t('Green pen')
        };
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'HighlightUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const options = this.editor.config.get('highlight.options');
        for (const option of options){
            this._addHighlighterButton(option);
        }
        this._addRemoveHighlightButton();
        this._addDropdown(options);
        this._addMenuBarButton(options);
    }
    /**
	 * Creates the "Remove highlight" button.
	 */ _addRemoveHighlightButton() {
        const t = this.editor.t;
        const command = this.editor.commands.get('highlight');
        this._addButton('removeHighlight', t('Remove highlight'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].eraser, null, (button)=>{
            button.bind('isEnabled').to(command, 'isEnabled');
        });
    }
    /**
	 * Creates a toolbar button from the provided highlight option.
	 */ _addHighlighterButton(option) {
        const command = this.editor.commands.get('highlight');
        // TODO: change naming
        this._addButton('highlight:' + option.model, option.title, getIconForType(option.type), option.model, decorateHighlightButton);
        function decorateHighlightButton(button) {
            button.bind('isEnabled').to(command, 'isEnabled');
            button.bind('isOn').to(command, 'value', (value)=>value === option.model);
            button.iconView.fillColor = option.color;
            button.isToggleable = true;
        }
    }
    /**
	 * Internal method for creating highlight buttons.
	 *
	 * @param name The name of the button.
	 * @param label The label for the button.
	 * @param icon The button icon.
	 * @param value The `value` property passed to the executed command.
	 * @param decorateButton A callback getting ButtonView instance so that it can be further customized.
	 */ _addButton(name, label, icon, value, decorateButton) {
        const editor = this.editor;
        editor.ui.componentFactory.add(name, (locale)=>{
            const buttonView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](locale);
            const localized = this.localizedOptionTitles[label] ? this.localizedOptionTitles[label] : label;
            buttonView.set({
                label: localized,
                icon,
                tooltip: true
            });
            buttonView.on('execute', ()=>{
                editor.execute('highlight', {
                    value
                });
                editor.editing.view.focus();
            });
            // Add additional behavior for buttonView.
            decorateButton(buttonView);
            return buttonView;
        });
    }
    /**
	 * Creates the split button dropdown UI from the provided highlight options.
	 */ _addDropdown(options) {
        const editor = this.editor;
        const t = editor.t;
        const componentFactory = editor.ui.componentFactory;
        const startingHighlighter = options[0];
        const optionsMap = options.reduce((retVal, option)=>{
            retVal[option.model] = option;
            return retVal;
        }, {});
        componentFactory.add('highlight', (locale)=>{
            const command = editor.commands.get('highlight');
            const dropdownView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDropdown"])(locale, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SplitButtonView"]);
            const splitButtonView = dropdownView.buttonView;
            splitButtonView.set({
                label: t('Highlight'),
                tooltip: true,
                // Holds last executed highlighter.
                lastExecuted: startingHighlighter.model,
                // Holds current highlighter to execute (might be different then last used).
                commandValue: startingHighlighter.model,
                isToggleable: true
            });
            // Dropdown button changes to selection (command.value):
            // - If selection is in highlight it get active highlight appearance (icon, color) and is activated.
            // - Otherwise it gets appearance (icon, color) of last executed highlight.
            splitButtonView.bind('icon').to(command, 'value', (value)=>getIconForType(getActiveOption(value, 'type')));
            splitButtonView.bind('color').to(command, 'value', (value)=>getActiveOption(value, 'color'));
            splitButtonView.bind('commandValue').to(command, 'value', (value)=>getActiveOption(value, 'model'));
            splitButtonView.bind('isOn').to(command, 'value', (value)=>!!value);
            splitButtonView.delegate('execute').to(dropdownView);
            // Create buttons array.
            const buttonsCreator = ()=>{
                const buttons = options.map((option)=>{
                    // Get existing highlighter button.
                    const buttonView = componentFactory.create('highlight:' + option.model);
                    // Update lastExecutedHighlight on execute.
                    this.listenTo(buttonView, 'execute', ()=>{
                        dropdownView.buttonView.set({
                            lastExecuted: option.model
                        });
                    });
                    return buttonView;
                });
                // Add separator and eraser buttons to dropdown.
                buttons.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToolbarSeparatorView"]());
                buttons.push(componentFactory.create('removeHighlight'));
                return buttons;
            };
            // Make toolbar button enabled when any button in dropdown is enabled before adding separator and eraser.
            dropdownView.bind('isEnabled').to(command, 'isEnabled');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addToolbarToDropdown"])(dropdownView, buttonsCreator, {
                enableActiveItemFocusOnDropdownOpen: true,
                ariaLabel: t('Text highlight toolbar')
            });
            bindToolbarIconStyleToActiveColor(dropdownView);
            // Execute current action from dropdown's split button action button.
            splitButtonView.on('execute', ()=>{
                editor.execute('highlight', {
                    value: splitButtonView.commandValue
                });
            });
            // Focus the editable after executing the command.
            // It overrides a default behaviour where the focus is moved to the dropdown button (#12125).
            this.listenTo(dropdownView, 'execute', ()=>{
                editor.editing.view.focus();
            });
            /**
			 * Returns active highlighter option depending on current command value.
			 * If current is not set or it is the same as last execute this method will return the option key (like icon or color)
			 * of last executed highlighter. Otherwise it will return option key for current one.
			 */ function getActiveOption(current, key) {
                const whichHighlighter = !current || current === splitButtonView.lastExecuted ? splitButtonView.lastExecuted : current;
                return optionsMap[whichHighlighter][key];
            }
            return dropdownView;
        });
    }
    /**
	 * Creates the menu bar button for highlight including submenu with available options.
	 */ _addMenuBarButton(options) {
        const editor = this.editor;
        const t = editor.t;
        const command = editor.commands.get('highlight');
        editor.ui.componentFactory.add('menuBar:highlight', (locale)=>{
            const menuView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuView"](locale);
            menuView.buttonView.set({
                label: t('Highlight'),
                icon: getIconForType('marker')
            });
            menuView.bind('isEnabled').to(command);
            menuView.buttonView.iconView.fillColor = 'transparent';
            const listView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListView"](locale);
            for (const option of options){
                const listItemView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemView"](locale, menuView);
                const buttonView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"](locale);
                buttonView.set({
                    label: option.title,
                    icon: getIconForType(option.type),
                    role: 'menuitemradio',
                    isToggleable: true
                });
                buttonView.iconView.fillColor = option.color;
                buttonView.delegate('execute').to(menuView);
                buttonView.bind('isOn').to(command, 'value', (value)=>value === option.model);
                buttonView.on('execute', ()=>{
                    editor.execute('highlight', {
                        value: option.model
                    });
                    editor.editing.view.focus();
                });
                listItemView.children.add(buttonView);
                listView.items.add(listItemView);
            }
            // Add remove highlight button
            listView.items.add(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ListSeparatorView"](locale));
            const listItemView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemView"](locale, menuView);
            const buttonView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"](locale);
            buttonView.set({
                label: t('Remove highlight'),
                icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].eraser
            });
            buttonView.delegate('execute').to(menuView);
            buttonView.on('execute', ()=>{
                editor.execute('highlight', {
                    value: null
                });
                editor.editing.view.focus();
            });
            listItemView.children.add(buttonView);
            listView.items.add(listItemView);
            menuView.panelView.children.add(listView);
            return menuView;
        });
    }
}
/**
 * Extends split button icon style to reflect last used button style.
 */ function bindToolbarIconStyleToActiveColor(dropdownView) {
    const actionView = dropdownView.buttonView.actionView;
    actionView.iconView.bind('fillColor').to(dropdownView.buttonView, 'color');
}
/**
 * Returns icon for given highlighter type.
 */ function getIconForType(type) {
    return type === 'marker' ? markerIcon : penIcon;
}
/**
 * The highlight plugin.
 *
 * For a detailed overview, check the {@glink features/highlight Highlight feature} documentation.
 *
 * This is a "glue" plugin which loads the {@link module:highlight/highlightediting~HighlightEditing} and
 * {@link module:highlight/highlightui~HighlightUI} plugins.
 */ class Highlight extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            HighlightEditing,
            HighlightUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Highlight';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-horizontal-line/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "HorizontalLine": (()=>HorizontalLine),
    "HorizontalLineEditing": (()=>HorizontalLineEditing),
    "HorizontalLineUI": (()=>HorizontalLineUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-widget/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
;
;
;
/**
 * The horizontal line command.
 *
 * The command is registered by {@link module:horizontal-line/horizontallineediting~HorizontalLineEditing} as `'horizontalLine'`.
 *
 * To insert a horizontal line at the current selection, execute the command:
 *
 * ```ts
 * editor.execute( 'horizontalLine' );
 * ```
 */ class HorizontalLineCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const schema = model.schema;
        const selection = model.document.selection;
        this.isEnabled = isHorizontalLineAllowedInParent(selection, schema, model);
    }
    /**
	 * Executes the command.
	 *
	 * @fires execute
	 */ execute() {
        const model = this.editor.model;
        model.change((writer)=>{
            const horizontalElement = writer.createElement('horizontalLine');
            model.insertObject(horizontalElement, null, null, {
                setSelection: 'after'
            });
        });
    }
}
/**
 * Checks if a horizontal line is allowed by the schema in the optimal insertion parent.
 *
 * @param model Model instance.
 */ function isHorizontalLineAllowedInParent(selection, schema, model) {
    const parent = getInsertHorizontalLineParent(selection, model);
    return schema.checkChild(parent, 'horizontalLine');
}
/**
 * Returns a node that will be used to insert a horizontal line with `model.insertContent` to check if the horizontal line can be
 * placed there.
 *
 * @param model Model instance.
 */ function getInsertHorizontalLineParent(selection, model) {
    const insertionRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findOptimalInsertionRange"])(selection, model);
    const parent = insertionRange.start.parent;
    if (parent.isEmpty && !parent.is('element', '$root')) {
        return parent.parent;
    }
    return parent;
}
/**
 * The horizontal line editing feature.
 */ class HorizontalLineEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'HorizontalLineEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        const t = editor.t;
        const conversion = editor.conversion;
        schema.register('horizontalLine', {
            inheritAllFrom: '$blockObject'
        });
        conversion.for('dataDowncast').elementToElement({
            model: 'horizontalLine',
            view: (modelElement, { writer })=>{
                return writer.createEmptyElement('hr');
            }
        });
        conversion.for('editingDowncast').elementToStructure({
            model: 'horizontalLine',
            view: (modelElement, { writer })=>{
                const label = t('Horizontal line');
                const viewWrapper = writer.createContainerElement('div', null, writer.createEmptyElement('hr'));
                writer.addClass('ck-horizontal-line', viewWrapper);
                writer.setCustomProperty('hr', true, viewWrapper);
                return toHorizontalLineWidget(viewWrapper, writer, label);
            }
        });
        conversion.for('upcast').elementToElement({
            view: 'hr',
            model: 'horizontalLine'
        });
        editor.commands.add('horizontalLine', new HorizontalLineCommand(editor));
    }
}
/**
 * Converts a given {@link module:engine/view/element~Element} to a horizontal line widget:
 * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to
 *   recognize the horizontal line widget element.
 * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.
 *
 * @param writer An instance of the view writer.
 */ function toHorizontalLineWidget(viewElement, writer, label) {
    writer.setCustomProperty('horizontalLine', true, viewElement);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toWidget"])(viewElement, writer, {
        label
    });
}
/**
 * The horizontal line UI plugin.
 */ class HorizontalLineUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'HorizontalLineUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        // Add the `horizontalLine` button to feature components.
        editor.ui.componentFactory.add('horizontalLine', ()=>{
            const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
            buttonView.set({
                tooltip: true
            });
            return buttonView;
        });
        editor.ui.componentFactory.add('menuBar:horizontalLine', ()=>{
            return this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
        });
    }
    /**
	 * Creates a button for horizontal line command to use either in toolbar or in menu bar.
	 */ _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = editor.commands.get('horizontalLine');
        const view = new ButtonClass(editor.locale);
        const t = locale.t;
        view.set({
            label: t('Horizontal line'),
            icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].horizontalLine
        });
        view.bind('isEnabled').to(command, 'isEnabled');
        // Execute the command.
        this.listenTo(view, 'execute', ()=>{
            editor.execute('horizontalLine');
            editor.editing.view.focus();
        });
        return view;
    }
}
/**
 * The horizontal line feature.
 *
 * It provides the possibility to insert a horizontal line into the rich-text editor.
 *
 * For a detailed overview, check the {@glink features/horizontal-line Horizontal line feature} documentation.
 */ class HorizontalLine extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            HorizontalLineEditing,
            HorizontalLineUI,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Widget"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'HorizontalLine';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-html-embed/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "HtmlEmbed": (()=>HtmlEmbed),
    "HtmlEmbedEditing": (()=>HtmlEmbedEditing),
    "HtmlEmbedUI": (()=>HtmlEmbedUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-widget/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
;
;
;
;
/**
 * The insert HTML embed element command.
 *
 * The command is registered by {@link module:html-embed/htmlembedediting~HtmlEmbedEditing} as `'htmlEmbed'`.
 *
 * To insert an empty HTML embed element at the current selection, execute the command:
 *
 * ```ts
 * editor.execute( 'htmlEmbed' );
 * ```
 *
 * You can specify the initial content of a new HTML embed in the argument:
 *
 * ```ts
 * editor.execute( 'htmlEmbed', '<b>Initial content.</b>' );
 * ```
 *
 * To update the content of the HTML embed, select it in the model and pass the content in the argument:
 *
 * ```ts
 * editor.execute( 'htmlEmbed', '<b>New content of an existing embed.</b>' );
 * ```
 */ class HtmlEmbedCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const schema = model.schema;
        const selection = model.document.selection;
        const selectedRawHtmlElement = getSelectedRawHtmlModelWidget(selection);
        this.isEnabled = isHtmlEmbedAllowedInParent(selection, schema, model);
        this.value = selectedRawHtmlElement ? selectedRawHtmlElement.getAttribute('value') || '' : null;
    }
    /**
	 * Executes the command, which either:
	 *
	 * * creates and inserts a new HTML embed element if none was selected,
	 * * updates the content of the HTML embed if one was selected.
	 *
	 * @fires execute
	 * @param value When passed, the value (content) will be set on a new embed or a selected one.
	 */ execute(value) {
        const model = this.editor.model;
        const selection = model.document.selection;
        model.change((writer)=>{
            let htmlEmbedElement;
            // If the command has a non-null value, there must be some HTML embed selected in the model.
            if (this.value !== null) {
                htmlEmbedElement = getSelectedRawHtmlModelWidget(selection);
            } else {
                htmlEmbedElement = writer.createElement('rawHtml');
                model.insertObject(htmlEmbedElement, null, null, {
                    setSelection: 'on'
                });
            }
            writer.setAttribute('value', value, htmlEmbedElement);
        });
    }
}
/**
 * Checks if an HTML embed is allowed by the schema in the optimal insertion parent.
 */ function isHtmlEmbedAllowedInParent(selection, schema, model) {
    const parent = getInsertHtmlEmbedParent(selection, model);
    return schema.checkChild(parent, 'rawHtml');
}
/**
 * Returns a node that will be used to insert a html embed with `model.insertContent` to check if a html embed element can be placed there.
 */ function getInsertHtmlEmbedParent(selection, model) {
    const insertionRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findOptimalInsertionRange"])(selection, model);
    const parent = insertionRange.start.parent;
    if (parent.isEmpty && !parent.is('rootElement')) {
        return parent.parent;
    }
    return parent;
}
/**
 * Returns the selected HTML embed element in the model, if any.
 */ function getSelectedRawHtmlModelWidget(selection) {
    const selectedElement = selection.getSelectedElement();
    if (selectedElement && selectedElement.is('element', 'rawHtml')) {
        return selectedElement;
    }
    return null;
}
/**
 * The HTML embed editing feature.
 */ class HtmlEmbedEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * Keeps references to {@link module:ui/button/buttonview~ButtonView edit, save, and cancel} button instances created for
	 * each widget so they can be destroyed if they are no longer in DOM after the editing view was re-rendered.
	 */ _widgetButtonViewReferences = new Set();
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'HtmlEmbedEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('htmlEmbed', {
            showPreviews: false,
            sanitizeHtml: (rawHtml)=>{
                /**
				 * When using the HTML embed feature with the `config.htmlEmbed.showPreviews` set to `true`, it is strongly recommended to
				 * define a sanitize function that will clean up the input HTML in order to avoid XSS vulnerability.
				 *
				 * For a detailed overview, check the {@glink features/html/html-embed HTML embed feature} documentation.
				 *
				 * @error html-embed-provide-sanitize-function
				 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('html-embed-provide-sanitize-function');
                return {
                    html: rawHtml,
                    hasChanged: false
                };
            }
        });
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        schema.register('rawHtml', {
            inheritAllFrom: '$blockObject',
            allowAttributes: [
                'value'
            ]
        });
        editor.commands.add('htmlEmbed', new HtmlEmbedCommand(editor));
        this._setupConversion();
    }
    /**
	 * Prepares converters for the feature.
	 */ _setupConversion() {
        const editor = this.editor;
        const t = editor.t;
        const view = editor.editing.view;
        const widgetButtonViewReferences = this._widgetButtonViewReferences;
        const htmlEmbedConfig = editor.config.get('htmlEmbed');
        // Destroy UI buttons created for widgets that have been removed from the view document (e.g. in the previous conversion).
        // This prevents unexpected memory leaks from UI views.
        this.editor.editing.view.on('render', ()=>{
            for (const buttonView of widgetButtonViewReferences){
                if (buttonView.element && buttonView.element.isConnected) {
                    return;
                }
                buttonView.destroy();
                widgetButtonViewReferences.delete(buttonView);
            }
        }, {
            priority: 'lowest'
        });
        // Register div.raw-html-embed as a raw content element so all of it's content will be provided
        // as a view element's custom property while data upcasting.
        editor.data.registerRawContentMatcher({
            name: 'div',
            classes: 'raw-html-embed'
        });
        editor.conversion.for('upcast').elementToElement({
            view: {
                name: 'div',
                classes: 'raw-html-embed'
            },
            model: (viewElement, { writer })=>{
                // The div.raw-html-embed is registered as a raw content element,
                // so all it's content is available in a custom property.
                return writer.createElement('rawHtml', {
                    value: viewElement.getCustomProperty('$rawContent')
                });
            }
        });
        editor.conversion.for('dataDowncast').elementToElement({
            model: 'rawHtml',
            view: (modelElement, { writer })=>{
                return writer.createRawElement('div', {
                    class: 'raw-html-embed'
                }, function(domElement) {
                    domElement.innerHTML = modelElement.getAttribute('value') || '';
                });
            }
        });
        editor.conversion.for('editingDowncast').elementToStructure({
            model: {
                name: 'rawHtml',
                attributes: [
                    'value'
                ]
            },
            view: (modelElement, { writer })=>{
                let domContentWrapper;
                let state;
                let props;
                const viewContentWrapper = writer.createRawElement('div', {
                    class: 'raw-html-embed__content-wrapper'
                }, function(domElement) {
                    domContentWrapper = domElement;
                    renderContent({
                        editor,
                        domElement,
                        state,
                        props
                    });
                    // Since there is a `data-cke-ignore-events` attribute set on the wrapper element in the editable mode,
                    // the explicit `mousedown` handler on the `capture` phase is needed to move the selection onto the whole
                    // HTML embed widget.
                    domContentWrapper.addEventListener('mousedown', ()=>{
                        if (state.isEditable) {
                            const model = editor.model;
                            const selectedElement = model.document.selection.getSelectedElement();
                            // Move the selection onto the whole HTML embed widget if it's currently not selected.
                            if (selectedElement !== modelElement) {
                                model.change((writer)=>writer.setSelection(modelElement, 'on'));
                            }
                        }
                    }, true);
                });
                // API exposed on each raw HTML embed widget so other features can control a particular widget.
                const rawHtmlApi = {
                    makeEditable () {
                        state = Object.assign({}, state, {
                            isEditable: true
                        });
                        renderContent({
                            domElement: domContentWrapper,
                            editor,
                            state,
                            props
                        });
                        view.change((writer)=>{
                            writer.setAttribute('data-cke-ignore-events', 'true', viewContentWrapper);
                        });
                        // This could be potentially pulled to a separate method called focusTextarea().
                        domContentWrapper.querySelector('textarea').focus();
                    },
                    save (newValue) {
                        // If the value didn't change, we just cancel. If it changed,
                        // it's enough to update the model – the entire widget will be reconverted.
                        if (newValue !== state.getRawHtmlValue()) {
                            editor.execute('htmlEmbed', newValue);
                            editor.editing.view.focus();
                        } else {
                            this.cancel();
                        }
                    },
                    cancel () {
                        state = Object.assign({}, state, {
                            isEditable: false
                        });
                        renderContent({
                            domElement: domContentWrapper,
                            editor,
                            state,
                            props
                        });
                        editor.editing.view.focus();
                        view.change((writer)=>{
                            writer.removeAttribute('data-cke-ignore-events', viewContentWrapper);
                        });
                    }
                };
                state = {
                    showPreviews: htmlEmbedConfig.showPreviews,
                    isEditable: false,
                    getRawHtmlValue: ()=>modelElement.getAttribute('value') || ''
                };
                props = {
                    sanitizeHtml: htmlEmbedConfig.sanitizeHtml,
                    textareaPlaceholder: t('Paste raw HTML here...'),
                    onEditClick () {
                        rawHtmlApi.makeEditable();
                    },
                    onSaveClick (newValue) {
                        rawHtmlApi.save(newValue);
                    },
                    onCancelClick () {
                        rawHtmlApi.cancel();
                    }
                };
                const viewContainer = writer.createContainerElement('div', {
                    class: 'raw-html-embed',
                    'data-html-embed-label': t('HTML snippet'),
                    dir: editor.locale.uiLanguageDirection
                }, viewContentWrapper);
                writer.setCustomProperty('rawHtmlApi', rawHtmlApi, viewContainer);
                writer.setCustomProperty('rawHtml', true, viewContainer);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toWidget"])(viewContainer, writer, {
                    label: t('HTML snippet'),
                    hasSelectionHandle: true
                });
            }
        });
        function renderContent({ editor, domElement, state, props }) {
            // Remove all children;
            domElement.textContent = '';
            const domDocument = domElement.ownerDocument;
            let domTextarea;
            if (state.isEditable) {
                const textareaProps = {
                    isDisabled: false,
                    placeholder: props.textareaPlaceholder
                };
                domTextarea = createDomTextarea({
                    domDocument,
                    state,
                    props: textareaProps
                });
                domElement.append(domTextarea);
            } else if (state.showPreviews) {
                const previewContainerProps = {
                    sanitizeHtml: props.sanitizeHtml
                };
                domElement.append(createPreviewContainer({
                    domDocument,
                    state,
                    props: previewContainerProps,
                    editor
                }));
            } else {
                const textareaProps = {
                    isDisabled: true,
                    placeholder: props.textareaPlaceholder
                };
                domElement.append(createDomTextarea({
                    domDocument,
                    state,
                    props: textareaProps
                }));
            }
            const buttonsWrapperProps = {
                onEditClick: props.onEditClick,
                onSaveClick: ()=>{
                    props.onSaveClick(domTextarea.value);
                },
                onCancelClick: props.onCancelClick
            };
            domElement.prepend(createDomButtonsWrapper({
                editor,
                domDocument,
                state,
                props: buttonsWrapperProps
            }));
        }
        function createDomButtonsWrapper({ editor, domDocument, state, props }) {
            const domButtonsWrapper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(domDocument, 'div', {
                class: 'raw-html-embed__buttons-wrapper'
            });
            if (state.isEditable) {
                const saveButtonView = createUIButton(editor, 'save', props.onSaveClick);
                const cancelButtonView = createUIButton(editor, 'cancel', props.onCancelClick);
                domButtonsWrapper.append(saveButtonView.element, cancelButtonView.element);
                widgetButtonViewReferences.add(saveButtonView).add(cancelButtonView);
            } else {
                const editButtonView = createUIButton(editor, 'edit', props.onEditClick);
                domButtonsWrapper.append(editButtonView.element);
                widgetButtonViewReferences.add(editButtonView);
            }
            return domButtonsWrapper;
        }
        function createDomTextarea({ domDocument, state, props }) {
            const domTextarea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(domDocument, 'textarea', {
                placeholder: props.placeholder,
                class: 'ck ck-reset ck-input ck-input-text raw-html-embed__source'
            });
            domTextarea.disabled = props.isDisabled;
            domTextarea.value = state.getRawHtmlValue();
            return domTextarea;
        }
        function createPreviewContainer({ editor, domDocument, state, props }) {
            const sanitizedOutput = props.sanitizeHtml(state.getRawHtmlValue());
            const placeholderText = state.getRawHtmlValue().length > 0 ? t('No preview available') : t('Empty snippet content');
            const domPreviewPlaceholder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(domDocument, 'div', {
                class: 'ck ck-reset_all raw-html-embed__preview-placeholder'
            }, placeholderText);
            const domPreviewContent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(domDocument, 'div', {
                class: 'raw-html-embed__preview-content',
                dir: editor.locale.contentLanguageDirection
            });
            // Creating a contextual document fragment allows executing scripts when inserting into the preview element.
            // See: #8326.
            const domRange = domDocument.createRange();
            const domDocumentFragment = domRange.createContextualFragment(sanitizedOutput.html);
            domPreviewContent.appendChild(domDocumentFragment);
            const domPreviewContainer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(domDocument, 'div', {
                class: 'raw-html-embed__preview'
            }, [
                domPreviewPlaceholder,
                domPreviewContent
            ]);
            return domPreviewContainer;
        }
    }
}
/**
 * Returns a UI button view that can be used in conversion.
 */ function createUIButton(editor, type, onClick) {
    const { t } = editor.locale;
    const buttonView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](editor.locale);
    const command = editor.commands.get('htmlEmbed');
    buttonView.set({
        class: `raw-html-embed__${type}-button`,
        icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].pencil,
        tooltip: true,
        tooltipPosition: editor.locale.uiLanguageDirection === 'rtl' ? 'e' : 'w'
    });
    buttonView.render();
    if (type === 'edit') {
        buttonView.set({
            icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].pencil,
            label: t('Edit source')
        });
        buttonView.bind('isEnabled').to(command);
    } else if (type === 'save') {
        buttonView.set({
            icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].check,
            label: t('Save changes')
        });
        buttonView.bind('isEnabled').to(command);
    } else {
        buttonView.set({
            icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].cancel,
            label: t('Cancel')
        });
    }
    buttonView.on('execute', onClick);
    return buttonView;
}
/**
 * The HTML embed UI plugin.
 */ class HtmlEmbedUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'HtmlEmbedUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const locale = editor.locale;
        const t = locale.t;
        // Add the `htmlEmbed` button to feature components.
        editor.ui.componentFactory.add('htmlEmbed', ()=>{
            const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
            buttonView.set({
                tooltip: true,
                label: t('Insert HTML')
            });
            return buttonView;
        });
        editor.ui.componentFactory.add('menuBar:htmlEmbed', ()=>{
            const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
            buttonView.set({
                label: t('HTML snippet')
            });
            return buttonView;
        });
    }
    /**
	 * Creates a button for html embed command to use either in toolbar or in menu bar.
	 */ _createButton(ButtonClass) {
        const editor = this.editor;
        const command = editor.commands.get('htmlEmbed');
        const view = new ButtonClass(editor.locale);
        view.set({
            icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].html
        });
        view.bind('isEnabled').to(command, 'isEnabled');
        // Execute the command.
        this.listenTo(view, 'execute', ()=>{
            editor.execute('htmlEmbed');
            editor.editing.view.focus();
            const rawHtmlApi = editor.editing.view.document.selection.getSelectedElement().getCustomProperty('rawHtmlApi');
            rawHtmlApi.makeEditable();
        });
        return view;
    }
}
/**
 * The HTML embed feature.
 *
 * It allows inserting HTML snippets directly into the editor.
 *
 * For a detailed overview, check the {@glink features/html/html-embed HTML embed feature} documentation.
 */ class HtmlEmbed extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            HtmlEmbedEditing,
            HtmlEmbedUI,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Widget"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'HtmlEmbed';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-indent/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Indent": (()=>Indent),
    "IndentBlock": (()=>IndentBlock),
    "IndentEditing": (()=>IndentEditing),
    "IndentUI": (()=>IndentUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
;
;
;
;
/**
 * The indent editing feature.
 *
 * This plugin registers the `'indent'` and `'outdent'` commands.
 *
 * **Note**: In order for the commands to work, at least one of the compatible features is required. Read more in the
 * {@link module:indent/indent~Indent indent feature} API documentation.
 */ class IndentEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'IndentEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.commands.add('indent', new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MultiCommand"](editor));
        editor.commands.add('outdent', new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MultiCommand"](editor));
    }
}
/**
 * The indent UI feature.
 *
 * This plugin registers the `'indent'` and `'outdent'` buttons.
 *
 * **Note**: In order for the commands to work, at least one of the compatible features is required. Read more in
 * the {@link module:indent/indent~Indent indent feature} API documentation.
 */ class IndentUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'IndentUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const locale = editor.locale;
        const t = editor.t;
        const localizedIndentIcon = locale.uiLanguageDirection == 'ltr' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].indent : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].outdent;
        const localizedOutdentIcon = locale.uiLanguageDirection == 'ltr' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].outdent : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].indent;
        this._defineButton('indent', t('Increase indent'), localizedIndentIcon);
        this._defineButton('outdent', t('Decrease indent'), localizedOutdentIcon);
    }
    /**
	 * Defines UI buttons for both toolbar and menu bar.
	 */ _defineButton(commandName, label, icon) {
        const editor = this.editor;
        editor.ui.componentFactory.add(commandName, ()=>{
            const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"], commandName, label, icon);
            buttonView.set({
                tooltip: true
            });
            return buttonView;
        });
        editor.ui.componentFactory.add('menuBar:' + commandName, ()=>{
            return this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"], commandName, label, icon);
        });
    }
    /**
	 * Creates a button to use either in toolbar or in menu bar.
	 */ _createButton(ButtonClass, commandName, label, icon) {
        const editor = this.editor;
        const command = editor.commands.get(commandName);
        const view = new ButtonClass(editor.locale);
        view.set({
            label,
            icon
        });
        view.bind('isEnabled').to(command, 'isEnabled');
        // Execute the command.
        this.listenTo(view, 'execute', ()=>{
            editor.execute(commandName);
            editor.editing.view.focus();
        });
        return view;
    }
}
/**
 * The indent feature.
 *
 * This plugin acts as a single entry point plugin for other features that implement indentation of elements like lists or paragraphs.
 *
 * The compatible features are:
 *
 * * The {@link module:list/list~List} or {@link module:list/list/listediting~ListEditing} feature for list indentation.
 * * The {@link module:indent/indentblock~IndentBlock} feature for block indentation.
 *
 * This is a "glue" plugin that loads the following plugins:
 *
 * * The {@link module:indent/indentediting~IndentEditing indent editing feature}.
 * * The {@link module:indent/indentui~IndentUI indent UI feature}.
 *
 * The dependent plugins register the `'indent'` and `'outdent'` commands and introduce the `'indent'` and `'outdent'` buttons
 * that allow to increase or decrease text indentation of supported elements.
 *
 * **Note**: In order for the commands and buttons to work, at least one of compatible features is required.
 */ class Indent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Indent';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            IndentEditing,
            IndentUI
        ];
    }
}
/**
 * The indent block command.
 *
 * The command is registered by the {@link module:indent/indentblock~IndentBlock} as `'indentBlock'` for indenting blocks and
 * `'outdentBlock'` for outdenting blocks.
 *
 * To increase block indentation at the current selection, execute the command:
 *
 * ```ts
 * editor.execute( 'indentBlock' );
 * ```
 *
 * To decrease block indentation at the current selection, execute the command:
 *
 * ```ts
 * editor.execute( 'outdentBlock' );
 * ```
 */ class IndentBlockCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * The command's indentation behavior.
	 */ _indentBehavior;
    /**
	 * Creates an instance of the command.
	 */ constructor(editor, indentBehavior){
        super(editor);
        this._indentBehavior = indentBehavior;
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        const editor = this.editor;
        const model = editor.model;
        const block = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(model.document.selection.getSelectedBlocks());
        if (!block || !this._isIndentationChangeAllowed(block)) {
            this.isEnabled = false;
            return;
        }
        this.isEnabled = this._indentBehavior.checkEnabled(block.getAttribute('blockIndent'));
    }
    /**
	 * @inheritDoc
	 */ execute() {
        const model = this.editor.model;
        const blocksToChange = this._getBlocksToChange();
        model.change((writer)=>{
            for (const block of blocksToChange){
                const currentIndent = block.getAttribute('blockIndent');
                const nextIndent = this._indentBehavior.getNextIndent(currentIndent);
                if (nextIndent) {
                    writer.setAttribute('blockIndent', nextIndent, block);
                } else {
                    writer.removeAttribute('blockIndent', block);
                }
            }
        });
    }
    /**
	 * Returns blocks from selection that should have blockIndent selection set.
	 */ _getBlocksToChange() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const blocksInSelection = Array.from(selection.getSelectedBlocks());
        return blocksInSelection.filter((block)=>this._isIndentationChangeAllowed(block));
    }
    /**
	 * Returns false if indentation cannot be applied, i.e.:
	 * - for blocks disallowed by schema declaration
	 * - for blocks in Document Lists (disallowed forward indentation only). See https://github.com/ckeditor/ckeditor5/issues/14155.
	 * Otherwise returns true.
	 */ _isIndentationChangeAllowed(element) {
        const editor = this.editor;
        if (!editor.model.schema.checkAttribute(element, 'blockIndent')) {
            return false;
        }
        if (!editor.plugins.has('ListUtils')) {
            return true;
        }
        // Only forward indentation is disallowed in list items. This allows the user to outdent blocks that are already indented.
        if (!this._indentBehavior.isForward) {
            return true;
        }
        const documentListUtils = editor.plugins.get('ListUtils');
        return !documentListUtils.isListItemBlock(element);
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module indent/indentcommandbehavior/indentusingoffset
 */ /**
 * The block indentation behavior that uses offsets to set indentation.
 */ class IndentUsingOffset {
    /**
	 * The direction of indentation.
	 */ isForward;
    /**
	 * The offset of the next indentation step.
	 */ offset;
    /**
	 * Indentation unit.
	 */ unit;
    /**
	 * Creates an instance of the indentation behavior.
	 *
	 * @param config.direction The direction of indentation.
	 * @param config.offset The offset of the next indentation step.
	 * @param config.unit Indentation unit.
	 */ constructor(config){
        this.isForward = config.direction === 'forward';
        this.offset = config.offset;
        this.unit = config.unit;
    }
    /**
	 * @inheritDoc
	 */ checkEnabled(indentAttributeValue) {
        const currentOffset = parseFloat(indentAttributeValue || '0');
        // The command is always enabled for forward indentation.
        return this.isForward || currentOffset > 0;
    }
    /**
	 * @inheritDoc
	 */ getNextIndent(indentAttributeValue) {
        const currentOffset = parseFloat(indentAttributeValue || '0');
        const isSameUnit = !indentAttributeValue || indentAttributeValue.endsWith(this.unit);
        if (!isSameUnit) {
            return this.isForward ? this.offset + this.unit : undefined;
        }
        const nextOffset = this.isForward ? this.offset : -this.offset;
        const offsetToSet = currentOffset + nextOffset;
        return offsetToSet > 0 ? offsetToSet + this.unit : undefined;
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module indent/indentcommandbehavior/indentusingclasses
 */ /**
 * The block indentation behavior that uses classes to set indentation.
 */ class IndentUsingClasses {
    /**
	 * The direction of indentation.
	 */ isForward;
    /**
	 * A list of classes used for indentation.
	 */ classes;
    /**
	 * Creates an instance of the indentation behavior.
	 *
	 * @param config.direction The direction of indentation.
	 * @param config.classes A list of classes used for indentation.
	 */ constructor(config){
        this.isForward = config.direction === 'forward';
        this.classes = config.classes;
    }
    /**
	 * @inheritDoc
	 */ checkEnabled(indentAttributeValue) {
        const currentIndex = this.classes.indexOf(indentAttributeValue);
        if (this.isForward) {
            return currentIndex < this.classes.length - 1;
        } else {
            return currentIndex >= 0;
        }
    }
    /**
	 * @inheritDoc
	 */ getNextIndent(indentAttributeValue) {
        const currentIndex = this.classes.indexOf(indentAttributeValue);
        const indexStep = this.isForward ? 1 : -1;
        return this.classes[currentIndex + indexStep];
    }
}
const DEFAULT_ELEMENTS = [
    'paragraph',
    'heading1',
    'heading2',
    'heading3',
    'heading4',
    'heading5',
    'heading6'
];
/**
 * The block indentation feature.
 *
 * It registers the `'indentBlock'` and `'outdentBlock'` commands.
 *
 * If the plugin {@link module:indent/indent~Indent} is defined, it also attaches the `'indentBlock'` and `'outdentBlock'` commands to
 * the `'indent'` and `'outdent'` commands.
 */ class IndentBlock extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('indentBlock', {
            offset: 40,
            unit: 'px'
        });
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'IndentBlock';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const configuration = editor.config.get('indentBlock');
        if (configuration.classes && configuration.classes.length) {
            this._setupConversionUsingClasses(configuration.classes);
            editor.commands.add('indentBlock', new IndentBlockCommand(editor, new IndentUsingClasses({
                direction: 'forward',
                classes: configuration.classes
            })));
            editor.commands.add('outdentBlock', new IndentBlockCommand(editor, new IndentUsingClasses({
                direction: 'backward',
                classes: configuration.classes
            })));
        } else {
            editor.data.addStyleProcessorRules(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addMarginRules"]);
            this._setupConversionUsingOffset();
            editor.commands.add('indentBlock', new IndentBlockCommand(editor, new IndentUsingOffset({
                direction: 'forward',
                offset: configuration.offset,
                unit: configuration.unit
            })));
            editor.commands.add('outdentBlock', new IndentBlockCommand(editor, new IndentUsingOffset({
                direction: 'backward',
                offset: configuration.offset,
                unit: configuration.unit
            })));
        }
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        const editor = this.editor;
        const schema = editor.model.schema;
        const indentCommand = editor.commands.get('indent');
        const outdentCommand = editor.commands.get('outdent');
        // Enable block indentation to heading configuration options. If it is not defined enable in paragraph and default headings.
        const options = editor.config.get('heading.options');
        const configuredElements = options && options.map((option)=>option.model);
        const knownElements = configuredElements || DEFAULT_ELEMENTS;
        knownElements.forEach((elementName)=>{
            if (schema.isRegistered(elementName)) {
                schema.extend(elementName, {
                    allowAttributes: 'blockIndent'
                });
            }
        });
        schema.setAttributeProperties('blockIndent', {
            isFormatting: true
        });
        indentCommand.registerChildCommand(editor.commands.get('indentBlock'));
        outdentCommand.registerChildCommand(editor.commands.get('outdentBlock'));
    }
    /**
	 * Setups conversion for using offset indents.
	 */ _setupConversionUsingOffset() {
        const conversion = this.editor.conversion;
        const locale = this.editor.locale;
        const marginProperty = locale.contentLanguageDirection === 'rtl' ? 'margin-right' : 'margin-left';
        conversion.for('upcast').attributeToAttribute({
            view: {
                styles: {
                    [marginProperty]: /[\s\S]+/
                }
            },
            model: {
                key: 'blockIndent',
                value: (viewElement)=>{
                    // Do not indent block elements in Document Lists. See https://github.com/ckeditor/ckeditor5/issues/12466.
                    if (!viewElement.is('element', 'li')) {
                        return viewElement.getStyle(marginProperty);
                    }
                }
            }
        });
        conversion.for('downcast').attributeToAttribute({
            model: 'blockIndent',
            view: (modelAttributeValue)=>{
                return {
                    key: 'style',
                    value: {
                        [marginProperty]: modelAttributeValue
                    }
                };
            }
        });
    }
    /**
	 * Setups conversion for using classes.
	 */ _setupConversionUsingClasses(classes) {
        const definition = {
            model: {
                key: 'blockIndent',
                values: []
            },
            view: {}
        };
        for (const className of classes){
            definition.model.values.push(className);
            definition.view[className] = {
                key: 'class',
                value: [
                    className
                ]
            };
        }
        this.editor.conversion.attributeToAttribute(definition);
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-language/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "TextPartLanguage": (()=>TextPartLanguage),
    "TextPartLanguageEditing": (()=>TextPartLanguageEditing),
    "TextPartLanguageUI": (()=>TextPartLanguageUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
;
;
;
/**
 * Returns the language attribute value in a human-readable text format:
 *
 * ```
 * <languageCode>:<textDirection>
 * ```
 *
 * * `languageCode` - The language code used for the `lang` attribute in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
 * * `textDirection` - One of the following values: `rtl` or `ltr`, indicating the reading direction of the language.
 *
 * See the {@link module:core/editor/editorconfig~LanguageConfig#textPartLanguage text part language configuration}
 * for more information about language properties.
 *
 * If the `textDirection` argument is omitted, it will be automatically detected based on `languageCode`.
 *
 * @param languageCode The language code in the ISO 639-1 format.
 * @param textDirection The language text direction. Automatically detected if omitted.
 */ function stringifyLanguageAttribute(languageCode, textDirection) {
    textDirection = textDirection || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLanguageDirection"])(languageCode);
    return `${languageCode}:${textDirection}`;
}
/**
 * Retrieves language properties converted to attribute value by the
 * {@link module:language/utils~stringifyLanguageAttribute stringifyLanguageAttribute} function.
 *
 * @param str The attribute value.
 * @returns The object with properties:
 * * languageCode - The language code in the ISO 639 format.
 * * textDirection - The language text direction.
 */ function parseLanguageAttribute(str) {
    const [languageCode, textDirection] = str.split(':');
    return {
        languageCode,
        textDirection
    };
}
/**
 * The text part language command plugin.
 */ class TextPartLanguageCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const doc = model.document;
        this.value = this._getValueFromFirstAllowedNode();
        this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, 'language');
    }
    /**
	 * Executes the command. Applies the attribute to the selection or removes it from the selection.
	 *
	 * If `languageCode` is set to `false` or a `null` value, it will remove attributes. Otherwise, it will set
	 * the attribute in the `{@link #value value}` format.
	 *
	 * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:
	 *
	 * * If the selection is on a range, the command applies the attribute to all nodes in that range
	 * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).
	 * * If the selection is collapsed in a non-empty node, the command applies the attribute to the
	 * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).
	 * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note
	 * that the selection inherits all attributes from a node if it is in an empty node).
	 *
	 * @fires execute
	 * @param options Command options.
	 * @param options.languageCode The language code to be applied to the model.
	 * @param options.textDirection The language text direction.
	 */ execute({ languageCode, textDirection } = {}) {
        const model = this.editor.model;
        const doc = model.document;
        const selection = doc.selection;
        const value = languageCode ? stringifyLanguageAttribute(languageCode, textDirection) : false;
        model.change((writer)=>{
            if (selection.isCollapsed) {
                if (value) {
                    writer.setSelectionAttribute('language', value);
                } else {
                    writer.removeSelectionAttribute('language');
                }
            } else {
                const ranges = model.schema.getValidRanges(selection.getRanges(), 'language');
                for (const range of ranges){
                    if (value) {
                        writer.setAttribute('language', value, range);
                    } else {
                        writer.removeAttribute('language', range);
                    }
                }
            }
        });
    }
    /**
	 * Returns the attribute value of the first node in the selection that allows the attribute.
	 * For a collapsed selection it returns the selection attribute.
	 *
	 * @returns The attribute value.
	 */ _getValueFromFirstAllowedNode() {
        const model = this.editor.model;
        const schema = model.schema;
        const selection = model.document.selection;
        if (selection.isCollapsed) {
            return selection.getAttribute('language') || false;
        }
        for (const range of selection.getRanges()){
            for (const item of range.getItems()){
                if (schema.checkAttribute(item, 'language')) {
                    return item.getAttribute('language') || false;
                }
            }
        }
        return false;
    }
}
/**
 * The text part language editing.
 *
 * Introduces the `'textPartLanguage'` command and the `'language'` model element attribute.
 */ class TextPartLanguageEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'TextPartLanguageEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        // Text part language options are only used to ensure that the feature works by default.
        // In the real usage it should be reconfigured by a developer. We are not providing
        // translations for `title` properties on purpose, as it's only an example configuration.
        editor.config.define('language', {
            textPartLanguage: [
                {
                    title: 'Arabic',
                    languageCode: 'ar'
                },
                {
                    title: 'French',
                    languageCode: 'fr'
                },
                {
                    title: 'Spanish',
                    languageCode: 'es'
                }
            ]
        });
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.model.schema.extend('$text', {
            allowAttributes: 'language'
        });
        editor.model.schema.setAttributeProperties('language', {
            copyOnEnter: true
        });
        this._defineConverters();
        editor.commands.add('textPartLanguage', new TextPartLanguageCommand(editor));
    }
    /**
	 * @private
	 */ _defineConverters() {
        const conversion = this.editor.conversion;
        conversion.for('upcast').elementToAttribute({
            model: {
                key: 'language',
                value: (viewElement)=>{
                    const languageCode = viewElement.getAttribute('lang');
                    const textDirection = viewElement.getAttribute('dir');
                    return stringifyLanguageAttribute(languageCode, textDirection);
                }
            },
            view: {
                name: 'span',
                attributes: {
                    lang: /[\s\S]+/
                }
            }
        });
        conversion.for('downcast').attributeToElement({
            model: 'language',
            view: (attributeValue, { writer }, data)=>{
                if (!attributeValue) {
                    return;
                }
                if (!data.item.is('$textProxy') && !data.item.is('documentSelection')) {
                    return;
                }
                const { languageCode, textDirection } = parseLanguageAttribute(attributeValue);
                return writer.createAttributeElement('span', {
                    lang: languageCode,
                    dir: textDirection
                });
            }
        });
    }
}
/**
 * The text part language UI plugin.
 *
 * It introduces the `'language'` dropdown.
 */ class TextPartLanguageUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'TextPartLanguageUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        const defaultTitle = t('Choose language');
        const accessibleLabel = t('Language');
        // Register UI component.
        editor.ui.componentFactory.add('textPartLanguage', (locale)=>{
            const { definitions, titles } = this._getItemMetadata();
            const languageCommand = editor.commands.get('textPartLanguage');
            const dropdownView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDropdown"])(locale);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addListToDropdown"])(dropdownView, definitions, {
                ariaLabel: accessibleLabel,
                role: 'menu'
            });
            dropdownView.buttonView.set({
                ariaLabel: accessibleLabel,
                ariaLabelledBy: undefined,
                isOn: false,
                withText: true,
                tooltip: accessibleLabel
            });
            dropdownView.extendTemplate({
                attributes: {
                    class: [
                        'ck-text-fragment-language-dropdown'
                    ]
                }
            });
            dropdownView.bind('isEnabled').to(languageCommand, 'isEnabled');
            dropdownView.buttonView.bind('label').to(languageCommand, 'value', (value)=>{
                return value && titles[value] || defaultTitle;
            });
            dropdownView.buttonView.bind('ariaLabel').to(languageCommand, 'value', (value)=>{
                const selectedLanguageTitle = value && titles[value];
                if (!selectedLanguageTitle) {
                    return accessibleLabel;
                }
                return `${selectedLanguageTitle}, ${accessibleLabel}`;
            });
            // Execute command when an item from the dropdown is selected.
            this.listenTo(dropdownView, 'execute', (evt)=>{
                languageCommand.execute({
                    languageCode: evt.source.languageCode,
                    textDirection: evt.source.textDirection
                });
                editor.editing.view.focus();
            });
            return dropdownView;
        });
        // Register menu bar UI component.
        editor.ui.componentFactory.add('menuBar:textPartLanguage', (locale)=>{
            const { definitions } = this._getItemMetadata();
            const languageCommand = editor.commands.get('textPartLanguage');
            const menuView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuView"](locale);
            menuView.buttonView.set({
                label: accessibleLabel
            });
            const listView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListView"](locale);
            listView.set({
                ariaLabel: t('Language'),
                role: 'menu'
            });
            for (const definition of definitions){
                if (definition.type != 'button') {
                    listView.items.add(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ListSeparatorView"](locale));
                    continue;
                }
                const listItemView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemView"](locale, menuView);
                const buttonView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"](locale);
                buttonView.set({
                    role: 'menuitemradio',
                    isToggleable: true
                });
                buttonView.bind(...Object.keys(definition.model)).to(definition.model);
                buttonView.delegate('execute').to(menuView);
                listItemView.children.add(buttonView);
                listView.items.add(listItemView);
            }
            menuView.bind('isEnabled').to(languageCommand, 'isEnabled');
            menuView.panelView.children.add(listView);
            menuView.on('execute', (evt)=>{
                languageCommand.execute({
                    languageCode: evt.source.languageCode,
                    textDirection: evt.source.textDirection
                });
                editor.editing.view.focus();
            });
            return menuView;
        });
    }
    /**
	 * Returns metadata for dropdown and menu items.
	 */ _getItemMetadata() {
        const editor = this.editor;
        const itemDefinitions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"]();
        const titles = {};
        const languageCommand = editor.commands.get('textPartLanguage');
        const options = editor.config.get('language.textPartLanguage');
        const t = editor.locale.t;
        const removeTitle = t('Remove language');
        // Item definition with false `languageCode` will behave as remove lang button.
        itemDefinitions.add({
            type: 'button',
            model: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewModel"]({
                label: removeTitle,
                languageCode: false,
                withText: true
            })
        });
        itemDefinitions.add({
            type: 'separator'
        });
        for (const option of options){
            const def = {
                type: 'button',
                model: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewModel"]({
                    label: option.title,
                    languageCode: option.languageCode,
                    role: 'menuitemradio',
                    textDirection: option.textDirection,
                    withText: true
                })
            };
            const language = stringifyLanguageAttribute(option.languageCode, option.textDirection);
            def.model.bind('isOn').to(languageCommand, 'value', (value)=>value === language);
            itemDefinitions.add(def);
            titles[language] = option.title;
        }
        return {
            definitions: itemDefinitions,
            titles
        };
    }
}
/**
 * The text part language feature.
 *
 * This feature allows setting a language of the document's text part to support
 * [WCAG 3.1.2 Language of Parts](https://www.w3.org/TR/UNDERSTANDING-WCAG20/meaning-other-lang-id.html) specification.
 *
 * To change the editor's UI language, refer to the {@glink getting-started/setup/ui-language Setting the UI language} guide.
 *
 * For more information about this feature, check the {@glink api/language package page} as well as the {@glink features/language
 * Text part language} feature guide.
 *
 * This is a "glue" plugin which loads the
 * {@link module:language/textpartlanguageediting~TextPartLanguageEditing text part language editing feature}
 * and the {@link module:language/textpartlanguageui~TextPartLanguageUI text part language UI feature}.
 */ class TextPartLanguage extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            TextPartLanguageEditing,
            TextPartLanguageUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'TextPartLanguage';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-link/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "AutoLink": (()=>AutoLink),
    "Link": (()=>Link),
    "LinkActionsView": (()=>LinkActionsView),
    "LinkCommand": (()=>LinkCommand),
    "LinkEditing": (()=>LinkEditing),
    "LinkFormView": (()=>LinkFormView),
    "LinkImage": (()=>LinkImage),
    "LinkImageEditing": (()=>LinkImageEditing),
    "LinkImageUI": (()=>LinkImageUI),
    "LinkUI": (()=>LinkUI),
    "UnlinkCommand": (()=>UnlinkCommand),
    "addLinkProtocolIfApplicable": (()=>addLinkProtocolIfApplicable),
    "ensureSafeUrl": (()=>ensureSafeUrl),
    "isLinkableElement": (()=>isLinkableElement)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-typing/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$clipboard$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-clipboard/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-widget/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$upperFirst$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/upperFirst.js [app-client] (ecmascript) <export default as upperFirst>");
;
;
;
;
;
;
;
;
/**
 * Helper class that ties together all {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition} and provides
 * the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement downcast dispatchers} for them.
 */ class AutomaticDecorators {
    /**
	 * Stores the definition of {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators}.
	 * This data is used as a source for a downcast dispatcher to create a proper conversion to output data.
	 */ _definitions = new Set();
    /**
	 * Gives information about the number of decorators stored in the {@link module:link/utils/automaticdecorators~AutomaticDecorators}
	 * instance.
	 */ get length() {
        return this._definitions.size;
    }
    /**
	 * Adds automatic decorator objects or an array with them to be used during downcasting.
	 *
	 * @param item A configuration object of automatic rules for decorating links. It might also be an array of such objects.
	 */ add(item) {
        if (Array.isArray(item)) {
            item.forEach((item)=>this._definitions.add(item));
        } else {
            this._definitions.add(item);
        }
    }
    /**
	 * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method.
	 *
	 * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
	 */ getDispatcher() {
        return (dispatcher)=>{
            dispatcher.on('attribute:linkHref', (evt, data, conversionApi)=>{
                // There is only test as this behavior decorates links and
                // it is run before dispatcher which actually consumes this node.
                // This allows on writing own dispatcher with highest priority,
                // which blocks both native converter and this additional decoration.
                if (!conversionApi.consumable.test(data.item, 'attribute:linkHref')) {
                    return;
                }
                // Automatic decorators for block links are handled e.g. in LinkImageEditing.
                if (!(data.item.is('selection') || conversionApi.schema.isInline(data.item))) {
                    return;
                }
                const viewWriter = conversionApi.writer;
                const viewSelection = viewWriter.document.selection;
                for (const item of this._definitions){
                    const viewElement = viewWriter.createAttributeElement('a', item.attributes, {
                        priority: 5
                    });
                    if (item.classes) {
                        viewWriter.addClass(item.classes, viewElement);
                    }
                    for(const key in item.styles){
                        viewWriter.setStyle(key, item.styles[key], viewElement);
                    }
                    viewWriter.setCustomProperty('link', true, viewElement);
                    if (item.callback(data.attributeNewValue)) {
                        if (data.item.is('selection')) {
                            viewWriter.wrap(viewSelection.getFirstRange(), viewElement);
                        } else {
                            viewWriter.wrap(conversionApi.mapper.toViewRange(data.range), viewElement);
                        }
                    } else {
                        viewWriter.unwrap(conversionApi.mapper.toViewRange(data.range), viewElement);
                    }
                }
            }, {
                priority: 'high'
            });
        };
    }
    /**
	 * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method
	 * when linking images.
	 *
	 * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
	 */ getDispatcherForLinkedImage() {
        return (dispatcher)=>{
            dispatcher.on('attribute:linkHref:imageBlock', (evt, data, { writer, mapper })=>{
                const viewFigure = mapper.toViewElement(data.item);
                const linkInImage = Array.from(viewFigure.getChildren()).find((child)=>child.is('element', 'a'));
                // It's not guaranteed that the anchor is present in the image block during execution of this dispatcher.
                // It might have been removed during the execution of unlink command that runs the image link downcast dispatcher
                // that is executed before this one and removes the anchor from the image block.
                if (!linkInImage) {
                    return;
                }
                for (const item of this._definitions){
                    const attributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toMap"])(item.attributes);
                    if (item.callback(data.attributeNewValue)) {
                        for (const [key, val] of attributes){
                            // Left for backward compatibility. Since v30 decorator should
                            // accept `classes` and `styles` separately from `attributes`.
                            if (key === 'class') {
                                writer.addClass(val, linkInImage);
                            } else {
                                writer.setAttribute(key, val, linkInImage);
                            }
                        }
                        if (item.classes) {
                            writer.addClass(item.classes, linkInImage);
                        }
                        for(const key in item.styles){
                            writer.setStyle(key, item.styles[key], linkInImage);
                        }
                    } else {
                        for (const [key, val] of attributes){
                            if (key === 'class') {
                                writer.removeClass(val, linkInImage);
                            } else {
                                writer.removeAttribute(key, linkInImage);
                            }
                        }
                        if (item.classes) {
                            writer.removeClass(item.classes, linkInImage);
                        }
                        for(const key in item.styles){
                            writer.removeStyle(key, linkInImage);
                        }
                    }
                }
            });
        };
    }
}
const ATTRIBUTE_WHITESPACES = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g; // eslint-disable-line no-control-regex
const SAFE_URL_TEMPLATE = '^(?:(?:<protocols>):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))';
// Simplified email test - should be run over previously found URL.
const EMAIL_REG_EXP = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i;
// The regex checks for the protocol syntax ('xxxx://' or 'xxxx:')
// or non-word characters at the beginning of the link ('/', '#' etc.).
const PROTOCOL_REG_EXP = /^((\w+:(\/{2,})?)|(\W))/i;
const DEFAULT_LINK_PROTOCOLS = [
    'https?',
    'ftps?',
    'mailto'
];
/**
 * A keystroke used by the {@link module:link/linkui~LinkUI link UI feature}.
 */ const LINK_KEYSTROKE = 'Ctrl+K';
/**
 * Returns `true` if a given view node is the link element.
 */ function isLinkElement(node) {
    return node.is('attributeElement') && !!node.getCustomProperty('link');
}
/**
 * Creates a link {@link module:engine/view/attributeelement~AttributeElement} with the provided `href` attribute.
 */ function createLinkElement(href, { writer }) {
    // Priority 5 - https://github.com/ckeditor/ckeditor5-link/issues/121.
    const linkElement = writer.createAttributeElement('a', {
        href
    }, {
        priority: 5
    });
    writer.setCustomProperty('link', true, linkElement);
    return linkElement;
}
/**
 * Returns a safe URL based on a given value.
 *
 * A URL is considered safe if it is safe for the user (does not contain any malicious code).
 *
 * If a URL is considered unsafe, a simple `"#"` is returned.
 *
 * @internal
 */ function ensureSafeUrl(url, allowedProtocols = DEFAULT_LINK_PROTOCOLS) {
    const urlString = String(url);
    const protocolsList = allowedProtocols.join('|');
    const customSafeRegex = new RegExp(`${SAFE_URL_TEMPLATE.replace('<protocols>', protocolsList)}`, 'i');
    return isSafeUrl(urlString, customSafeRegex) ? urlString : '#';
}
/**
 * Checks whether the given URL is safe for the user (does not contain any malicious code).
 */ function isSafeUrl(url, customRegexp) {
    const normalizedUrl = url.replace(ATTRIBUTE_WHITESPACES, '');
    return !!normalizedUrl.match(customRegexp);
}
/**
 * Returns the {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`} configuration processed
 * to respect the locale of the editor, i.e. to display the {@link module:link/linkconfig~LinkDecoratorManualDefinition label}
 * in the correct language.
 *
 * **Note**: Only the few most commonly used labels are translated automatically. Other labels should be manually
 * translated in the {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`} configuration.
 *
 * @param t Shorthand for {@link module:utils/locale~Locale#t Locale#t}.
 * @param decorators The decorator reference where the label values should be localized.
 */ function getLocalizedDecorators(t, decorators) {
    const localizedDecoratorsLabels = {
        'Open in a new tab': t('Open in a new tab'),
        'Downloadable': t('Downloadable')
    };
    decorators.forEach((decorator)=>{
        if ('label' in decorator && localizedDecoratorsLabels[decorator.label]) {
            decorator.label = localizedDecoratorsLabels[decorator.label];
        }
        return decorator;
    });
    return decorators;
}
/**
 * Converts an object with defined decorators to a normalized array of decorators. The `id` key is added for each decorator and
 * is used as the attribute's name in the model.
 */ function normalizeDecorators(decorators) {
    const retArray = [];
    if (decorators) {
        for (const [key, value] of Object.entries(decorators)){
            const decorator = Object.assign({}, value, {
                id: `link${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$upperFirst$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__["upperFirst"])(key)}`
            });
            retArray.push(decorator);
        }
    }
    return retArray;
}
/**
 * Returns `true` if the specified `element` can be linked (the element allows the `linkHref` attribute).
 */ function isLinkableElement(element, schema) {
    if (!element) {
        return false;
    }
    return schema.checkAttribute(element.name, 'linkHref');
}
/**
 * Returns `true` if the specified `value` is an email.
 */ function isEmail(value) {
    return EMAIL_REG_EXP.test(value);
}
/**
 * Adds the protocol prefix to the specified `link` when:
 *
 * * it does not contain it already, and there is a {@link module:link/linkconfig~LinkConfig#defaultProtocol `defaultProtocol` }
 * configuration value provided,
 * * or the link is an email address.
 */ function addLinkProtocolIfApplicable(link, defaultProtocol) {
    const protocol = isEmail(link) ? 'mailto:' : defaultProtocol;
    const isProtocolNeeded = !!protocol && !linkHasProtocol(link);
    return link && isProtocolNeeded ? protocol + link : link;
}
/**
 * Checks if protocol is already included in the link.
 */ function linkHasProtocol(link) {
    return PROTOCOL_REG_EXP.test(link);
}
/**
 * Opens the link in a new browser tab.
 */ function openLink(link) {
    window.open(link, '_blank', 'noopener');
}
/**
 * Creates the bookmark callbacks for handling link opening experience.
 */ function createBookmarkCallbacks(editor) {
    const bookmarkEditing = editor.plugins.has('BookmarkEditing') ? editor.plugins.get('BookmarkEditing') : null;
    /**
	 * Returns `true` when bookmark `id` matches the hash from `link`.
	 */ function isScrollableToTarget(link) {
        return !!link && link.startsWith('#') && !!bookmarkEditing && !!bookmarkEditing.getElementForBookmarkId(link.slice(1));
    }
    /**
	 * Scrolls the view to the desired bookmark or open a link in new window.
	 */ function scrollToTarget(link) {
        const bookmarkId = link.slice(1);
        const modelBookmark = bookmarkEditing.getElementForBookmarkId(bookmarkId);
        editor.model.change((writer)=>{
            writer.setSelection(modelBookmark, 'on');
        });
        editor.editing.view.scrollToTheSelection({
            alignToTop: true,
            forceScroll: true
        });
    }
    return {
        isScrollableToTarget,
        scrollToTarget
    };
}
/**
 * The link command. It is used by the {@link module:link/link~Link link feature}.
 */ class LinkCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * A collection of {@link module:link/utils/manualdecorator~ManualDecorator manual decorators}
	 * corresponding to the {@link module:link/linkconfig~LinkConfig#decorators decorator configuration}.
	 *
	 * You can consider it a model with states of manual decorators added to the currently selected link.
	 */ manualDecorators = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"]();
    /**
	 * An instance of the helper that ties together all {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition}
	 * that are used by the {@glink features/link link} and the {@glink features/images/images-linking linking images} features.
	 */ automaticDecorators = new AutomaticDecorators();
    /**
	 * Synchronizes the state of {@link #manualDecorators} with the currently present elements in the model.
	 */ restoreManualDecoratorStates() {
        for (const manualDecorator of this.manualDecorators){
            manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);
        }
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedElement = selection.getSelectedElement() || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(selection.getSelectedBlocks());
        // A check for any integration that allows linking elements (e.g. `LinkImage`).
        // Currently the selection reads attributes from text nodes only. See #7429 and #7465.
        if (isLinkableElement(selectedElement, model.schema)) {
            this.value = selectedElement.getAttribute('linkHref');
            this.isEnabled = model.schema.checkAttribute(selectedElement, 'linkHref');
        } else {
            this.value = selection.getAttribute('linkHref');
            this.isEnabled = model.schema.checkAttributeInSelection(selection, 'linkHref');
        }
        for (const manualDecorator of this.manualDecorators){
            manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);
        }
    }
    /**
	 * Executes the command.
	 *
	 * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to
	 * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).
	 *
	 * When the selection is collapsed and is not inside the text with the `linkHref` attribute, a
	 * new {@link module:engine/model/text~Text text node} with the `linkHref` attribute will be inserted in place of the caret, but
	 * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.
	 * The selection will be updated to wrap the just inserted text node.
	 *
	 * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.
	 *
	 * # Decorators and model attribute management
	 *
	 * There is an optional argument to this command that applies or removes model
	 * {@glink framework/architecture/editing-engine#text-attributes text attributes} brought by
	 * {@link module:link/utils/manualdecorator~ManualDecorator manual link decorators}.
	 *
	 * Text attribute names in the model correspond to the entries in the {@link module:link/linkconfig~LinkConfig#decorators
	 * configuration}.
	 * For every decorator configured, a model text attribute exists with the "link" prefix. For example, a `'linkMyDecorator'` attribute
	 * corresponds to `'myDecorator'` in the configuration.
	 *
	 * To learn more about link decorators, check out the {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`}
	 * documentation.
	 *
	 * Here is how to manage decorator attributes with the link command:
	 *
	 * ```ts
	 * const linkCommand = editor.commands.get( 'link' );
	 *
	 * // Adding a new decorator attribute.
	 * linkCommand.execute( 'http://example.com', {
	 * 	linkIsExternal: true
	 * } );
	 *
	 * // Removing a decorator attribute from the selection.
	 * linkCommand.execute( 'http://example.com', {
	 * 	linkIsExternal: false
	 * } );
	 *
	 * // Adding multiple decorator attributes at the same time.
	 * linkCommand.execute( 'http://example.com', {
	 * 	linkIsExternal: true,
	 * 	linkIsDownloadable: true,
	 * } );
	 *
	 * // Removing and adding decorator attributes at the same time.
	 * linkCommand.execute( 'http://example.com', {
	 * 	linkIsExternal: false,
	 * 	linkFoo: true,
	 * 	linkIsDownloadable: false,
	 * } );
	 * ```
	 *
	 * **Note**: If the decorator attribute name is not specified, its state remains untouched.
	 *
	 * **Note**: {@link module:link/unlinkcommand~UnlinkCommand#execute `UnlinkCommand#execute()`} removes all
	 * decorator attributes.
	 *
	 * @fires execute
	 * @param href Link destination.
	 * @param manualDecoratorIds The information about manual decorator attributes to be applied or removed upon execution.
	 */ execute(href, manualDecoratorIds = {}) {
        const model = this.editor.model;
        const selection = model.document.selection;
        // Stores information about manual decorators to turn them on/off when command is applied.
        const truthyManualDecorators = [];
        const falsyManualDecorators = [];
        for(const name in manualDecoratorIds){
            if (manualDecoratorIds[name]) {
                truthyManualDecorators.push(name);
            } else {
                falsyManualDecorators.push(name);
            }
        }
        model.change((writer)=>{
            // If selection is collapsed then update selected link or insert new one at the place of caret.
            if (selection.isCollapsed) {
                const position = selection.getFirstPosition();
                // When selection is inside text with `linkHref` attribute.
                if (selection.hasAttribute('linkHref')) {
                    const linkText = extractTextFromSelection(selection);
                    // Then update `linkHref` value.
                    let linkRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findAttributeRange"])(position, 'linkHref', selection.getAttribute('linkHref'), model);
                    if (selection.getAttribute('linkHref') === linkText) {
                        linkRange = this._updateLinkContent(model, writer, linkRange, href);
                    }
                    writer.setAttribute('linkHref', href, linkRange);
                    truthyManualDecorators.forEach((item)=>{
                        writer.setAttribute(item, true, linkRange);
                    });
                    falsyManualDecorators.forEach((item)=>{
                        writer.removeAttribute(item, linkRange);
                    });
                    // Put the selection at the end of the updated link.
                    writer.setSelection(writer.createPositionAfter(linkRange.end.nodeBefore));
                } else if (href !== '') {
                    const attributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toMap"])(selection.getAttributes());
                    attributes.set('linkHref', href);
                    truthyManualDecorators.forEach((item)=>{
                        attributes.set(item, true);
                    });
                    const { end: positionAfter } = model.insertContent(writer.createText(href, attributes), position);
                    // Put the selection at the end of the inserted link.
                    // Using end of range returned from insertContent in case nodes with the same attributes got merged.
                    writer.setSelection(positionAfter);
                }
                // Remove the `linkHref` attribute and all link decorators from the selection.
                // It stops adding a new content into the link element.
                [
                    'linkHref',
                    ...truthyManualDecorators,
                    ...falsyManualDecorators
                ].forEach((item)=>{
                    writer.removeSelectionAttribute(item);
                });
            } else {
                // If selection has non-collapsed ranges, we change attribute on nodes inside those ranges
                // omitting nodes where the `linkHref` attribute is disallowed.
                const ranges = model.schema.getValidRanges(selection.getRanges(), 'linkHref');
                // But for the first, check whether the `linkHref` attribute is allowed on selected blocks (e.g. the "image" element).
                const allowedRanges = [];
                for (const element of selection.getSelectedBlocks()){
                    if (model.schema.checkAttribute(element, 'linkHref')) {
                        allowedRanges.push(writer.createRangeOn(element));
                    }
                }
                // Ranges that accept the `linkHref` attribute. Since we will iterate over `allowedRanges`, let's clone it.
                const rangesToUpdate = allowedRanges.slice();
                // For all selection ranges we want to check whether given range is inside an element that accepts the `linkHref` attribute.
                // If so, we don't want to propagate applying the attribute to its children.
                for (const range of ranges){
                    if (this._isRangeToUpdate(range, allowedRanges)) {
                        rangesToUpdate.push(range);
                    }
                }
                for (const range of rangesToUpdate){
                    let linkRange = range;
                    if (rangesToUpdate.length === 1) {
                        // Current text of the link in the document.
                        const linkText = extractTextFromSelection(selection);
                        if (selection.getAttribute('linkHref') === linkText) {
                            linkRange = this._updateLinkContent(model, writer, range, href);
                            writer.setSelection(writer.createSelection(linkRange));
                        }
                    }
                    writer.setAttribute('linkHref', href, linkRange);
                    truthyManualDecorators.forEach((item)=>{
                        writer.setAttribute(item, true, linkRange);
                    });
                    falsyManualDecorators.forEach((item)=>{
                        writer.removeAttribute(item, linkRange);
                    });
                }
            }
        });
    }
    /**
	 * Provides information whether a decorator with a given name is present in the currently processed selection.
	 *
	 * @param decoratorName The name of the manual decorator used in the model
	 * @returns The information whether a given decorator is currently present in the selection.
	 */ _getDecoratorStateFromModel(decoratorName) {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedElement = selection.getSelectedElement();
        // A check for the `LinkImage` plugin. If the selection contains an element, get values from the element.
        // Currently the selection reads attributes from text nodes only. See #7429 and #7465.
        if (isLinkableElement(selectedElement, model.schema)) {
            return selectedElement.getAttribute(decoratorName);
        }
        return selection.getAttribute(decoratorName);
    }
    /**
	 * Checks whether specified `range` is inside an element that accepts the `linkHref` attribute.
	 *
	 * @param range A range to check.
	 * @param allowedRanges An array of ranges created on elements where the attribute is accepted.
	 */ _isRangeToUpdate(range, allowedRanges) {
        for (const allowedRange of allowedRanges){
            // A range is inside an element that will have the `linkHref` attribute. Do not modify its nodes.
            if (allowedRange.containsRange(range)) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Updates selected link with a new value as its content and as its href attribute.
	 *
	 * @param model Model is need to insert content.
	 * @param writer Writer is need to create text element in model.
	 * @param range A range where should be inserted content.
	 * @param href A link value which should be in the href attribute and in the content.
	 */ _updateLinkContent(model, writer, range, href) {
        const text = writer.createText(href, {
            linkHref: href
        });
        return model.insertContent(text, range);
    }
}
// Returns a text of a link under the collapsed selection or a selection that contains the entire link.
function extractTextFromSelection(selection) {
    if (selection.isCollapsed) {
        const firstPosition = selection.getFirstPosition();
        return firstPosition.textNode && firstPosition.textNode.data;
    } else {
        const rangeItems = Array.from(selection.getFirstRange().getItems());
        if (rangeItems.length > 1) {
            return null;
        }
        const firstNode = rangeItems[0];
        if (firstNode.is('$text') || firstNode.is('$textProxy')) {
            return firstNode.data;
        }
        return null;
    }
}
/**
 * The unlink command. It is used by the {@link module:link/link~Link link plugin}.
 */ class UnlinkCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedElement = selection.getSelectedElement();
        // A check for any integration that allows linking elements (e.g. `LinkImage`).
        // Currently the selection reads attributes from text nodes only. See #7429 and #7465.
        if (isLinkableElement(selectedElement, model.schema)) {
            this.isEnabled = model.schema.checkAttribute(selectedElement, 'linkHref');
        } else {
            this.isEnabled = model.schema.checkAttributeInSelection(selection, 'linkHref');
        }
    }
    /**
	 * Executes the command.
	 *
	 * When the selection is collapsed, it removes the `linkHref` attribute from each node with the same `linkHref` attribute value.
	 * When the selection is non-collapsed, it removes the `linkHref` attribute from each node in selected ranges.
	 *
	 * # Decorators
	 *
	 * If {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`} is specified,
	 * all configured decorators are removed together with the `linkHref` attribute.
	 *
	 * @fires execute
	 */ execute() {
        const editor = this.editor;
        const model = this.editor.model;
        const selection = model.document.selection;
        const linkCommand = editor.commands.get('link');
        model.change((writer)=>{
            // Get ranges to unlink.
            const rangesToUnlink = selection.isCollapsed ? [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findAttributeRange"])(selection.getFirstPosition(), 'linkHref', selection.getAttribute('linkHref'), model)
            ] : model.schema.getValidRanges(selection.getRanges(), 'linkHref');
            // Remove `linkHref` attribute from specified ranges.
            for (const range of rangesToUnlink){
                writer.removeAttribute('linkHref', range);
                // If there are registered custom attributes, then remove them during unlink.
                if (linkCommand) {
                    for (const manualDecorator of linkCommand.manualDecorators){
                        writer.removeAttribute(manualDecorator.id, range);
                    }
                }
            }
        });
    }
}
/**
 * Helper class that stores manual decorators with observable {@link module:link/utils/manualdecorator~ManualDecorator#value}
 * to support integration with the UI state. An instance of this class is a model with the state of individual manual decorators.
 * These decorators are kept as collections in {@link module:link/linkcommand~LinkCommand#manualDecorators}.
 */ class ManualDecorator extends /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObservableMixin"])() {
    /**
	 * An ID of a manual decorator which is the name of the attribute in the model, for example: 'linkManualDecorator0'.
	 */ id;
    /**
	 * The default value of manual decorator.
	 */ defaultValue;
    /**
	 * The label used in the user interface to toggle the manual decorator.
	 */ label;
    /**
	 * A set of attributes added to downcasted data when the decorator is activated for a specific link.
	 * Attributes should be added in a form of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
	 */ attributes;
    /**
	 * A set of classes added to downcasted data when the decorator is activated for a specific link.
	 * Classes should be added in a form of classes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
	 */ classes;
    /**
	 * A set of styles added to downcasted data when the decorator is activated for a specific link.
	 * Styles should be added in a form of styles defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
	 */ styles;
    /**
	 * Creates a new instance of {@link module:link/utils/manualdecorator~ManualDecorator}.
	 *
	 * @param config.id The name of the attribute used in the model that represents a given manual decorator.
	 * For example: `'linkIsExternal'`.
	 * @param config.label The label used in the user interface to toggle the manual decorator.
	 * @param config.attributes A set of attributes added to output data when the decorator is active for a specific link.
	 * Attributes should keep the format of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
	 * @param [config.defaultValue] Controls whether the decorator is "on" by default.
	 */ constructor({ id, label, attributes, classes, styles, defaultValue }){
        super();
        this.id = id;
        this.set('value', undefined);
        this.defaultValue = defaultValue;
        this.label = label;
        this.attributes = attributes;
        this.classes = classes;
        this.styles = styles;
    }
    /**
	 * Returns {@link module:engine/view/matcher~MatcherPattern} with decorator attributes.
	 *
	 * @internal
	 */ _createPattern() {
        return {
            attributes: this.attributes,
            classes: this.classes,
            styles: this.styles
        };
    }
}
const HIGHLIGHT_CLASS = 'ck-link_selected';
const DECORATOR_AUTOMATIC = 'automatic';
const DECORATOR_MANUAL = 'manual';
const EXTERNAL_LINKS_REGEXP = /^(https?:)?\/\//;
/**
 * The link engine feature.
 *
 * It introduces the `linkHref="url"` attribute in the model which renders to the view as a `<a href="url">` element
 * as well as `'link'` and `'unlink'` commands.
 */ class LinkEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'LinkEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        // Clipboard is required for handling cut and paste events while typing over the link.
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TwoStepCaretMovement"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Input"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$clipboard$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClipboardPipeline"]
        ];
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('link', {
            allowCreatingEmptyLinks: false,
            addTargetToExternalLinks: false
        });
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const allowedProtocols = this.editor.config.get('link.allowedProtocols');
        // Allow link attribute on all inline nodes.
        editor.model.schema.extend('$text', {
            allowAttributes: 'linkHref'
        });
        editor.conversion.for('dataDowncast').attributeToElement({
            model: 'linkHref',
            view: createLinkElement
        });
        editor.conversion.for('editingDowncast').attributeToElement({
            model: 'linkHref',
            view: (href, conversionApi)=>{
                return createLinkElement(ensureSafeUrl(href, allowedProtocols), conversionApi);
            }
        });
        editor.conversion.for('upcast').elementToAttribute({
            view: {
                name: 'a',
                attributes: {
                    href: true
                }
            },
            model: {
                key: 'linkHref',
                value: (viewElement)=>viewElement.getAttribute('href')
            }
        });
        // Create linking commands.
        editor.commands.add('link', new LinkCommand(editor));
        editor.commands.add('unlink', new UnlinkCommand(editor));
        const linkDecorators = getLocalizedDecorators(editor.t, normalizeDecorators(editor.config.get('link.decorators')));
        this._enableAutomaticDecorators(linkDecorators.filter((item)=>item.mode === DECORATOR_AUTOMATIC));
        this._enableManualDecorators(linkDecorators.filter((item)=>item.mode === DECORATOR_MANUAL));
        // Enable two-step caret movement for `linkHref` attribute.
        const twoStepCaretMovementPlugin = editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TwoStepCaretMovement"]);
        twoStepCaretMovementPlugin.registerAttribute('linkHref');
        // Setup highlight over selected link.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inlineHighlight"])(editor, 'linkHref', 'a', HIGHLIGHT_CLASS);
        // Handle link following by CTRL+click or ALT+ENTER
        this._enableLinkOpen();
        // Clears the DocumentSelection decorator attributes if the selection is no longer in a link (for example while using 2-SCM).
        this._enableSelectionAttributesFixer();
        // Handle adding default protocol to pasted links.
        this._enableClipboardIntegration();
    }
    /**
	 * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators}
	 * and registers a {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}
	 * for each one of them. Downcast dispatchers are obtained using the
	 * {@link module:link/utils/automaticdecorators~AutomaticDecorators#getDispatcher} method.
	 *
	 * **Note**: This method also activates the automatic external link decorator if enabled with
	 * {@link module:link/linkconfig~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}.
	 */ _enableAutomaticDecorators(automaticDecoratorDefinitions) {
        const editor = this.editor;
        // Store automatic decorators in the command instance as we do the same with manual decorators.
        // Thanks to that, `LinkImageEditing` plugin can re-use the same definitions.
        const command = editor.commands.get('link');
        const automaticDecorators = command.automaticDecorators;
        // Adds a default decorator for external links.
        if (editor.config.get('link.addTargetToExternalLinks')) {
            automaticDecorators.add({
                id: 'linkIsExternal',
                mode: DECORATOR_AUTOMATIC,
                callback: (url)=>!!url && EXTERNAL_LINKS_REGEXP.test(url),
                attributes: {
                    target: '_blank',
                    rel: 'noopener noreferrer'
                }
            });
        }
        automaticDecorators.add(automaticDecoratorDefinitions);
        if (automaticDecorators.length) {
            editor.conversion.for('downcast').add(automaticDecorators.getDispatcher());
        }
    }
    /**
	 * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorManualDefinition manual decorators},
	 * transforms them into {@link module:link/utils/manualdecorator~ManualDecorator} instances and stores them in the
	 * {@link module:link/linkcommand~LinkCommand#manualDecorators} collection (a model for manual decorators state).
	 *
	 * Also registers an {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement attribute-to-element}
	 * converter for each manual decorator and extends the {@link module:engine/model/schema~Schema model's schema}
	 * with adequate model attributes.
	 */ _enableManualDecorators(manualDecoratorDefinitions) {
        if (!manualDecoratorDefinitions.length) {
            return;
        }
        const editor = this.editor;
        const command = editor.commands.get('link');
        const manualDecorators = command.manualDecorators;
        manualDecoratorDefinitions.forEach((decoratorDefinition)=>{
            editor.model.schema.extend('$text', {
                allowAttributes: decoratorDefinition.id
            });
            // Keeps reference to manual decorator to decode its name to attributes during downcast.
            const decorator = new ManualDecorator(decoratorDefinition);
            manualDecorators.add(decorator);
            editor.conversion.for('downcast').attributeToElement({
                model: decorator.id,
                view: (manualDecoratorValue, { writer, schema }, { item })=>{
                    // Manual decorators for block links are handled e.g. in LinkImageEditing.
                    if (!(item.is('selection') || schema.isInline(item))) {
                        return;
                    }
                    if (manualDecoratorValue) {
                        const element = writer.createAttributeElement('a', decorator.attributes, {
                            priority: 5
                        });
                        if (decorator.classes) {
                            writer.addClass(decorator.classes, element);
                        }
                        for(const key in decorator.styles){
                            writer.setStyle(key, decorator.styles[key], element);
                        }
                        writer.setCustomProperty('link', true, element);
                        return element;
                    }
                }
            });
            editor.conversion.for('upcast').elementToAttribute({
                view: {
                    name: 'a',
                    ...decorator._createPattern()
                },
                model: {
                    key: decorator.id
                }
            });
        });
    }
    /**
	 * Attaches handlers for {@link module:engine/view/document~Document#event:enter} and
	 * {@link module:engine/view/document~Document#event:click} to enable link following.
	 */ _enableLinkOpen() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const bookmarkCallbacks = createBookmarkCallbacks(editor);
        function handleLinkOpening(url) {
            if (bookmarkCallbacks.isScrollableToTarget(url)) {
                bookmarkCallbacks.scrollToTarget(url);
            } else {
                openLink(url);
            }
        }
        this.listenTo(viewDocument, 'click', (evt, data)=>{
            const shouldOpen = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].isMac ? data.domEvent.metaKey : data.domEvent.ctrlKey;
            if (!shouldOpen) {
                return;
            }
            let clickedElement = data.domTarget;
            if (clickedElement.tagName.toLowerCase() != 'a') {
                clickedElement = clickedElement.closest('a');
            }
            if (!clickedElement) {
                return;
            }
            const url = clickedElement.getAttribute('href');
            if (!url) {
                return;
            }
            evt.stop();
            data.preventDefault();
            handleLinkOpening(url);
        }, {
            context: '$capture'
        });
        // Open link on Alt+Enter.
        this.listenTo(viewDocument, 'keydown', (evt, data)=>{
            const linkCommand = editor.commands.get('link');
            const url = linkCommand.value;
            const shouldOpen = !!url && data.keyCode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].enter && data.altKey;
            if (!shouldOpen) {
                return;
            }
            evt.stop();
            handleLinkOpening(url);
        });
    }
    /**
	 * Watches the DocumentSelection attribute changes and removes link decorator attributes when the linkHref attribute is removed.
	 *
	 * This is to ensure that there is no left-over link decorator attributes on the document selection that is no longer in a link.
	 */ _enableSelectionAttributesFixer() {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        this.listenTo(selection, 'change:attribute', (evt, { attributeKeys })=>{
            if (!attributeKeys.includes('linkHref') || selection.hasAttribute('linkHref')) {
                return;
            }
            model.change((writer)=>{
                removeLinkAttributesFromSelection(writer, getLinkAttributesAllowedOnText(model.schema));
            });
        });
    }
    /**
	 * Enables URL fixing on pasting.
	 */ _enableClipboardIntegration() {
        const editor = this.editor;
        const model = editor.model;
        const defaultProtocol = this.editor.config.get('link.defaultProtocol');
        if (!defaultProtocol) {
            return;
        }
        this.listenTo(editor.plugins.get('ClipboardPipeline'), 'contentInsertion', (evt, data)=>{
            model.change((writer)=>{
                const range = writer.createRangeIn(data.content);
                for (const item of range.getItems()){
                    if (item.hasAttribute('linkHref')) {
                        const newLink = addLinkProtocolIfApplicable(item.getAttribute('linkHref'), defaultProtocol);
                        writer.setAttribute('linkHref', newLink, item);
                    }
                }
            });
        });
    }
}
/**
 * Make the selection free of link-related model attributes.
 * All link-related model attributes start with "link". That includes not only "linkHref"
 * but also all decorator attributes (they have dynamic names), or even custom plugins.
 */ function removeLinkAttributesFromSelection(writer, linkAttributes) {
    writer.removeSelectionAttribute('linkHref');
    for (const attribute of linkAttributes){
        writer.removeSelectionAttribute(attribute);
    }
}
/**
 * Returns an array containing names of the attributes allowed on `$text` that describes the link item.
 */ function getLinkAttributesAllowedOnText(schema) {
    const textAttributes = schema.getDefinition('$text').allowAttributes;
    return textAttributes.filter((attribute)=>attribute.startsWith('link'));
}
/**
 * The link form view controller class.
 *
 * See {@link module:link/ui/linkformview~LinkFormView}.
 */ class LinkFormView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * Tracks information about DOM focus in the form.
	 */ focusTracker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusTracker"]();
    /**
	 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
	 */ keystrokes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeystrokeHandler"]();
    /**
	 * The URL input view.
	 */ urlInputView;
    /**
	 * The Save button view.
	 */ saveButtonView;
    /**
	 * The Cancel button view.
	 */ cancelButtonView;
    /**
	 * A collection of {@link module:ui/button/switchbuttonview~SwitchButtonView},
	 * which corresponds to {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators}
	 * configured in the editor.
	 */ _manualDecoratorSwitches;
    /**
	 * A collection of child views in the form.
	 */ children;
    /**
	 * An array of form validators used by {@link #isValid}.
	 */ _validators;
    /**
	 * A collection of views that can be focused in the form.
	 */ _focusables = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewCollection"]();
    /**
	 * Helps cycling over {@link #_focusables} in the form.
	 */ _focusCycler;
    /**
	 * Creates an instance of the {@link module:link/ui/linkformview~LinkFormView} class.
	 *
	 * Also see {@link #render}.
	 *
	 * @param locale The localization services instance.
	 * @param linkCommand Reference to {@link module:link/linkcommand~LinkCommand}.
	 * @param validators  Form validators used by {@link #isValid}.
	 */ constructor(locale, linkCommand, validators){
        super(locale);
        const t = locale.t;
        this._validators = validators;
        this.urlInputView = this._createUrlInput();
        this.saveButtonView = this._createButton(t('Save'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].check, 'ck-button-save');
        this.saveButtonView.type = 'submit';
        this.cancelButtonView = this._createButton(t('Cancel'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].cancel, 'ck-button-cancel', 'cancel');
        this._manualDecoratorSwitches = this._createManualDecoratorSwitches(linkCommand);
        this.children = this._createFormChildren(linkCommand.manualDecorators);
        this._focusCycler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusCycler"]({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
                // Navigate form fields backwards using the Shift + Tab keystroke.
                focusPrevious: 'shift + tab',
                // Navigate form fields forwards using the Tab key.
                focusNext: 'tab'
            }
        });
        const classList = [
            'ck',
            'ck-link-form',
            'ck-responsive-form'
        ];
        if (linkCommand.manualDecorators.length) {
            classList.push('ck-link-form_layout-vertical', 'ck-vertical-form');
        }
        this.setTemplate({
            tag: 'form',
            attributes: {
                class: classList,
                // https://github.com/ckeditor/ckeditor5-link/issues/90
                tabindex: '-1'
            },
            children: this.children
        });
    }
    /**
	 * Obtains the state of the {@link module:ui/button/switchbuttonview~SwitchButtonView switch buttons} representing
	 * {@link module:link/linkcommand~LinkCommand#manualDecorators manual link decorators}
	 * in the {@link module:link/ui/linkformview~LinkFormView}.
	 *
	 * @returns Key-value pairs, where the key is the name of the decorator and the value is its state.
	 */ getDecoratorSwitchesState() {
        return Array.from(this._manualDecoratorSwitches).reduce((accumulator, switchButton)=>{
            accumulator[switchButton.name] = switchButton.isOn;
            return accumulator;
        }, {});
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["submitHandler"])({
            view: this
        });
        const childViews = [
            this.urlInputView,
            ...this._manualDecoratorSwitches,
            this.saveButtonView,
            this.cancelButtonView
        ];
        childViews.forEach((v)=>{
            // Register the view as focusable.
            this._focusables.add(v);
            // Register the view in the focus tracker.
            this.focusTracker.add(v.element);
        });
        // Start listening for the keystrokes coming from #element.
        this.keystrokes.listenTo(this.element);
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
    }
    /**
	 * Focuses the fist {@link #_focusables} in the form.
	 */ focus() {
        this._focusCycler.focusFirst();
    }
    /**
	 * Validates the form and returns `false` when some fields are invalid.
	 */ isValid() {
        this.resetFormStatus();
        for (const validator of this._validators){
            const errorText = validator(this);
            // One error per field is enough.
            if (errorText) {
                // Apply updated error.
                this.urlInputView.errorText = errorText;
                return false;
            }
        }
        return true;
    }
    /**
	 * Cleans up the supplementary error and information text of the {@link #urlInputView}
	 * bringing them back to the state when the form has been displayed for the first time.
	 *
	 * See {@link #isValid}.
	 */ resetFormStatus() {
        this.urlInputView.errorText = null;
    }
    /**
	 * Creates a labeled input view.
	 *
	 * @returns Labeled field view instance.
	 */ _createUrlInput() {
        const t = this.locale.t;
        const labeledInput = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LabeledFieldView"](this.locale, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLabeledInputText"]);
        labeledInput.fieldView.inputMode = 'url';
        labeledInput.label = t('Link URL');
        return labeledInput;
    }
    /**
	 * Creates a button view.
	 *
	 * @param label The button label.
	 * @param icon The button icon.
	 * @param className The additional button CSS class name.
	 * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
	 * @returns The button view instance.
	 */ _createButton(label, icon, className, eventName) {
        const button = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](this.locale);
        button.set({
            label,
            icon,
            tooltip: true
        });
        button.extendTemplate({
            attributes: {
                class: className
            }
        });
        if (eventName) {
            button.delegate('execute').to(this, eventName);
        }
        return button;
    }
    /**
	 * Populates {@link module:ui/viewcollection~ViewCollection} of {@link module:ui/button/switchbuttonview~SwitchButtonView}
	 * made based on {@link module:link/linkcommand~LinkCommand#manualDecorators}.
	 *
	 * @param linkCommand A reference to the link command.
	 * @returns ViewCollection of switch buttons.
	 */ _createManualDecoratorSwitches(linkCommand) {
        const switches = this.createCollection();
        for (const manualDecorator of linkCommand.manualDecorators){
            const switchButton = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SwitchButtonView"](this.locale);
            switchButton.set({
                name: manualDecorator.id,
                label: manualDecorator.label,
                withText: true
            });
            switchButton.bind('isOn').toMany([
                manualDecorator,
                linkCommand
            ], 'value', (decoratorValue, commandValue)=>{
                return commandValue === undefined && decoratorValue === undefined ? !!manualDecorator.defaultValue : !!decoratorValue;
            });
            switchButton.on('execute', ()=>{
                manualDecorator.set('value', !switchButton.isOn);
            });
            switches.add(switchButton);
        }
        return switches;
    }
    /**
	 * Populates the {@link #children} collection of the form.
	 *
	 * If {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators} are configured in the editor, it creates an
	 * additional `View` wrapping all {@link #_manualDecoratorSwitches} switch buttons corresponding
	 * to these decorators.
	 *
	 * @param manualDecorators A reference to
	 * the collection of manual decorators stored in the link command.
	 * @returns The children of link form view.
	 */ _createFormChildren(manualDecorators) {
        const children = this.createCollection();
        children.add(this.urlInputView);
        if (manualDecorators.length) {
            const additionalButtonsView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"]();
            additionalButtonsView.setTemplate({
                tag: 'ul',
                children: this._manualDecoratorSwitches.map((switchButton)=>({
                        tag: 'li',
                        children: [
                            switchButton
                        ],
                        attributes: {
                            class: [
                                'ck',
                                'ck-list__item'
                            ]
                        }
                    })),
                attributes: {
                    class: [
                        'ck',
                        'ck-reset',
                        'ck-list'
                    ]
                }
            });
            children.add(additionalButtonsView);
        }
        children.add(this.saveButtonView);
        children.add(this.cancelButtonView);
        return children;
    }
    /**
	 * The native DOM `value` of the {@link #urlInputView} element.
	 *
	 * **Note**: Do not confuse it with the {@link module:ui/inputtext/inputtextview~InputTextView#value}
	 * which works one way only and may not represent the actual state of the component in the DOM.
	 */ get url() {
        const { element } = this.urlInputView.fieldView;
        if (!element) {
            return null;
        }
        return element.value.trim();
    }
}
var unlinkIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z\"/></svg>";
/**
 * The link actions view class. This view displays the link preview, allows
 * unlinking or editing the link.
 */ class LinkActionsView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * Tracks information about DOM focus in the actions.
	 */ focusTracker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusTracker"]();
    /**
	 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
	 */ keystrokes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeystrokeHandler"]();
    /**
	 * The href preview view.
	 */ previewButtonView;
    /**
	 * The unlink button view.
	 */ unlinkButtonView;
    /**
	 * The edit link button view.
	 */ editButtonView;
    /**
	 * A collection of views that can be focused in the view.
	 */ _focusables = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewCollection"]();
    /**
	 * Helps cycling over {@link #_focusables} in the view.
	 */ _focusCycler;
    _linkConfig;
    _options;
    /**
	 * @inheritDoc
	 */ constructor(locale, linkConfig = {}, options){
        super(locale);
        const t = locale.t;
        this._options = options;
        this.previewButtonView = this._createPreviewButton();
        this.unlinkButtonView = this._createButton(t('Unlink'), unlinkIcon, 'unlink');
        this.editButtonView = this._createButton(t('Edit link'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].pencil, 'edit');
        this.set('href', undefined);
        this._linkConfig = linkConfig;
        this._focusCycler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusCycler"]({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
                // Navigate fields backwards using the Shift + Tab keystroke.
                focusPrevious: 'shift + tab',
                // Navigate fields forwards using the Tab key.
                focusNext: 'tab'
            }
        });
        this.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-link-actions',
                    'ck-responsive-form'
                ],
                // https://github.com/ckeditor/ckeditor5-link/issues/90
                tabindex: '-1'
            },
            children: [
                this.previewButtonView,
                this.editButtonView,
                this.unlinkButtonView
            ]
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        const childViews = [
            this.previewButtonView,
            this.editButtonView,
            this.unlinkButtonView
        ];
        childViews.forEach((v)=>{
            // Register the view as focusable.
            this._focusables.add(v);
            // Register the view in the focus tracker.
            this.focusTracker.add(v.element);
        });
        // Start listening for the keystrokes coming from #element.
        this.keystrokes.listenTo(this.element);
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
    }
    /**
	 * Focuses the fist {@link #_focusables} in the actions.
	 */ focus() {
        this._focusCycler.focusFirst();
    }
    /**
	 * Creates a button view.
	 *
	 * @param label The button label.
	 * @param icon The button icon.
	 * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
	 * @returns The button view instance.
	 */ _createButton(label, icon, eventName) {
        const button = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](this.locale);
        button.set({
            label,
            icon,
            tooltip: true
        });
        button.delegate('execute').to(this, eventName);
        return button;
    }
    /**
	 * Creates a link href preview button.
	 *
	 * @returns The button view instance.
	 */ _createPreviewButton() {
        const button = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](this.locale);
        const bind = this.bindTemplate;
        const t = this.t;
        button.set({
            withText: true
        });
        button.extendTemplate({
            attributes: {
                class: [
                    'ck',
                    'ck-link-actions__preview'
                ],
                href: bind.to('href', (href)=>href && ensureSafeUrl(href, this._linkConfig.allowedProtocols)),
                target: '_blank',
                rel: 'noopener noreferrer'
            },
            on: {
                click: bind.to((evt)=>{
                    if (this._options && this._options.isScrollableToTarget(this.href)) {
                        evt.preventDefault();
                        this._options.scrollToTarget(this.href);
                    } else {
                        openLink(this.href);
                    }
                })
            }
        });
        button.bind('tooltip').to(this, 'href', (href)=>{
            if (this._options && this._options.isScrollableToTarget(href)) {
                return t('Scroll to target');
            }
            return t('Open link in new tab');
        });
        button.bind('label').to(this, 'href', (href)=>{
            return href || t('This link has no URL');
        });
        button.bind('isEnabled').to(this, 'href', (href)=>!!href);
        button.template.tag = 'a';
        return button;
    }
}
var linkIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z\"/></svg>";
const VISUAL_SELECTION_MARKER_NAME = 'link-ui';
/**
 * The link UI plugin. It introduces the `'link'` and `'unlink'` buttons and support for the <kbd>Ctrl+K</kbd> keystroke.
 *
 * It uses the
 * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon plugin}.
 */ class LinkUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * The actions view displayed inside of the balloon.
	 */ actionsView = null;
    /**
	 * The form view displayed inside the balloon.
	 */ formView = null;
    /**
	 * The contextual balloon plugin instance.
	 */ _balloon;
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ContextualBalloon"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'LinkUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = this.editor.t;
        editor.editing.view.addObserver(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClickObserver"]);
        this._balloon = editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ContextualBalloon"]);
        // Create toolbar buttons.
        this._createToolbarLinkButton();
        this._enableBalloonActivators();
        // Renders a fake visual selection marker on an expanded selection.
        editor.conversion.for('editingDowncast').markerToHighlight({
            model: VISUAL_SELECTION_MARKER_NAME,
            view: {
                classes: [
                    'ck-fake-link-selection'
                ]
            }
        });
        // Renders a fake visual selection marker on a collapsed selection.
        editor.conversion.for('editingDowncast').markerToElement({
            model: VISUAL_SELECTION_MARKER_NAME,
            view: (data, { writer })=>{
                if (!data.markerRange.isCollapsed) {
                    return null;
                }
                const markerElement = writer.createUIElement('span');
                writer.addClass([
                    'ck-fake-link-selection',
                    'ck-fake-link-selection_collapsed'
                ], markerElement);
                return markerElement;
            }
        });
        // Add the information about the keystrokes to the accessibility database.
        editor.accessibility.addKeystrokeInfos({
            keystrokes: [
                {
                    label: t('Create link'),
                    keystroke: LINK_KEYSTROKE
                },
                {
                    label: t('Move out of a link'),
                    keystroke: [
                        [
                            'arrowleft',
                            'arrowleft'
                        ],
                        [
                            'arrowright',
                            'arrowright'
                        ]
                    ]
                }
            ]
        });
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        // Destroy created UI components as they are not automatically destroyed (see ckeditor5#1341).
        if (this.formView) {
            this.formView.destroy();
        }
        if (this.actionsView) {
            this.actionsView.destroy();
        }
    }
    /**
	 * Creates views.
	 */ _createViews() {
        this.actionsView = this._createActionsView();
        this.formView = this._createFormView();
        // Attach lifecycle actions to the the balloon.
        this._enableUserBalloonInteractions();
    }
    /**
	 * Creates the {@link module:link/ui/linkactionsview~LinkActionsView} instance.
	 */ _createActionsView() {
        const editor = this.editor;
        const actionsView = new LinkActionsView(editor.locale, editor.config.get('link'), createBookmarkCallbacks(editor));
        const linkCommand = editor.commands.get('link');
        const unlinkCommand = editor.commands.get('unlink');
        actionsView.bind('href').to(linkCommand, 'value');
        actionsView.editButtonView.bind('isEnabled').to(linkCommand);
        actionsView.unlinkButtonView.bind('isEnabled').to(unlinkCommand);
        // Execute unlink command after clicking on the "Edit" button.
        this.listenTo(actionsView, 'edit', ()=>{
            this._addFormView();
        });
        // Execute unlink command after clicking on the "Unlink" button.
        this.listenTo(actionsView, 'unlink', ()=>{
            editor.execute('unlink');
            this._hideUI();
        });
        // Close the panel on esc key press when the **actions have focus**.
        actionsView.keystrokes.set('Esc', (data, cancel)=>{
            this._hideUI();
            cancel();
        });
        // Open the form view on Ctrl+K when the **actions have focus**..
        actionsView.keystrokes.set(LINK_KEYSTROKE, (data, cancel)=>{
            this._addFormView();
            cancel();
        });
        return actionsView;
    }
    /**
	 * Creates the {@link module:link/ui/linkformview~LinkFormView} instance.
	 */ _createFormView() {
        const editor = this.editor;
        const linkCommand = editor.commands.get('link');
        const defaultProtocol = editor.config.get('link.defaultProtocol');
        const formView = new ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CssTransitionDisablerMixin"])(LinkFormView))(editor.locale, linkCommand, getFormValidators(editor));
        formView.urlInputView.fieldView.bind('value').to(linkCommand, 'value');
        // Form elements should be read-only when corresponding commands are disabled.
        formView.urlInputView.bind('isEnabled').to(linkCommand, 'isEnabled');
        // Disable the "save" button if the command is disabled.
        formView.saveButtonView.bind('isEnabled').to(linkCommand, 'isEnabled');
        // Execute link command after clicking the "Save" button.
        this.listenTo(formView, 'submit', ()=>{
            if (formView.isValid()) {
                const { value } = formView.urlInputView.fieldView.element;
                const parsedUrl = addLinkProtocolIfApplicable(value, defaultProtocol);
                editor.execute('link', parsedUrl, formView.getDecoratorSwitchesState());
                this._closeFormView();
            }
        });
        // Update balloon position when form error changes.
        this.listenTo(formView.urlInputView, 'change:errorText', ()=>{
            editor.ui.update();
        });
        // Hide the panel after clicking the "Cancel" button.
        this.listenTo(formView, 'cancel', ()=>{
            this._closeFormView();
        });
        // Close the panel on esc key press when the **form has focus**.
        formView.keystrokes.set('Esc', (data, cancel)=>{
            this._closeFormView();
            cancel();
        });
        return formView;
    }
    /**
	 * Creates a toolbar Link button. Clicking this button will show
	 * a {@link #_balloon} attached to the selection.
	 */ _createToolbarLinkButton() {
        const editor = this.editor;
        editor.ui.componentFactory.add('link', ()=>{
            const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
            button.set({
                tooltip: true
            });
            return button;
        });
        editor.ui.componentFactory.add('menuBar:link', ()=>{
            const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
            button.set({
                role: 'menuitemcheckbox'
            });
            return button;
        });
    }
    /**
	 * Creates a button for link command to use either in toolbar or in menu bar.
	 */ _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = editor.commands.get('link');
        const view = new ButtonClass(editor.locale);
        const t = locale.t;
        view.set({
            label: t('Link'),
            icon: linkIcon,
            keystroke: LINK_KEYSTROKE,
            isToggleable: true
        });
        view.bind('isEnabled').to(command, 'isEnabled');
        view.bind('isOn').to(command, 'value', (value)=>!!value);
        // Show the panel on button click.
        this.listenTo(view, 'execute', ()=>this._showUI(true));
        return view;
    }
    /**
	 * Attaches actions that control whether the balloon panel containing the
	 * {@link #formView} should be displayed.
	 */ _enableBalloonActivators() {
        const editor = this.editor;
        const viewDocument = editor.editing.view.document;
        // Handle click on view document and show panel when selection is placed inside the link element.
        // Keep panel open until selection will be inside the same link element.
        this.listenTo(viewDocument, 'click', ()=>{
            const parentLink = this._getSelectedLinkElement();
            if (parentLink) {
                // Then show panel but keep focus inside editor editable.
                this._showUI();
            }
        });
        // Handle the `Ctrl+K` keystroke and show the panel.
        editor.keystrokes.set(LINK_KEYSTROKE, (keyEvtData, cancel)=>{
            // Prevent focusing the search bar in FF, Chrome and Edge. See https://github.com/ckeditor/ckeditor5/issues/4811.
            cancel();
            if (editor.commands.get('link').isEnabled) {
                this._showUI(true);
            }
        });
    }
    /**
	 * Attaches actions that control whether the balloon panel containing the
	 * {@link #formView} is visible or not.
	 */ _enableUserBalloonInteractions() {
        // Focus the form if the balloon is visible and the Tab key has been pressed.
        this.editor.keystrokes.set('Tab', (data, cancel)=>{
            if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) {
                this.actionsView.focus();
                cancel();
            }
        }, {
            // Use the high priority because the link UI navigation is more important
            // than other feature's actions, e.g. list indentation.
            // https://github.com/ckeditor/ckeditor5-link/issues/146
            priority: 'high'
        });
        // Close the panel on the Esc key press when the editable has focus and the balloon is visible.
        this.editor.keystrokes.set('Esc', (data, cancel)=>{
            if (this._isUIVisible) {
                this._hideUI();
                cancel();
            }
        });
        // Close on click outside of balloon panel element.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clickOutsideHandler"])({
            emitter: this.formView,
            activator: ()=>this._isUIInPanel,
            contextElements: ()=>[
                    this._balloon.view.element
                ],
            callback: ()=>this._hideUI()
        });
    }
    /**
	 * Adds the {@link #actionsView} to the {@link #_balloon}.
	 *
	 * @internal
	 */ _addActionsView() {
        if (!this.actionsView) {
            this._createViews();
        }
        if (this._areActionsInPanel) {
            return;
        }
        this._balloon.add({
            view: this.actionsView,
            position: this._getBalloonPositionData()
        });
    }
    /**
	 * Adds the {@link #formView} to the {@link #_balloon}.
	 */ _addFormView() {
        if (!this.formView) {
            this._createViews();
        }
        if (this._isFormInPanel) {
            return;
        }
        const editor = this.editor;
        const linkCommand = editor.commands.get('link');
        this.formView.disableCssTransitions();
        this.formView.resetFormStatus();
        this._balloon.add({
            view: this.formView,
            position: this._getBalloonPositionData()
        });
        // Make sure that each time the panel shows up, the URL field remains in sync with the value of
        // the command. If the user typed in the input, then canceled the balloon (`urlInputView.fieldView#value` stays
        // unaltered) and re-opened it without changing the value of the link command (e.g. because they
        // clicked the same link), they would see the old value instead of the actual value of the command.
        // https://github.com/ckeditor/ckeditor5-link/issues/78
        // https://github.com/ckeditor/ckeditor5-link/issues/123
        this.formView.urlInputView.fieldView.value = linkCommand.value || '';
        // Select input when form view is currently visible.
        if (this._balloon.visibleView === this.formView) {
            this.formView.urlInputView.fieldView.select();
        }
        this.formView.enableCssTransitions();
    }
    /**
	 * Closes the form view. Decides whether the balloon should be hidden completely or if the action view should be shown. This is
	 * decided upon the link command value (which has a value if the document selection is in the link).
	 *
	 * Additionally, if any {@link module:link/linkconfig~LinkConfig#decorators} are defined in the editor configuration, the state of
	 * switch buttons responsible for manual decorator handling is restored.
	 */ _closeFormView() {
        const linkCommand = this.editor.commands.get('link');
        // Restore manual decorator states to represent the current model state. This case is important to reset the switch buttons
        // when the user cancels the editing form.
        linkCommand.restoreManualDecoratorStates();
        if (linkCommand.value !== undefined) {
            this._removeFormView();
        } else {
            this._hideUI();
        }
    }
    /**
	 * Removes the {@link #formView} from the {@link #_balloon}.
	 */ _removeFormView() {
        if (this._isFormInPanel) {
            // Blur the input element before removing it from DOM to prevent issues in some browsers.
            // See https://github.com/ckeditor/ckeditor5/issues/1501.
            this.formView.saveButtonView.focus();
            // Reset the URL field to update the state of the submit button.
            this.formView.urlInputView.fieldView.reset();
            this._balloon.remove(this.formView);
            // Because the form has an input which has focus, the focus must be brought back
            // to the editor. Otherwise, it would be lost.
            this.editor.editing.view.focus();
            this._hideFakeVisualSelection();
        }
    }
    /**
	 * Shows the correct UI type. It is either {@link #formView} or {@link #actionsView}.
	 *
	 * @internal
	 */ _showUI(forceVisible = false) {
        if (!this.formView) {
            this._createViews();
        }
        // When there's no link under the selection, go straight to the editing UI.
        if (!this._getSelectedLinkElement()) {
            // Show visual selection on a text without a link when the contextual balloon is displayed.
            // See https://github.com/ckeditor/ckeditor5/issues/4721.
            this._showFakeVisualSelection();
            this._addActionsView();
            // Be sure panel with link is visible.
            if (forceVisible) {
                this._balloon.showStack('main');
            }
            this._addFormView();
        } else {
            // Go to the editing UI if actions are already visible.
            if (this._areActionsVisible) {
                this._addFormView();
            } else {
                this._addActionsView();
            }
            // Be sure panel with link is visible.
            if (forceVisible) {
                this._balloon.showStack('main');
            }
        }
        // Begin responding to ui#update once the UI is added.
        this._startUpdatingUI();
    }
    /**
	 * Removes the {@link #formView} from the {@link #_balloon}.
	 *
	 * See {@link #_addFormView}, {@link #_addActionsView}.
	 */ _hideUI() {
        if (!this._isUIInPanel) {
            return;
        }
        const editor = this.editor;
        this.stopListening(editor.ui, 'update');
        this.stopListening(this._balloon, 'change:visibleView');
        // Make sure the focus always gets back to the editable _before_ removing the focused form view.
        // Doing otherwise causes issues in some browsers. See https://github.com/ckeditor/ckeditor5-link/issues/193.
        editor.editing.view.focus();
        // Remove form first because it's on top of the stack.
        this._removeFormView();
        // Then remove the actions view because it's beneath the form.
        this._balloon.remove(this.actionsView);
        this._hideFakeVisualSelection();
    }
    /**
	 * Makes the UI react to the {@link module:ui/editorui/editorui~EditorUI#event:update} event to
	 * reposition itself when the editor UI should be refreshed.
	 *
	 * See: {@link #_hideUI} to learn when the UI stops reacting to the `update` event.
	 */ _startUpdatingUI() {
        const editor = this.editor;
        const viewDocument = editor.editing.view.document;
        let prevSelectedLink = this._getSelectedLinkElement();
        let prevSelectionParent = getSelectionParent();
        const update = ()=>{
            const selectedLink = this._getSelectedLinkElement();
            const selectionParent = getSelectionParent();
            // Hide the panel if:
            //
            // * the selection went out of the EXISTING link element. E.g. user moved the caret out
            //   of the link,
            // * the selection went to a different parent when creating a NEW link. E.g. someone
            //   else modified the document.
            // * the selection has expanded (e.g. displaying link actions then pressing SHIFT+Right arrow).
            //
            // Note: #_getSelectedLinkElement will return a link for a non-collapsed selection only
            // when fully selected.
            if (prevSelectedLink && !selectedLink || !prevSelectedLink && selectionParent !== prevSelectionParent) {
                this._hideUI();
            } else if (this._isUIVisible) {
                // If still in a link element, simply update the position of the balloon.
                // If there was no link (e.g. inserting one), the balloon must be moved
                // to the new position in the editing view (a new native DOM range).
                this._balloon.updatePosition(this._getBalloonPositionData());
            }
            prevSelectedLink = selectedLink;
            prevSelectionParent = selectionParent;
        };
        function getSelectionParent() {
            return viewDocument.selection.focus.getAncestors().reverse().find((node)=>node.is('element'));
        }
        this.listenTo(editor.ui, 'update', update);
        this.listenTo(this._balloon, 'change:visibleView', update);
    }
    /**
	 * Returns `true` when {@link #formView} is in the {@link #_balloon}.
	 */ get _isFormInPanel() {
        return !!this.formView && this._balloon.hasView(this.formView);
    }
    /**
	 * Returns `true` when {@link #actionsView} is in the {@link #_balloon}.
	 */ get _areActionsInPanel() {
        return !!this.actionsView && this._balloon.hasView(this.actionsView);
    }
    /**
	 * Returns `true` when {@link #actionsView} is in the {@link #_balloon} and it is
	 * currently visible.
	 */ get _areActionsVisible() {
        return !!this.actionsView && this._balloon.visibleView === this.actionsView;
    }
    /**
	 * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon}.
	 */ get _isUIInPanel() {
        return this._isFormInPanel || this._areActionsInPanel;
    }
    /**
	 * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon} and it is
	 * currently visible.
	 */ get _isUIVisible() {
        const visibleView = this._balloon.visibleView;
        return !!this.formView && visibleView == this.formView || this._areActionsVisible;
    }
    /**
	 * Returns positioning options for the {@link #_balloon}. They control the way the balloon is attached
	 * to the target element or selection.
	 *
	 * If the selection is collapsed and inside a link element, the panel will be attached to the
	 * entire link element. Otherwise, it will be attached to the selection.
	 */ _getBalloonPositionData() {
        const view = this.editor.editing.view;
        const model = this.editor.model;
        const viewDocument = view.document;
        let target;
        if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
            // There are cases when we highlight selection using a marker (#7705, #4721).
            const markerViewElements = Array.from(this.editor.editing.mapper.markerNameToElements(VISUAL_SELECTION_MARKER_NAME));
            const newRange = view.createRange(view.createPositionBefore(markerViewElements[0]), view.createPositionAfter(markerViewElements[markerViewElements.length - 1]));
            target = view.domConverter.viewRangeToDom(newRange);
        } else {
            // Make sure the target is calculated on demand at the last moment because a cached DOM range
            // (which is very fragile) can desynchronize with the state of the editing view if there was
            // any rendering done in the meantime. This can happen, for instance, when an inline widget
            // gets unlinked.
            target = ()=>{
                const targetLink = this._getSelectedLinkElement();
                return targetLink ? view.domConverter.mapViewToDom(targetLink) : view.domConverter.viewRangeToDom(viewDocument.selection.getFirstRange());
            };
        }
        return {
            target
        };
    }
    /**
	 * Returns the link {@link module:engine/view/attributeelement~AttributeElement} under
	 * the {@link module:engine/view/document~Document editing view's} selection or `null`
	 * if there is none.
	 *
	 * **Note**: For a non–collapsed selection, the link element is returned when **fully**
	 * selected and the **only** element within the selection boundaries, or when
	 * a linked widget is selected.
	 */ _getSelectedLinkElement() {
        const view = this.editor.editing.view;
        const selection = view.document.selection;
        const selectedElement = selection.getSelectedElement();
        // The selection is collapsed or some widget is selected (especially inline widget).
        if (selection.isCollapsed || selectedElement && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWidget"])(selectedElement)) {
            return findLinkElementAncestor(selection.getFirstPosition());
        } else {
            // The range for fully selected link is usually anchored in adjacent text nodes.
            // Trim it to get closer to the actual link element.
            const range = selection.getFirstRange().getTrimmed();
            const startLink = findLinkElementAncestor(range.start);
            const endLink = findLinkElementAncestor(range.end);
            if (!startLink || startLink != endLink) {
                return null;
            }
            // Check if the link element is fully selected.
            if (view.createRangeIn(startLink).getTrimmed().isEqual(range)) {
                return startLink;
            } else {
                return null;
            }
        }
    }
    /**
	 * Displays a fake visual selection when the contextual balloon is displayed.
	 *
	 * This adds a 'link-ui' marker into the document that is rendered as a highlight on selected text fragment.
	 */ _showFakeVisualSelection() {
        const model = this.editor.model;
        model.change((writer)=>{
            const range = model.document.selection.getFirstRange();
            if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
                writer.updateMarker(VISUAL_SELECTION_MARKER_NAME, {
                    range
                });
            } else {
                if (range.start.isAtEnd) {
                    const startPosition = range.start.getLastMatchingPosition(({ item })=>!model.schema.isContent(item), {
                        boundaries: range
                    });
                    writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
                        usingOperation: false,
                        affectsData: false,
                        range: writer.createRange(startPosition, range.end)
                    });
                } else {
                    writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
                        usingOperation: false,
                        affectsData: false,
                        range
                    });
                }
            }
        });
    }
    /**
	 * Hides the fake visual selection created in {@link #_showFakeVisualSelection}.
	 */ _hideFakeVisualSelection() {
        const model = this.editor.model;
        if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
            model.change((writer)=>{
                writer.removeMarker(VISUAL_SELECTION_MARKER_NAME);
            });
        }
    }
}
/**
 * Returns a link element if there's one among the ancestors of the provided `Position`.
 *
 * @param View position to analyze.
 * @returns Link element at the position or null.
 */ function findLinkElementAncestor(position) {
    return position.getAncestors().find((ancestor)=>isLinkElement(ancestor)) || null;
}
/**
 * Returns link form validation callbacks.
 *
 * @param editor Editor instance.
 */ function getFormValidators(editor) {
    const t = editor.t;
    const allowCreatingEmptyLinks = editor.config.get('link.allowCreatingEmptyLinks');
    return [
        (form)=>{
            if (!allowCreatingEmptyLinks && !form.url.length) {
                return t('Link URL must not be empty.');
            }
        }
    ];
}
const MIN_LINK_LENGTH_WITH_SPACE_AT_END = 4; // Ie: "t.co " (length 5).
// This was a tweak from https://gist.github.com/dperini/729294.
const URL_REG_EXP = new RegExp('(^|\\s)' + // Group 2: Detected URL (or e-mail).
'(' + // Protocol identifier or short syntax "//"
// a. Full form http://user@foo.bar.baz:8080/foo/bar.html#baz?foo=bar
'(' + '(?:(?:(?:https?|ftp):)?\\/\\/)' + // BasicAuth using user:pass (optional)
'(?:\\S+(?::\\S*)?@)?' + '(?:' + // IP address dotted notation octets
// excludes loopback network 0.0.0.0
// excludes reserved space >= 224.0.0.0
// excludes network & broadcast addresses
// (first & last IP address of each class)
'(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])' + '(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}' + '(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))' + '|' + '(' + // Do not allow `www.foo` - see https://github.com/ckeditor/ckeditor5/issues/8050.
'((?!www\\.)|(www\\.))' + // Host & domain names.
'(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+' + // TLD identifier name.
'(?:[a-z\\u00a1-\\uffff]{2,63})' + ')' + ')' + // port number (optional)
'(?::\\d{2,5})?' + // resource path (optional)
'(?:[/?#]\\S*)?' + ')' + '|' + // b. Short form (either www.example.com or example@example.com)
'(' + '(www.|(\\S+@))' + // Host & domain names.
'((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+' + // TLD identifier name.
'(?:[a-z\\u00a1-\\uffff]{2,63})' + ')' + ')$', 'i');
const URL_GROUP_IN_MATCH = 2;
/**
 * The autolink plugin.
 */ class AutoLink extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Delete"],
            LinkEditing
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'AutoLink';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const selection = editor.model.document.selection;
        selection.on('change:range', ()=>{
            // Disable plugin when selection is inside a code block.
            this.isEnabled = !selection.anchor.parent.is('element', 'codeBlock');
        });
        this._enableTypingHandling();
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        this._enableEnterHandling();
        this._enableShiftEnterHandling();
        this._enablePasteLinking();
    }
    /**
	 * For given position, returns a range that includes the whole link that contains the position.
	 *
	 * If position is not inside a link, returns `null`.
	 */ _expandLinkRange(model, position) {
        if (position.textNode && position.textNode.hasAttribute('linkHref')) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findAttributeRange"])(position, 'linkHref', position.textNode.getAttribute('linkHref'), model);
        } else {
            return null;
        }
    }
    /**
	 * Extends the document selection to includes all links that intersects with given `selectedRange`.
	 */ _selectEntireLinks(writer, selectedRange) {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const selStart = selection.getFirstPosition();
        const selEnd = selection.getLastPosition();
        let updatedSelection = selectedRange.getJoined(this._expandLinkRange(model, selStart) || selectedRange);
        if (updatedSelection) {
            updatedSelection = updatedSelection.getJoined(this._expandLinkRange(model, selEnd) || selectedRange);
        }
        if (updatedSelection && (updatedSelection.start.isBefore(selStart) || updatedSelection.end.isAfter(selEnd))) {
            // Only update the selection if it changed.
            writer.setSelection(updatedSelection);
        }
    }
    /**
	 * Enables autolinking on pasting a URL when some content is selected.
	 */ _enablePasteLinking() {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const clipboardPipeline = editor.plugins.get('ClipboardPipeline');
        const linkCommand = editor.commands.get('link');
        clipboardPipeline.on('inputTransformation', (evt, data)=>{
            if (!this.isEnabled || !linkCommand.isEnabled || selection.isCollapsed || data.method !== 'paste') {
                // Abort if we are disabled or the selection is collapsed.
                return;
            }
            if (selection.rangeCount > 1) {
                // Abort if there are multiple selection ranges.
                return;
            }
            const selectedRange = selection.getFirstRange();
            const newLink = data.dataTransfer.getData('text/plain');
            if (!newLink) {
                // Abort if there is no plain text on the clipboard.
                return;
            }
            const matches = newLink.match(URL_REG_EXP);
            // If the text in the clipboard has a URL, and that URL is the whole clipboard.
            if (matches && matches[2] === newLink) {
                model.change((writer)=>{
                    this._selectEntireLinks(writer, selectedRange);
                    linkCommand.execute(newLink);
                });
                evt.stop();
            }
        }, {
            priority: 'high'
        });
    }
    /**
	 * Enables autolinking on typing.
	 */ _enableTypingHandling() {
        const editor = this.editor;
        const watcher = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextWatcher"](editor.model, (text)=>{
            let mappedText = text;
            // 1. Detect <kbd>Space</kbd> after a text with a potential link.
            if (!isSingleSpaceAtTheEnd(mappedText)) {
                return;
            }
            // 2. Remove the last space character.
            mappedText = mappedText.slice(0, -1);
            // 3. Remove punctuation at the end of the URL if it exists.
            if ('!.:,;?'.includes(mappedText[mappedText.length - 1])) {
                mappedText = mappedText.slice(0, -1);
            }
            // 4. Check text before last typed <kbd>Space</kbd> or punctuation.
            const url = getUrlAtTextEnd(mappedText);
            if (url) {
                return {
                    url,
                    removedTrailingCharacters: text.length - mappedText.length
                };
            }
        });
        watcher.on('matched:data', (evt, data)=>{
            const { batch, range, url, removedTrailingCharacters } = data;
            if (!batch.isTyping) {
                return;
            }
            const linkEnd = range.end.getShiftedBy(-removedTrailingCharacters); // Executed after a space character or punctuation.
            const linkStart = linkEnd.getShiftedBy(-url.length);
            const linkRange = editor.model.createRange(linkStart, linkEnd);
            this._applyAutoLink(url, linkRange);
        });
        watcher.bind('isEnabled').to(this);
    }
    /**
	 * Enables autolinking on the <kbd>Enter</kbd> key.
	 */ _enableEnterHandling() {
        const editor = this.editor;
        const model = editor.model;
        const enterCommand = editor.commands.get('enter');
        if (!enterCommand) {
            return;
        }
        enterCommand.on('execute', ()=>{
            const position = model.document.selection.getFirstPosition();
            if (!position.parent.previousSibling) {
                return;
            }
            const rangeToCheck = model.createRangeIn(position.parent.previousSibling);
            this._checkAndApplyAutoLinkOnRange(rangeToCheck);
        });
    }
    /**
	 * Enables autolinking on the <kbd>Shift</kbd>+<kbd>Enter</kbd> keyboard shortcut.
	 */ _enableShiftEnterHandling() {
        const editor = this.editor;
        const model = editor.model;
        const shiftEnterCommand = editor.commands.get('shiftEnter');
        if (!shiftEnterCommand) {
            return;
        }
        shiftEnterCommand.on('execute', ()=>{
            const position = model.document.selection.getFirstPosition();
            const rangeToCheck = model.createRange(model.createPositionAt(position.parent, 0), position.getShiftedBy(-1));
            this._checkAndApplyAutoLinkOnRange(rangeToCheck);
        });
    }
    /**
	 * Checks if the passed range contains a linkable text.
	 */ _checkAndApplyAutoLinkOnRange(rangeToCheck) {
        const model = this.editor.model;
        const { text, range } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLastTextLine"])(rangeToCheck, model);
        const url = getUrlAtTextEnd(text);
        if (url) {
            const linkRange = model.createRange(range.end.getShiftedBy(-url.length), range.end);
            this._applyAutoLink(url, linkRange);
        }
    }
    /**
	 * Applies a link on a given range if the link should be applied.
	 *
	 * @param url The URL to link.
	 * @param range The text range to apply the link attribute to.
	 */ _applyAutoLink(url, range) {
        const model = this.editor.model;
        const defaultProtocol = this.editor.config.get('link.defaultProtocol');
        const fullUrl = addLinkProtocolIfApplicable(url, defaultProtocol);
        if (!this.isEnabled || !isLinkAllowedOnRange(range, model) || !linkHasProtocol(fullUrl) || linkIsAlreadySet(range)) {
            return;
        }
        this._persistAutoLink(fullUrl, range);
    }
    /**
	 * Enqueues autolink changes in the model.
	 *
	 * @param url The URL to link.
	 * @param range The text range to apply the link attribute to.
	 */ _persistAutoLink(url, range) {
        const model = this.editor.model;
        const deletePlugin = this.editor.plugins.get('Delete');
        // Enqueue change to make undo step.
        model.enqueueChange((writer)=>{
            writer.setAttribute('linkHref', url, range);
            model.enqueueChange(()=>{
                deletePlugin.requestUndoOnBackspace();
            });
        });
    }
}
// Check if text should be evaluated by the plugin in order to reduce number of RegExp checks on whole text.
function isSingleSpaceAtTheEnd(text) {
    return text.length > MIN_LINK_LENGTH_WITH_SPACE_AT_END && text[text.length - 1] === ' ' && text[text.length - 2] !== ' ';
}
function getUrlAtTextEnd(text) {
    const match = URL_REG_EXP.exec(text);
    return match ? match[URL_GROUP_IN_MATCH] : null;
}
function isLinkAllowedOnRange(range, model) {
    return model.schema.checkAttributeInSelection(model.createSelection(range), 'linkHref');
}
function linkIsAlreadySet(range) {
    const item = range.start.nodeAfter;
    return !!item && item.hasAttribute('linkHref');
}
/**
 * The link plugin.
 *
 * This is a "glue" plugin that loads the {@link module:link/linkediting~LinkEditing link editing feature}
 * and {@link module:link/linkui~LinkUI link UI feature}.
 */ class Link extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            LinkEditing,
            LinkUI,
            AutoLink
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Link';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
/**
 * The link image engine feature.
 *
 * It accepts the `linkHref="url"` attribute in the model for the {@link module:image/image~Image `<imageBlock>`} element
 * which allows linking images.
 */ class LinkImageEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            'ImageEditing',
            'ImageUtils',
            LinkEditing
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'LinkImageEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        const editor = this.editor;
        const schema = editor.model.schema;
        if (editor.plugins.has('ImageBlockEditing')) {
            schema.extend('imageBlock', {
                allowAttributes: [
                    'linkHref'
                ]
            });
        }
        editor.conversion.for('upcast').add(upcastLink(editor));
        editor.conversion.for('downcast').add(downcastImageLink(editor));
        // Definitions for decorators are provided by the `link` command and the `LinkEditing` plugin.
        this._enableAutomaticDecorators();
        this._enableManualDecorators();
    }
    /**
	 * Processes {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators} definitions and
	 * attaches proper converters that will work when linking an image.`
	 */ _enableAutomaticDecorators() {
        const editor = this.editor;
        const command = editor.commands.get('link');
        const automaticDecorators = command.automaticDecorators;
        if (automaticDecorators.length) {
            editor.conversion.for('downcast').add(automaticDecorators.getDispatcherForLinkedImage());
        }
    }
    /**
	 * Processes transformed {@link module:link/utils/manualdecorator~ManualDecorator} instances and attaches proper converters
	 * that will work when linking an image.
	 */ _enableManualDecorators() {
        const editor = this.editor;
        const command = editor.commands.get('link');
        for (const decorator of command.manualDecorators){
            if (editor.plugins.has('ImageBlockEditing')) {
                editor.model.schema.extend('imageBlock', {
                    allowAttributes: decorator.id
                });
            }
            if (editor.plugins.has('ImageInlineEditing')) {
                editor.model.schema.extend('imageInline', {
                    allowAttributes: decorator.id
                });
            }
            editor.conversion.for('downcast').add(downcastImageLinkManualDecorator(decorator));
            editor.conversion.for('upcast').add(upcastImageLinkManualDecorator(editor, decorator));
        }
    }
}
/**
 * Returns a converter for linked block images that consumes the "href" attribute
 * if a link contains an image.
 *
 * @param editor The editor instance.
 */ function upcastLink(editor) {
    const isImageInlinePluginLoaded = editor.plugins.has('ImageInlineEditing');
    const imageUtils = editor.plugins.get('ImageUtils');
    return (dispatcher)=>{
        dispatcher.on('element:a', (evt, data, conversionApi)=>{
            const viewLink = data.viewItem;
            const imageInLink = imageUtils.findViewImgElement(viewLink);
            if (!imageInLink) {
                return;
            }
            const blockImageView = imageInLink.findAncestor((element)=>imageUtils.isBlockImageView(element));
            // There are four possible cases to consider here
            //
            // 1. A "root > ... > figure.image > a > img" structure.
            // 2. A "root > ... > figure.image > a > picture > img" structure.
            // 3. A "root > ... > block > a > img" structure.
            // 4. A "root > ... > block > a > picture > img" structure.
            //
            // but the last 2 cases should only be considered by this converter when the inline image plugin
            // is NOT loaded in the editor (because otherwise, that would be a plain, linked inline image).
            if (isImageInlinePluginLoaded && !blockImageView) {
                return;
            }
            // There's an image inside an <a> element - we consume it so it won't be picked up by the Link plugin.
            const consumableAttributes = {
                attributes: [
                    'href'
                ]
            };
            // Consume the `href` attribute so the default one will not convert it to $text attribute.
            if (!conversionApi.consumable.consume(viewLink, consumableAttributes)) {
                // Might be consumed by something else - i.e. other converter with priority=highest - a standard check.
                return;
            }
            const linkHref = viewLink.getAttribute('href');
            // Missing the 'href' attribute.
            if (!linkHref) {
                return;
            }
            // A full definition of the image feature.
            // figure > a > img: parent of the view link element is an image element (figure).
            let modelElement = data.modelCursor.parent;
            if (!modelElement.is('element', 'imageBlock')) {
                // a > img: parent of the view link is not the image (figure) element. We need to convert it manually.
                const conversionResult = conversionApi.convertItem(imageInLink, data.modelCursor);
                // Set image range as conversion result.
                data.modelRange = conversionResult.modelRange;
                // Continue conversion where image conversion ends.
                data.modelCursor = conversionResult.modelCursor;
                modelElement = data.modelCursor.nodeBefore;
            }
            if (modelElement && modelElement.is('element', 'imageBlock')) {
                // Set the linkHref attribute from link element on model image element.
                conversionApi.writer.setAttribute('linkHref', linkHref, modelElement);
            }
        }, {
            priority: 'high'
        });
    // Using the same priority that `upcastImageLinkManualDecorator()` converter guarantees
    // that manual decorators will decorate the proper element.
    };
}
/**
 * Creates a converter that adds `<a>` to linked block image view elements.
 */ function downcastImageLink(editor) {
    const imageUtils = editor.plugins.get('ImageUtils');
    return (dispatcher)=>{
        dispatcher.on('attribute:linkHref:imageBlock', (evt, data, conversionApi)=>{
            if (!conversionApi.consumable.consume(data.item, evt.name)) {
                return;
            }
            // The image will be already converted - so it will be present in the view.
            const viewFigure = conversionApi.mapper.toViewElement(data.item);
            const writer = conversionApi.writer;
            // But we need to check whether the link element exists.
            const linkInImage = Array.from(viewFigure.getChildren()).find((child)=>child.is('element', 'a'));
            const viewImage = imageUtils.findViewImgElement(viewFigure);
            // <picture>...<img/></picture> or <img/>
            const viewImgOrPicture = viewImage.parent.is('element', 'picture') ? viewImage.parent : viewImage;
            // If so, update the attribute if it's defined or remove the entire link if the attribute is empty.
            if (linkInImage) {
                if (data.attributeNewValue) {
                    writer.setAttribute('href', data.attributeNewValue, linkInImage);
                } else {
                    writer.move(writer.createRangeOn(viewImgOrPicture), writer.createPositionAt(viewFigure, 0));
                    writer.remove(linkInImage);
                }
            } else {
                // But if it does not exist. Let's wrap already converted image by newly created link element.
                // 1. Create an empty link element.
                const linkElement = writer.createContainerElement('a', {
                    href: data.attributeNewValue
                });
                // 2. Insert link inside the associated image.
                writer.insert(writer.createPositionAt(viewFigure, 0), linkElement);
                // 3. Move the image to the link.
                writer.move(writer.createRangeOn(viewImgOrPicture), writer.createPositionAt(linkElement, 0));
            }
        }, {
            priority: 'high'
        });
    };
}
/**
 * Returns a converter that decorates the `<a>` element when the image is the link label.
 */ function downcastImageLinkManualDecorator(decorator) {
    return (dispatcher)=>{
        dispatcher.on(`attribute:${decorator.id}:imageBlock`, (evt, data, conversionApi)=>{
            const viewFigure = conversionApi.mapper.toViewElement(data.item);
            const linkInImage = Array.from(viewFigure.getChildren()).find((child)=>child.is('element', 'a'));
            // The <a> element was removed by the time this converter is executed.
            // It may happen when the base `linkHref` and decorator attributes are removed
            // at the same time (see #8401).
            if (!linkInImage) {
                return;
            }
            for (const [key, val] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toMap"])(decorator.attributes)){
                conversionApi.writer.setAttribute(key, val, linkInImage);
            }
            if (decorator.classes) {
                conversionApi.writer.addClass(decorator.classes, linkInImage);
            }
            for(const key in decorator.styles){
                conversionApi.writer.setStyle(key, decorator.styles[key], linkInImage);
            }
        });
    };
}
/**
 * Returns a converter that checks whether manual decorators should be applied to the link.
 */ function upcastImageLinkManualDecorator(editor, decorator) {
    const isImageInlinePluginLoaded = editor.plugins.has('ImageInlineEditing');
    const imageUtils = editor.plugins.get('ImageUtils');
    return (dispatcher)=>{
        dispatcher.on('element:a', (evt, data, conversionApi)=>{
            const viewLink = data.viewItem;
            const imageInLink = imageUtils.findViewImgElement(viewLink);
            // We need to check whether an image is inside a link because the converter handles
            // only manual decorators for linked images. See #7975.
            if (!imageInLink) {
                return;
            }
            const blockImageView = imageInLink.findAncestor((element)=>imageUtils.isBlockImageView(element));
            if (isImageInlinePluginLoaded && !blockImageView) {
                return;
            }
            const matcher = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matcher"](decorator._createPattern());
            const result = matcher.match(viewLink);
            // The link element does not have required attributes or/and proper values.
            if (!result) {
                return;
            }
            // Check whether we can consume those attributes.
            if (!conversionApi.consumable.consume(viewLink, result.match)) {
                return;
            }
            // At this stage we can assume that we have the `<imageBlock>` element.
            // `nodeBefore` comes after conversion: `<a><img></a>`.
            // `parent` comes with full image definition: `<figure><a><img></a></figure>.
            // See the body of the `upcastLink()` function.
            const modelElement = data.modelCursor.nodeBefore || data.modelCursor.parent;
            conversionApi.writer.setAttribute(decorator.id, true, modelElement);
        }, {
            priority: 'high'
        });
    // Using the same priority that `upcastLink()` converter guarantees that the linked image was properly converted.
    };
}
/**
 * The link image UI plugin.
 *
 * This plugin provides the `'linkImage'` button that can be displayed in the {@link module:image/imagetoolbar~ImageToolbar}.
 * It can be used to wrap images in links.
 */ class LinkImageUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            LinkEditing,
            LinkUI,
            'ImageBlockEditing'
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'LinkImageUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const viewDocument = editor.editing.view.document;
        this.listenTo(viewDocument, 'click', (evt, data)=>{
            if (this._isSelectedLinkedImage(editor.model.document.selection)) {
                // Prevent browser navigation when clicking a linked image.
                data.preventDefault();
                // Block the `LinkUI` plugin when an image was clicked.
                // In such a case, we'd like to display the image toolbar.
                evt.stop();
            }
        }, {
            priority: 'high'
        });
        this._createToolbarLinkImageButton();
    }
    /**
	 * Creates a `LinkImageUI` button view.
	 *
	 * Clicking this button shows a {@link module:link/linkui~LinkUI#_balloon} attached to the selection.
	 * When an image is already linked, the view shows {@link module:link/linkui~LinkUI#actionsView} or
	 * {@link module:link/linkui~LinkUI#formView} if it is not.
	 */ _createToolbarLinkImageButton() {
        const editor = this.editor;
        const t = editor.t;
        editor.ui.componentFactory.add('linkImage', (locale)=>{
            const button = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](locale);
            const plugin = editor.plugins.get('LinkUI');
            const linkCommand = editor.commands.get('link');
            button.set({
                isEnabled: true,
                label: t('Link image'),
                icon: linkIcon,
                keystroke: LINK_KEYSTROKE,
                tooltip: true,
                isToggleable: true
            });
            // Bind button to the command.
            button.bind('isEnabled').to(linkCommand, 'isEnabled');
            button.bind('isOn').to(linkCommand, 'value', (value)=>!!value);
            // Show the actionsView or formView (both from LinkUI) on button click depending on whether the image is linked already.
            this.listenTo(button, 'execute', ()=>{
                if (this._isSelectedLinkedImage(editor.model.document.selection)) {
                    plugin._addActionsView();
                } else {
                    plugin._showUI(true);
                }
            });
            return button;
        });
    }
    /**
	 * Returns true if a linked image (either block or inline) is the only selected element
	 * in the model document.
	 */ _isSelectedLinkedImage(selection) {
        const selectedModelElement = selection.getSelectedElement();
        const imageUtils = this.editor.plugins.get('ImageUtils');
        return imageUtils.isImage(selectedModelElement) && selectedModelElement.hasAttribute('linkHref');
    }
}
/**
 * The `LinkImage` plugin.
 *
 * This is a "glue" plugin that loads the {@link module:link/linkimageediting~LinkImageEditing link image editing feature}
 * and {@link module:link/linkimageui~LinkImageUI link image UI feature}.
 */ class LinkImage extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            LinkImageEditing,
            LinkImageUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'LinkImage';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-media-embed/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "AutoMediaEmbed": (()=>AutoMediaEmbed),
    "MediaEmbed": (()=>MediaEmbed),
    "MediaEmbedEditing": (()=>MediaEmbedEditing),
    "MediaEmbedToolbar": (()=>MediaEmbedToolbar),
    "MediaEmbedUI": (()=>MediaEmbedUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-widget/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$clipboard$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-clipboard/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-typing/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$undo$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-undo/dist/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module media-embed/converters
 */ /**
 * Returns a function that converts the model "url" attribute to the view representation.
 *
 * Depending on the configuration, the view representation can be "semantic" (for the data pipeline):
 *
 * ```html
 * <figure class="media">
 * 	<oembed url="foo"></oembed>
 * </figure>
 * ```
 *
 * or "non-semantic" (for the editing view pipeline):
 *
 * ```html
 * <figure class="media">
 * 	<div data-oembed-url="foo">[ non-semantic media preview for "foo" ]</div>
 * </figure>
 * ```
 *
 * **Note:** Changing the model "url" attribute replaces the entire content of the
 * `<figure>` in the view.
 *
 * @param registry The registry providing
 * the media and their content.
 * @param options options object with following properties:
 * - elementName When set, overrides the default element name for semantic media embeds.
 * - renderMediaPreview When `true`, the converter will create the view in the non-semantic form.
 * - renderForEditingView When `true`, the converter will create a view specific for the
 * editing pipeline (e.g. including CSS classes, content placeholders).
 */ function modelToViewUrlAttributeConverter(registry, options) {
    const converter = (evt, data, conversionApi)=>{
        if (!conversionApi.consumable.consume(data.item, evt.name)) {
            return;
        }
        const url = data.attributeNewValue;
        const viewWriter = conversionApi.writer;
        const figure = conversionApi.mapper.toViewElement(data.item);
        const mediaContentElement = [
            ...figure.getChildren()
        ].find((child)=>child.getCustomProperty('media-content'));
        // TODO: removing the wrapper and creating it from scratch is a hack. We can do better than that.
        viewWriter.remove(mediaContentElement);
        const mediaViewElement = registry.getMediaViewElement(viewWriter, url, options);
        viewWriter.insert(viewWriter.createPositionAt(figure, 0), mediaViewElement);
    };
    return (dispatcher)=>{
        dispatcher.on('attribute:url:media', converter);
    };
}
/**
 * Converts a given {@link module:engine/view/element~Element} to a media embed widget:
 * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the media widget element.
 * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.
 *
 * @param writer An instance of the view writer.
 * @param label The element's label.
 */ function toMediaWidget(viewElement, writer, label) {
    writer.setCustomProperty('media', true, viewElement);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toWidget"])(viewElement, writer, {
        label
    });
}
/**
 * Returns a media widget editing view element if one is selected.
 */ function getSelectedMediaViewWidget(selection) {
    const viewElement = selection.getSelectedElement();
    if (viewElement && isMediaWidget(viewElement)) {
        return viewElement;
    }
    return null;
}
/**
 * Checks if a given view element is a media widget.
 */ function isMediaWidget(viewElement) {
    return !!viewElement.getCustomProperty('media') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWidget"])(viewElement);
}
/**
 * Creates a view element representing the media. Either a "semantic" one for the data pipeline:
 *
 * ```html
 * <figure class="media">
 * 	<oembed url="foo"></oembed>
 * </figure>
 * ```
 *
 * or a "non-semantic" (for the editing view pipeline):
 *
 * ```html
 * <figure class="media">
 * 	<div data-oembed-url="foo">[ non-semantic media preview for "foo" ]</div>
 * </figure>
 * ```
 */ function createMediaFigureElement(writer, registry, url, options) {
    return writer.createContainerElement('figure', {
        class: 'media'
    }, [
        registry.getMediaViewElement(writer, url, options),
        writer.createSlot()
    ]);
}
/**
 * Returns a selected media element in the model, if any.
 */ function getSelectedMediaModelWidget(selection) {
    const selectedElement = selection.getSelectedElement();
    if (selectedElement && selectedElement.is('element', 'media')) {
        return selectedElement;
    }
    return null;
}
/**
 * Creates a media element and inserts it into the model.
 *
 * **Note**: This method will use {@link module:engine/model/model~Model#insertContent `model.insertContent()`} logic of inserting content
 * if no `insertPosition` is passed.
 *
 * @param url An URL of an embeddable media.
 * @param findOptimalPosition If true it will try to find optimal position to insert media without breaking content
 * in which a selection is.
 */ function insertMedia(model, url, selectable, findOptimalPosition) {
    model.change((writer)=>{
        const mediaElement = writer.createElement('media', {
            url
        });
        model.insertObject(mediaElement, selectable, null, {
            setSelection: 'on',
            findOptimalPosition: findOptimalPosition ? 'auto' : undefined
        });
    });
}
/**
 * The insert media command.
 *
 * The command is registered by the {@link module:media-embed/mediaembedediting~MediaEmbedEditing} as `'mediaEmbed'`.
 *
 * To insert media at the current selection, execute the command and specify the URL:
 *
 * ```ts
 * editor.execute( 'mediaEmbed', 'http://url.to.the/media' );
 * ```
 */ class MediaEmbedCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedMedia = getSelectedMediaModelWidget(selection);
        this.value = selectedMedia ? selectedMedia.getAttribute('url') : undefined;
        this.isEnabled = isMediaSelected(selection) || isAllowedInParent(selection, model);
    }
    /**
	 * Executes the command, which either:
	 *
	 * * updates the URL of the selected media,
	 * * inserts the new media into the editor and puts the selection around it.
	 *
	 * @fires execute
	 * @param url The URL of the media.
	 */ execute(url) {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedMedia = getSelectedMediaModelWidget(selection);
        if (selectedMedia) {
            model.change((writer)=>{
                writer.setAttribute('url', url, selectedMedia);
            });
        } else {
            insertMedia(model, url, selection, true);
        }
    }
}
/**
 * Checks if the media embed is allowed in the parent.
 */ function isAllowedInParent(selection, model) {
    const insertionRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findOptimalInsertionRange"])(selection, model);
    let parent = insertionRange.start.parent;
    // The model.insertContent() will remove empty parent (unless it is a $root or a limit).
    if (parent.isEmpty && !model.schema.isLimit(parent)) {
        parent = parent.parent;
    }
    return model.schema.checkChild(parent, 'media');
}
/**
 * Checks if the media object is selected.
 */ function isMediaSelected(selection) {
    const element = selection.getSelectedElement();
    return !!element && element.name === 'media';
}
var mediaPlaceholderIcon = "<svg viewBox=\"0 0 64 42\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z\"/></svg>";
const mediaPlaceholderIconViewBox = '0 0 64 42';
/**
 * A bridge between the raw media content provider definitions and the editor view content.
 *
 * It helps translating media URLs to corresponding {@link module:engine/view/element~Element view elements}.
 *
 * Mostly used by the {@link module:media-embed/mediaembedediting~MediaEmbedEditing} plugin.
 */ class MediaRegistry {
    /**
	 * The {@link module:utils/locale~Locale} instance.
	 */ locale;
    /**
	 * The media provider definitions available for the registry. Usually corresponding with the
	 * {@link module:media-embed/mediaembedconfig~MediaEmbedConfig media configuration}.
	 */ providerDefinitions;
    /**
	 * Creates an instance of the {@link module:media-embed/mediaregistry~MediaRegistry} class.
	 *
	 * @param locale The localization services instance.
	 * @param config The configuration of the media embed feature.
	 */ constructor(locale, config){
        const providers = config.providers;
        const extraProviders = config.extraProviders || [];
        const removedProviders = new Set(config.removeProviders);
        const providerDefinitions = providers.concat(extraProviders).filter((provider)=>{
            const name = provider.name;
            if (!name) {
                /**
					 * One of the providers (or extra providers) specified in the media embed configuration
					 * has no name and will not be used by the editor. In order to get this media
					 * provider working, double check your editor configuration.
					 *
					 * @error media-embed-no-provider-name
					 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('media-embed-no-provider-name', {
                    provider
                });
                return false;
            }
            return !removedProviders.has(name);
        });
        this.locale = locale;
        this.providerDefinitions = providerDefinitions;
    }
    /**
	 * Checks whether the passed URL is representing a certain media type allowed in the editor.
	 *
	 * @param url The URL to be checked
	 */ hasMedia(url) {
        return !!this._getMedia(url);
    }
    /**
	 * For the given media URL string and options, it returns the {@link module:engine/view/element~Element view element}
	 * representing that media.
	 *
	 * **Note:** If no URL is specified, an empty view element is returned.
	 *
	 * @param writer The view writer used to produce a view element.
	 * @param url The URL to be translated into a view element.
	 */ getMediaViewElement(writer, url, options) {
        return this._getMedia(url).getViewElement(writer, options);
    }
    /**
	 * Returns a `Media` instance for the given URL.
	 *
	 * @param url The URL of the media.
	 * @returns The `Media` instance or `null` when there is none.
	 */ _getMedia(url) {
        if (!url) {
            return new Media(this.locale);
        }
        url = url.trim();
        for (const definition of this.providerDefinitions){
            const previewRenderer = definition.html;
            const pattern = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])(definition.url);
            for (const subPattern of pattern){
                const match = this._getUrlMatches(url, subPattern);
                if (match) {
                    return new Media(this.locale, url, match, previewRenderer);
                }
            }
        }
        return null;
    }
    /**
	 * Tries to match `url` to `pattern`.
	 *
	 * @param url The URL of the media.
	 * @param pattern The pattern that should accept the media URL.
	 */ _getUrlMatches(url, pattern) {
        // 1. Try to match without stripping the protocol and "www" subdomain.
        let match = url.match(pattern);
        if (match) {
            return match;
        }
        // 2. Try to match after stripping the protocol.
        let rawUrl = url.replace(/^https?:\/\//, '');
        match = rawUrl.match(pattern);
        if (match) {
            return match;
        }
        // 3. Try to match after stripping the "www" subdomain.
        rawUrl = rawUrl.replace(/^www\./, '');
        match = rawUrl.match(pattern);
        if (match) {
            return match;
        }
        return null;
    }
}
/**
 * Represents media defined by the provider configuration.
 *
 * It can be rendered to the {@link module:engine/view/element~Element view element} and used in the editing or data pipeline.
 */ class Media {
    /**
	 * The URL this Media instance represents.
	 */ url;
    /**
	 * Shorthand for {@link module:utils/locale~Locale#t}.
	 *
	 * @see module:utils/locale~Locale#t
	 */ _locale;
    /**
	 * The output of the `RegExp.match` which validated the {@link #url} of this media.
	 */ _match;
    /**
	 * The function returning the HTML string preview of this media.
	 */ _previewRenderer;
    constructor(locale, url, match, previewRenderer){
        this.url = this._getValidUrl(url);
        this._locale = locale;
        this._match = match;
        this._previewRenderer = previewRenderer;
    }
    /**
	 * Returns the view element representation of the media.
	 *
	 * @param writer The view writer used to produce a view element.
	 */ getViewElement(writer, options) {
        const attributes = {};
        let viewElement;
        if (options.renderForEditingView || options.renderMediaPreview && this.url && this._previewRenderer) {
            if (this.url) {
                attributes['data-oembed-url'] = this.url;
            }
            if (options.renderForEditingView) {
                attributes.class = 'ck-media__wrapper';
            }
            const mediaHtml = this._getPreviewHtml(options);
            viewElement = writer.createRawElement('div', attributes, (domElement, domConverter)=>{
                domConverter.setContentOf(domElement, mediaHtml);
            });
        } else {
            if (this.url) {
                attributes.url = this.url;
            }
            viewElement = writer.createEmptyElement(options.elementName, attributes);
        }
        writer.setCustomProperty('media-content', true, viewElement);
        return viewElement;
    }
    /**
	 * Returns the HTML string of the media content preview.
	 */ _getPreviewHtml(options) {
        if (this._previewRenderer) {
            return this._previewRenderer(this._match);
        } else {
            // The placeholder only makes sense for editing view and media which have URLs.
            // Placeholder is never displayed in data and URL-less media have no content.
            if (this.url && options.renderForEditingView) {
                return this._getPlaceholderHtml();
            }
            return '';
        }
    }
    /**
	 * Returns the placeholder HTML when the media has no content preview.
	 */ _getPlaceholderHtml() {
        const icon = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IconView"]();
        const t = this._locale.t;
        icon.content = mediaPlaceholderIcon;
        icon.viewBox = mediaPlaceholderIconViewBox;
        const placeholder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Template"]({
            tag: 'div',
            attributes: {
                class: 'ck ck-reset_all ck-media__placeholder'
            },
            children: [
                {
                    tag: 'div',
                    attributes: {
                        class: 'ck-media__placeholder__icon'
                    },
                    children: [
                        icon
                    ]
                },
                {
                    tag: 'a',
                    attributes: {
                        class: 'ck-media__placeholder__url',
                        target: '_blank',
                        rel: 'noopener noreferrer',
                        href: this.url,
                        'data-cke-tooltip-text': t('Open media in new tab')
                    },
                    children: [
                        {
                            tag: 'span',
                            attributes: {
                                class: 'ck-media__placeholder__url__text'
                            },
                            children: [
                                this.url
                            ]
                        }
                    ]
                }
            ]
        }).render();
        return placeholder.outerHTML;
    }
    /**
	 * Returns the full URL to the specified media.
	 *
	 * @param url The URL of the media.
	 */ _getValidUrl(url) {
        if (!url) {
            return null;
        }
        if (url.match(/^https?/)) {
            return url;
        }
        return 'https://' + url;
    }
}
/**
 * The media embed editing feature.
 */ class MediaEmbedEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'MediaEmbedEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * The media registry managing the media providers in the editor.
	 */ registry;
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('mediaEmbed', {
            elementName: 'oembed',
            providers: [
                {
                    name: 'dailymotion',
                    url: [
                        /^dailymotion\.com\/video\/(\w+)/,
                        /^dai.ly\/(\w+)/
                    ],
                    html: (match)=>{
                        const id = match[1];
                        return '<div style="position: relative; padding-bottom: 100%; height: 0; ">' + `<iframe src="https://www.dailymotion.com/embed/video/${id}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" width="480" height="270" allowfullscreen allow="autoplay">' + '</iframe>' + '</div>';
                    }
                },
                {
                    name: 'spotify',
                    url: [
                        /^open\.spotify\.com\/(artist\/\w+)/,
                        /^open\.spotify\.com\/(album\/\w+)/,
                        /^open\.spotify\.com\/(track\/\w+)/
                    ],
                    html: (match)=>{
                        const id = match[1];
                        return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;">' + `<iframe src="https://open.spotify.com/embed/${id}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" allowtransparency="true" allow="encrypted-media">' + '</iframe>' + '</div>';
                    }
                },
                {
                    name: 'youtube',
                    url: [
                        /^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/,
                        /^(?:m\.)?youtube\.com\/shorts\/([\w-]+)(?:\?t=(\d+))?/,
                        /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/,
                        /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/,
                        /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/
                    ],
                    html: (match)=>{
                        const id = match[1];
                        const time = match[2];
                        return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' + `<iframe src="https://www.youtube.com/embed/${id}${time ? `?start=${time}` : ''}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>' + '</iframe>' + '</div>';
                    }
                },
                {
                    name: 'vimeo',
                    url: [
                        /^vimeo\.com\/(\d+)/,
                        /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/,
                        /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/,
                        /^vimeo\.com\/channels\/[^/]+\/(\d+)/,
                        /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/,
                        /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/,
                        /^player\.vimeo\.com\/video\/(\d+)/
                    ],
                    html: (match)=>{
                        const id = match[1];
                        return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' + `<iframe src="https://player.vimeo.com/video/${id}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen>' + '</iframe>' + '</div>';
                    }
                },
                {
                    name: 'instagram',
                    url: [
                        /^instagram\.com\/p\/(\w+)/,
                        /^instagram\.com\/reel\/(\w+)/
                    ]
                },
                {
                    name: 'twitter',
                    url: [
                        /^twitter\.com/,
                        /^x\.com/
                    ]
                },
                {
                    name: 'googleMaps',
                    url: [
                        /^google\.com\/maps/,
                        /^goo\.gl\/maps/,
                        /^maps\.google\.com/,
                        /^maps\.app\.goo\.gl/
                    ]
                },
                {
                    name: 'flickr',
                    url: /^flickr\.com/
                },
                {
                    name: 'facebook',
                    url: /^facebook\.com/
                }
            ]
        });
        this.registry = new MediaRegistry(editor.locale, editor.config.get('mediaEmbed'));
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        const t = editor.t;
        const conversion = editor.conversion;
        const renderMediaPreview = editor.config.get('mediaEmbed.previewsInData');
        const elementName = editor.config.get('mediaEmbed.elementName');
        const registry = this.registry;
        editor.commands.add('mediaEmbed', new MediaEmbedCommand(editor));
        // Configure the schema.
        schema.register('media', {
            inheritAllFrom: '$blockObject',
            allowAttributes: [
                'url'
            ]
        });
        // Model -> Data
        conversion.for('dataDowncast').elementToStructure({
            model: 'media',
            view: (modelElement, { writer })=>{
                const url = modelElement.getAttribute('url');
                return createMediaFigureElement(writer, registry, url, {
                    elementName,
                    renderMediaPreview: !!url && renderMediaPreview
                });
            }
        });
        // Model -> Data (url -> data-oembed-url)
        conversion.for('dataDowncast').add(modelToViewUrlAttributeConverter(registry, {
            elementName,
            renderMediaPreview
        }));
        // Model -> View (element)
        conversion.for('editingDowncast').elementToStructure({
            model: 'media',
            view: (modelElement, { writer })=>{
                const url = modelElement.getAttribute('url');
                const figure = createMediaFigureElement(writer, registry, url, {
                    elementName,
                    renderForEditingView: true
                });
                return toMediaWidget(figure, writer, t('media widget'));
            }
        });
        // Model -> View (url -> data-oembed-url)
        conversion.for('editingDowncast').add(modelToViewUrlAttributeConverter(registry, {
            elementName,
            renderForEditingView: true
        }));
        // View -> Model (data-oembed-url -> url)
        conversion.for('upcast') // Upcast semantic media.
        .elementToElement({
            view: (element)=>[
                    'oembed',
                    elementName
                ].includes(element.name) && element.getAttribute('url') ? {
                    name: true
                } : null,
            model: (viewMedia, { writer })=>{
                const url = viewMedia.getAttribute('url');
                if (registry.hasMedia(url)) {
                    return writer.createElement('media', {
                        url
                    });
                }
                return null;
            }
        }) // Upcast non-semantic media.
        .elementToElement({
            view: {
                name: 'div',
                attributes: {
                    'data-oembed-url': true
                }
            },
            model: (viewMedia, { writer })=>{
                const url = viewMedia.getAttribute('data-oembed-url');
                if (registry.hasMedia(url)) {
                    return writer.createElement('media', {
                        url
                    });
                }
                return null;
            }
        }) // Consume `<figure class="media">` elements, that were left after upcast.
        .add((dispatcher)=>{
            const converter = (evt, data, conversionApi)=>{
                if (!conversionApi.consumable.consume(data.viewItem, {
                    name: true,
                    classes: 'media'
                })) {
                    return;
                }
                const { modelRange, modelCursor } = conversionApi.convertChildren(data.viewItem, data.modelCursor);
                data.modelRange = modelRange;
                data.modelCursor = modelCursor;
                const modelElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(modelRange.getItems());
                if (!modelElement) {
                    // Revert consumed figure so other features can convert it.
                    conversionApi.consumable.revert(data.viewItem, {
                        name: true,
                        classes: 'media'
                    });
                }
            };
            dispatcher.on('element:figure', converter);
        });
    }
}
const URL_REGEXP = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
/**
 * The auto-media embed plugin. It recognizes media links in the pasted content and embeds
 * them shortly after they are injected into the document.
 */ class AutoMediaEmbed extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$clipboard$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Clipboard"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Delete"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$undo$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Undo"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'AutoMediaEmbed';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * The paste–to–embed `setTimeout` ID. Stored as a property to allow
	 * cleaning of the timeout.
	 */ _timeoutId;
    /**
	 * The position where the `<media>` element will be inserted after the timeout,
	 * determined each time the new content is pasted into the document.
	 */ _positionToInsert;
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        this._timeoutId = null;
        this._positionToInsert = null;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const modelDocument = editor.model.document;
        // We need to listen on `Clipboard#inputTransformation` because we need to save positions of selection.
        // After pasting, the content between those positions will be checked for a URL that could be transformed
        // into media.
        const clipboardPipeline = editor.plugins.get('ClipboardPipeline');
        this.listenTo(clipboardPipeline, 'inputTransformation', ()=>{
            const firstRange = modelDocument.selection.getFirstRange();
            const leftLivePosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LivePosition"].fromPosition(firstRange.start);
            leftLivePosition.stickiness = 'toPrevious';
            const rightLivePosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LivePosition"].fromPosition(firstRange.end);
            rightLivePosition.stickiness = 'toNext';
            modelDocument.once('change:data', ()=>{
                this._embedMediaBetweenPositions(leftLivePosition, rightLivePosition);
                leftLivePosition.detach();
                rightLivePosition.detach();
            }, {
                priority: 'high'
            });
        });
        const undoCommand = editor.commands.get('undo');
        undoCommand.on('execute', ()=>{
            if (this._timeoutId) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window.clearTimeout(this._timeoutId);
                this._positionToInsert.detach();
                this._timeoutId = null;
                this._positionToInsert = null;
            }
        }, {
            priority: 'high'
        });
    }
    /**
	 * Analyzes the part of the document between provided positions in search for a URL representing media.
	 * When the URL is found, it is automatically converted into media.
	 *
	 * @param leftPosition Left position of the selection.
	 * @param rightPosition Right position of the selection.
	 */ _embedMediaBetweenPositions(leftPosition, rightPosition) {
        const editor = this.editor;
        const mediaRegistry = editor.plugins.get(MediaEmbedEditing).registry;
        // TODO: Use marker instead of LiveRange & LivePositions.
        const urlRange = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LiveRange"](leftPosition, rightPosition);
        const walker = urlRange.getWalker({
            ignoreElementEnd: true
        });
        let url = '';
        for (const node of walker){
            if (node.item.is('$textProxy')) {
                url += node.item.data;
            }
        }
        url = url.trim();
        // If the URL does not match to universal URL regexp, let's skip that.
        if (!url.match(URL_REGEXP)) {
            urlRange.detach();
            return;
        }
        // If the URL represents a media, let's use it.
        if (!mediaRegistry.hasMedia(url)) {
            urlRange.detach();
            return;
        }
        const mediaEmbedCommand = editor.commands.get('mediaEmbed');
        // Do not anything if media element cannot be inserted at the current position (#47).
        if (!mediaEmbedCommand.isEnabled) {
            urlRange.detach();
            return;
        }
        // Position won't be available in the `setTimeout` function so let's clone it.
        this._positionToInsert = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LivePosition"].fromPosition(leftPosition);
        // This action mustn't be executed if undo was called between pasting and auto-embedding.
        this._timeoutId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window.setTimeout(()=>{
            editor.model.change((writer)=>{
                this._timeoutId = null;
                writer.remove(urlRange);
                urlRange.detach();
                let insertionPosition = null;
                // Check if position where the media element should be inserted is still valid.
                // Otherwise leave it as undefined to use document.selection - default behavior of model.insertContent().
                if (this._positionToInsert.root.rootName !== '$graveyard') {
                    insertionPosition = this._positionToInsert;
                }
                insertMedia(editor.model, url, insertionPosition, false);
                this._positionToInsert.detach();
                this._positionToInsert = null;
            });
            editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Delete"]).requestUndoOnBackspace();
        }, 100);
    }
}
/**
 * The media form view controller class.
 *
 * See {@link module:media-embed/ui/mediaformview~MediaFormView}.
 */ class MediaFormView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * Tracks information about the DOM focus in the form.
	 */ focusTracker;
    /**
	 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
	 */ keystrokes;
    /**
	 * The URL input view.
	 */ urlInputView;
    /**
	 * An array of form validators used by {@link #isValid}.
	 */ _validators;
    /**
	 * The default info text for the {@link #urlInputView}.
	 */ _urlInputViewInfoDefault;
    /**
	 * The info text with an additional tip for the {@link #urlInputView},
	 * displayed when the input has some value.
	 */ _urlInputViewInfoTip;
    /**
	 * @param validators Form validators used by {@link #isValid}.
	 * @param locale The localization services instance.
	 */ constructor(validators, locale){
        super(locale);
        this.focusTracker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusTracker"]();
        this.keystrokes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeystrokeHandler"]();
        this.set('mediaURLInputValue', '');
        this.urlInputView = this._createUrlInput();
        this._validators = validators;
        this.setTemplate({
            tag: 'form',
            attributes: {
                class: [
                    'ck',
                    'ck-media-form',
                    'ck-responsive-form'
                ],
                tabindex: '-1'
            },
            children: [
                this.urlInputView
            ]
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["submitHandler"])({
            view: this
        });
        // Register the view in the focus tracker.
        this.focusTracker.add(this.urlInputView.element);
        // Start listening for the keystrokes coming from #element.
        this.keystrokes.listenTo(this.element);
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
    }
    /**
	 * Focuses the {@link #urlInputView}.
	 */ focus() {
        this.urlInputView.focus();
    }
    /**
	 * The native DOM `value` of the {@link #urlInputView} element.
	 *
	 * **Note**: Do not confuse it with the {@link module:ui/inputtext/inputtextview~InputTextView#value}
	 * which works one way only and may not represent the actual state of the component in the DOM.
	 */ get url() {
        return this.urlInputView.fieldView.element.value.trim();
    }
    set url(url) {
        this.urlInputView.fieldView.value = url.trim();
    }
    /**
	 * Validates the form and returns `false` when some fields are invalid.
	 */ isValid() {
        this.resetFormStatus();
        for (const validator of this._validators){
            const errorText = validator(this);
            // One error per field is enough.
            if (errorText) {
                // Apply updated error.
                this.urlInputView.errorText = errorText;
                return false;
            }
        }
        return true;
    }
    /**
	 * Cleans up the supplementary error and information text of the {@link #urlInputView}
	 * bringing them back to the state when the form has been displayed for the first time.
	 *
	 * See {@link #isValid}.
	 */ resetFormStatus() {
        this.urlInputView.errorText = null;
        this.urlInputView.infoText = this._urlInputViewInfoDefault;
    }
    /**
	 * Creates a labeled input view.
	 *
	 * @returns Labeled input view instance.
	 */ _createUrlInput() {
        const t = this.locale.t;
        const labeledInput = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LabeledFieldView"](this.locale, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLabeledInputText"]);
        const inputField = labeledInput.fieldView;
        this._urlInputViewInfoDefault = t('Paste the media URL in the input.');
        this._urlInputViewInfoTip = t('Tip: Paste the URL into the content to embed faster.');
        labeledInput.label = t('Media URL');
        labeledInput.infoText = this._urlInputViewInfoDefault;
        inputField.inputMode = 'url';
        inputField.on('input', ()=>{
            // Display the tip text only when there is some value. Otherwise fall back to the default info text.
            labeledInput.infoText = inputField.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault;
            this.mediaURLInputValue = inputField.element.value.trim();
        });
        return labeledInput;
    }
}
var mediaIcon = "<svg viewBox=\"0 0 22 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M1.587 1.5c-.612 0-.601-.029-.601.551v14.84c0 .59-.01.559.591.559h18.846c.602 0 .591.03.591-.56V2.052c0-.58.01-.55-.591-.55H1.587Zm.701.971h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-14.24 1h13.008v12H4.467l.029-12Zm-2.208 1h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003l-.029 1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h.974v1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Z\"/><path d=\"M8.374 6.648a.399.399 0 0 1 .395-.4.402.402 0 0 1 .2.049l5.148 2.824a.4.4 0 0 1 0 .7l-5.148 2.824a.403.403 0 0 1-.595-.35V6.648Z\"/></svg>";
/**
 * The media embed UI plugin.
 */ class MediaEmbedUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            MediaEmbedEditing,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Dialog"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'MediaEmbedUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    _formView;
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.ui.componentFactory.add('mediaEmbed', ()=>{
            const t = this.editor.locale.t;
            const button = this._createDialogButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
            button.tooltip = true;
            button.label = t('Insert media');
            return button;
        });
        editor.ui.componentFactory.add('menuBar:mediaEmbed', ()=>{
            const t = this.editor.locale.t;
            const button = this._createDialogButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
            button.label = t('Media');
            return button;
        });
    }
    /**
	 * Creates a button for menu bar that will show media embed dialog.
	 */ _createDialogButton(ButtonClass) {
        const editor = this.editor;
        const buttonView = new ButtonClass(editor.locale);
        const command = editor.commands.get('mediaEmbed');
        const dialogPlugin = this.editor.plugins.get('Dialog');
        buttonView.icon = mediaIcon;
        buttonView.bind('isEnabled').to(command, 'isEnabled');
        buttonView.on('execute', ()=>{
            if (dialogPlugin.id === 'mediaEmbed') {
                dialogPlugin.hide();
            } else {
                this._showDialog();
            }
        });
        return buttonView;
    }
    _showDialog() {
        const editor = this.editor;
        const dialog = editor.plugins.get('Dialog');
        const command = editor.commands.get('mediaEmbed');
        const t = editor.locale.t;
        if (!this._formView) {
            const registry = editor.plugins.get(MediaEmbedEditing).registry;
            this._formView = new ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CssTransitionDisablerMixin"])(MediaFormView))(getFormValidators(editor.t, registry), editor.locale);
            this._formView.on('submit', ()=>this._handleSubmitForm());
        }
        dialog.show({
            id: 'mediaEmbed',
            title: t('Insert media'),
            content: this._formView,
            isModal: true,
            onShow: ()=>{
                this._formView.url = command.value || '';
                this._formView.resetFormStatus();
                this._formView.urlInputView.fieldView.select();
            },
            actionButtons: [
                {
                    label: t('Cancel'),
                    withText: true,
                    onExecute: ()=>dialog.hide()
                },
                {
                    label: t('Accept'),
                    class: 'ck-button-action',
                    withText: true,
                    onExecute: ()=>this._handleSubmitForm()
                }
            ]
        });
    }
    _handleSubmitForm() {
        const editor = this.editor;
        const dialog = editor.plugins.get('Dialog');
        if (this._formView.isValid()) {
            editor.execute('mediaEmbed', this._formView.url);
            dialog.hide();
            editor.editing.view.focus();
        }
    }
}
function getFormValidators(t, registry) {
    return [
        (form)=>{
            if (!form.url.length) {
                return t('The URL must not be empty.');
            }
        },
        (form)=>{
            if (!registry.hasMedia(form.url)) {
                return t('This media URL is not supported.');
            }
        }
    ];
}
/**
 * The media embed plugin.
 *
 * For a detailed overview, check the {@glink features/media-embed Media Embed feature documentation}.
 *
 * This is a "glue" plugin which loads the following plugins:
 *
 * * The {@link module:media-embed/mediaembedediting~MediaEmbedEditing media embed editing feature},
 * * The {@link module:media-embed/mediaembedui~MediaEmbedUI media embed UI feature} and
 * * The {@link module:media-embed/automediaembed~AutoMediaEmbed auto-media embed feature}.
 */ class MediaEmbed extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            MediaEmbedEditing,
            MediaEmbedUI,
            AutoMediaEmbed,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Widget"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'MediaEmbed';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
/**
 * The media embed toolbar plugin. It creates a toolbar for media embed that shows up when the media element is selected.
 *
 * Instances of toolbar components (e.g. buttons) are created based on the
 * {@link module:media-embed/mediaembedconfig~MediaEmbedConfig#toolbar `media.toolbar` configuration option}.
 */ class MediaEmbedToolbar extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WidgetToolbarRepository"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'MediaEmbedToolbar';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        const editor = this.editor;
        const t = editor.t;
        const widgetToolbarRepository = editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WidgetToolbarRepository"]);
        widgetToolbarRepository.register('mediaEmbed', {
            ariaLabel: t('Media toolbar'),
            items: editor.config.get('mediaEmbed.toolbar') || [],
            getRelatedElement: getSelectedMediaViewWidget
        });
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-mention/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "DomWrapperView": (()=>DomWrapperView),
    "Mention": (()=>Mention),
    "MentionEditing": (()=>MentionEditing),
    "MentionListItemView": (()=>MentionListItemView),
    "MentionUI": (()=>MentionUI),
    "MentionsView": (()=>MentionsView)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-typing/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$debounce$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__debounce$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/debounce.js [app-client] (ecmascript) <export default as debounce>");
;
;
;
;
;
const BRACKET_PAIRS = {
    '(': ')',
    '[': ']',
    '{': '}'
};
/**
 * The mention command.
 *
 * The command is registered by {@link module:mention/mentionediting~MentionEditing} as `'mention'`.
 *
 * To insert a mention into a range, execute the command and specify a mention object with a range to replace:
 *
 * ```ts
 * const focus = editor.model.document.selection.focus;
 *
 * // It will replace one character before the selection focus with the '#1234' text
 * // with the mention attribute filled with passed attributes.
 * editor.execute( 'mention', {
 * 	marker: '#',
 * 	mention: {
 * 		id: '#1234',
 * 		name: 'Foo',
 * 		title: 'Big Foo'
 * 	},
 * 	range: editor.model.createRange( focus.getShiftedBy( -1 ), focus )
 * } );
 *
 * // It will replace one character before the selection focus with the 'The "Big Foo"' text
 * // with the mention attribute filled with passed attributes.
 * editor.execute( 'mention', {
 * 	marker: '#',
 * 	mention: {
 * 		id: '#1234',
 * 		name: 'Foo',
 * 		title: 'Big Foo'
 * 	},
 * 	text: 'The "Big Foo"',
 * 	range: editor.model.createRange( focus.getShiftedBy( -1 ), focus )
 * } );
 *	```
 */ class MentionCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        // Since this command may pass range in execution parameters, it should be checked directly in execute block.
        this._isEnabledBasedOnSelection = false;
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const doc = model.document;
        this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, 'mention');
    }
    /**
	 * Executes the command.
	 *
	 * @param options Options for the executed command.
	 * @param options.mention The mention object to insert. When a string is passed, it will be used to create a plain
	 * object with the name attribute that equals the passed string.
	 * @param options.marker The marker character (e.g. `'@'`).
	 * @param options.text The text of the inserted mention. Defaults to the full mention string composed from `marker` and
	 * `mention` string or `mention.id` if an object is passed.
	 * @param options.range The range to replace.
	 * Note that the replaced range might be shorter than the inserted text with the mention attribute.
	 * @fires execute
	 */ execute(options) {
        const model = this.editor.model;
        const document = model.document;
        const selection = document.selection;
        const mentionData = typeof options.mention == 'string' ? {
            id: options.mention
        } : options.mention;
        const mentionID = mentionData.id;
        const range = options.range || selection.getFirstRange();
        // Don't execute command if range is in non-editable place.
        if (!model.canEditAt(range)) {
            return;
        }
        const mentionText = options.text || mentionID;
        const mention = _addMentionAttributes({
            _text: mentionText,
            id: mentionID
        }, mentionData);
        if (!mentionID.startsWith(options.marker)) {
            /**
			 * The feed item ID must start with the marker character(s).
			 *
			 * Correct mention feed setting:
			 *
			 * ```ts
			 * mentions: [
			 * 	{
			 * 		marker: '@',
			 * 		feed: [ '@Ann', '@Barney', ... ]
			 * 	}
			 * ]
			 * ```
			 *
			 * Incorrect mention feed setting:
			 *
			 * ```ts
			 * mentions: [
			 * 	{
			 * 		marker: '@',
			 * 		feed: [ 'Ann', 'Barney', ... ]
			 * 	}
			 * ]
			 * ```
			 *
			 * See {@link module:mention/mentionconfig~MentionConfig}.
			 *
			 * @error mentioncommand-incorrect-id
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('mentioncommand-incorrect-id', this);
        }
        model.change((writer)=>{
            const currentAttributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toMap"])(selection.getAttributes());
            const attributesWithMention = new Map(currentAttributes.entries());
            attributesWithMention.set('mention', mention);
            // Replace a range with the text with a mention.
            const insertionRange = model.insertContent(writer.createText(mentionText, attributesWithMention), range);
            const nodeBefore = insertionRange.start.nodeBefore;
            const nodeAfter = insertionRange.end.nodeAfter;
            const isFollowedByWhiteSpace = nodeAfter && nodeAfter.is('$text') && nodeAfter.data.startsWith(' ');
            let isInsertedInBrackets = false;
            if (nodeBefore && nodeAfter && nodeBefore.is('$text') && nodeAfter.is('$text')) {
                const precedingCharacter = nodeBefore.data.slice(-1);
                const isPrecededByOpeningBracket = precedingCharacter in BRACKET_PAIRS;
                const isFollowedByBracketClosure = isPrecededByOpeningBracket && nodeAfter.data.startsWith(BRACKET_PAIRS[precedingCharacter]);
                isInsertedInBrackets = isPrecededByOpeningBracket && isFollowedByBracketClosure;
            }
            // Don't add a white space if either of the following is true:
            // * there's already one after the mention;
            // * the mention was inserted in the empty matching brackets.
            // https://github.com/ckeditor/ckeditor5/issues/4651
            if (!isInsertedInBrackets && !isFollowedByWhiteSpace) {
                model.insertContent(writer.createText(' ', currentAttributes), range.start.getShiftedBy(mentionText.length));
            }
        });
    }
}
/**
 * The mention editing feature.
 *
 * It introduces the {@link module:mention/mentioncommand~MentionCommand command} and the `mention`
 * attribute in the {@link module:engine/model/model~Model model} which renders in the {@link module:engine/view/view view}
 * as a `<span class="mention" data-mention="@mention">`.
 */ class MentionEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'MentionEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const model = editor.model;
        const doc = model.document;
        // Allow the mention attribute on all text nodes.
        model.schema.extend('$text', {
            allowAttributes: 'mention'
        });
        // Upcast conversion.
        editor.conversion.for('upcast').elementToAttribute({
            view: {
                name: 'span',
                attributes: 'data-mention',
                classes: 'mention'
            },
            model: {
                key: 'mention',
                value: (viewElement)=>_toMentionAttribute(viewElement)
            }
        });
        // Downcast conversion.
        editor.conversion.for('downcast').attributeToElement({
            model: 'mention',
            view: createViewMentionElement
        });
        editor.conversion.for('downcast').add(preventPartialMentionDowncast);
        doc.registerPostFixer((writer)=>removePartialMentionPostFixer(writer, doc, model.schema));
        doc.registerPostFixer((writer)=>extendAttributeOnMentionPostFixer(writer, doc));
        doc.registerPostFixer((writer)=>selectionMentionAttributePostFixer(writer, doc));
        editor.commands.add('mention', new MentionCommand(editor));
    }
}
/**
 * @internal
 */ function _addMentionAttributes(baseMentionData, data) {
    return Object.assign({
        uid: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uid"])()
    }, baseMentionData, data || {});
}
/**
 * Creates a mention attribute value from the provided view element and optional data.
 *
 * This function is exposed as
 * {@link module:mention/mention~Mention#toMentionAttribute `editor.plugins.get( 'Mention' ).toMentionAttribute()`}.
 *
 * @internal
 */ function _toMentionAttribute(viewElementOrMention, data) {
    const dataMention = viewElementOrMention.getAttribute('data-mention');
    const textNode = viewElementOrMention.getChild(0);
    // Do not convert empty mentions.
    if (!textNode) {
        return;
    }
    const baseMentionData = {
        id: dataMention,
        _text: textNode.data
    };
    return _addMentionAttributes(baseMentionData, data);
}
/**
 * A converter that blocks partial mention from being converted.
 *
 * This converter is registered with 'highest' priority in order to consume mention attribute before it is converted by
 * any other converters. This converter only consumes partial mention - those whose `_text` attribute is not equal to text with mention
 * attribute. This may happen when copying part of mention text.
 */ function preventPartialMentionDowncast(dispatcher) {
    dispatcher.on('attribute:mention', (evt, data, conversionApi)=>{
        const mention = data.attributeNewValue;
        if (!data.item.is('$textProxy') || !mention) {
            return;
        }
        const start = data.range.start;
        const textNode = start.textNode || start.nodeAfter;
        if (textNode.data != mention._text) {
            // Consume item to prevent partial mention conversion.
            conversionApi.consumable.consume(data.item, evt.name);
        }
    }, {
        priority: 'highest'
    });
}
/**
 * Creates a mention element from the mention data.
 */ function createViewMentionElement(mention, { writer }) {
    if (!mention) {
        return;
    }
    const attributes = {
        class: 'mention',
        'data-mention': mention.id
    };
    const options = {
        id: mention.uid,
        priority: 20
    };
    return writer.createAttributeElement('span', attributes, options);
}
/**
 * Model post-fixer that disallows typing with selection when the selection is placed after the text node with the mention attribute or
 * before a text node with mention attribute.
 */ function selectionMentionAttributePostFixer(writer, doc) {
    const selection = doc.selection;
    const focus = selection.focus;
    if (selection.isCollapsed && selection.hasAttribute('mention') && shouldNotTypeWithMentionAt(focus)) {
        writer.removeSelectionAttribute('mention');
        return true;
    }
    return false;
}
/**
 * Helper function to detect if mention attribute should be removed from selection.
 * This check makes only sense if the selection has mention attribute.
 *
 * The mention attribute should be removed from a selection when selection focus is placed:
 * a) after a text node
 * b) the position is at parents start - the selection will set attributes from node after.
 */ function shouldNotTypeWithMentionAt(position) {
    const isAtStart = position.isAtStart;
    const isAfterAMention = position.nodeBefore && position.nodeBefore.is('$text');
    return isAfterAMention || isAtStart;
}
/**
 * Model post-fixer that removes the mention attribute from the modified text node.
 */ function removePartialMentionPostFixer(writer, doc, schema) {
    const changes = doc.differ.getChanges();
    let wasChanged = false;
    for (const change of changes){
        if (change.type == 'attribute') {
            continue;
        }
        // Checks the text node on the current position.
        const position = change.position;
        if (change.name == '$text') {
            const nodeAfterInsertedTextNode = position.textNode && position.textNode.nextSibling;
            // Checks the text node where the change occurred.
            wasChanged = checkAndFix(position.textNode, writer) || wasChanged;
            // Occurs on paste inside a text node with mention.
            wasChanged = checkAndFix(nodeAfterInsertedTextNode, writer) || wasChanged;
            wasChanged = checkAndFix(position.nodeBefore, writer) || wasChanged;
            wasChanged = checkAndFix(position.nodeAfter, writer) || wasChanged;
        }
        // Checks text nodes in inserted elements (might occur when splitting a paragraph or pasting content inside text with mention).
        if (change.name != '$text' && change.type == 'insert') {
            const insertedNode = position.nodeAfter;
            for (const item of writer.createRangeIn(insertedNode).getItems()){
                wasChanged = checkAndFix(item, writer) || wasChanged;
            }
        }
        // Inserted inline elements might break mention.
        if (change.type == 'insert' && schema.isInline(change.name)) {
            const nodeAfterInserted = position.nodeAfter && position.nodeAfter.nextSibling;
            wasChanged = checkAndFix(position.nodeBefore, writer) || wasChanged;
            wasChanged = checkAndFix(nodeAfterInserted, writer) || wasChanged;
        }
    }
    return wasChanged;
}
/**
 * This post-fixer will extend the attribute applied on the part of the mention so the whole text node of the mention will have
 * the added attribute.
 */ function extendAttributeOnMentionPostFixer(writer, doc) {
    const changes = doc.differ.getChanges();
    let wasChanged = false;
    for (const change of changes){
        if (change.type === 'attribute' && change.attributeKey != 'mention') {
            // Checks the node on the left side of the range...
            const nodeBefore = change.range.start.nodeBefore;
            // ... and on the right side of the range.
            const nodeAfter = change.range.end.nodeAfter;
            for (const node of [
                nodeBefore,
                nodeAfter
            ]){
                if (isBrokenMentionNode(node) && node.getAttribute(change.attributeKey) != change.attributeNewValue) {
                    writer.setAttribute(change.attributeKey, change.attributeNewValue, node);
                    wasChanged = true;
                }
            }
        }
    }
    return wasChanged;
}
/**
 * Checks if a node has a correct mention attribute if present.
 * Returns `true` if the node is text and has a mention attribute whose text does not match the expected mention text.
 */ function isBrokenMentionNode(node) {
    if (!node || !(node.is('$text') || node.is('$textProxy')) || !node.hasAttribute('mention')) {
        return false;
    }
    const text = node.data;
    const mention = node.getAttribute('mention');
    const expectedText = mention._text;
    return text != expectedText;
}
/**
 * Fixes a mention on a text node if it needs a fix.
 */ function checkAndFix(textNode, writer) {
    if (isBrokenMentionNode(textNode)) {
        writer.removeAttribute('mention', textNode);
        return true;
    }
    return false;
}
/**
 * The mention ui view.
 */ class MentionsView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ListView"] {
    selected;
    position;
    /**
	 * @inheritDoc
	 */ constructor(locale){
        super(locale);
        this.extendTemplate({
            attributes: {
                class: [
                    'ck-mentions'
                ],
                tabindex: '-1'
            }
        });
    }
    /**
	 * {@link #select Selects} the first item.
	 */ selectFirst() {
        this.select(0);
    }
    /**
	 * Selects next item to the currently {@link #select selected}.
	 *
	 * If the last item is already selected, it will select the first item.
	 */ selectNext() {
        const item = this.selected;
        const index = this.items.getIndex(item);
        this.select(index + 1);
    }
    /**
	 * Selects previous item to the currently {@link #select selected}.
	 *
	 * If the first item is already selected, it will select the last item.
	 */ selectPrevious() {
        const item = this.selected;
        const index = this.items.getIndex(item);
        this.select(index - 1);
    }
    /**
	 * Marks item at a given index as selected.
	 *
	 * Handles selection cycling when passed index is out of bounds:
	 * - if the index is lower than 0, it will select the last item,
	 * - if the index is higher than the last item index, it will select the first item.
	 *
	 * @param index Index of an item to be marked as selected.
	 */ select(index) {
        let indexToGet = 0;
        if (index > 0 && index < this.items.length) {
            indexToGet = index;
        } else if (index < 0) {
            indexToGet = this.items.length - 1;
        }
        const item = this.items.get(indexToGet);
        // Return early if item is already selected.
        if (this.selected === item) {
            return;
        }
        // Remove highlight of previously selected item.
        if (this.selected) {
            this.selected.removeHighlight();
        }
        item.highlight();
        this.selected = item;
        // Scroll the mentions view to the selected element.
        if (!this._isItemVisibleInScrolledArea(item)) {
            this.element.scrollTop = item.element.offsetTop;
        }
    }
    /**
	 * Triggers the `execute` event on the {@link #select selected} item.
	 */ executeSelected() {
        this.selected.fire('execute');
    }
    /**
	 * Checks if an item is visible in the scrollable area.
	 *
	 * The item is considered visible when:
	 * - its top boundary is inside the scrollable rect
	 * - its bottom boundary is inside the scrollable rect (the whole item must be visible)
	 */ _isItemVisibleInScrolledArea(item) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](this.element).contains(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](item.element));
    }
}
/**
 * This class wraps DOM element as a CKEditor5 UI View.
 *
 * It allows to render any DOM element and use it in mentions list.
 */ class DomWrapperView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * The DOM element for which wrapper was created.
	 */ domElement;
    /**
	 * Creates an instance of {@link module:mention/ui/domwrapperview~DomWrapperView} class.
	 *
	 * Also see {@link #render}.
	 */ constructor(locale, domElement){
        super(locale);
        // Disable template rendering on this view.
        this.template = undefined;
        this.domElement = domElement;
        // Render dom wrapper as a button.
        this.domElement.classList.add('ck-button');
        this.set('isOn', false);
        // Handle isOn state as in buttons.
        this.on('change:isOn', (evt, name, isOn)=>{
            if (isOn) {
                this.domElement.classList.add('ck-on');
                this.domElement.classList.remove('ck-off');
            } else {
                this.domElement.classList.add('ck-off');
                this.domElement.classList.remove('ck-on');
            }
        });
        // Pass click event as execute event.
        this.listenTo(this.domElement, 'click', ()=>{
            this.fire('execute');
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        this.element = this.domElement;
    }
    /**
	 * Focuses the DOM element.
	 */ focus() {
        this.domElement.focus();
    }
}
class MentionListItemView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ListItemView"] {
    item;
    marker;
    highlight() {
        const child = this.children.first;
        child.isOn = true;
    }
    removeHighlight() {
        const child = this.children.first;
        child.isOn = false;
    }
}
const VERTICAL_SPACING = 3;
// The key codes that mention UI handles when it is open (without commit keys).
const defaultHandledKeyCodes = [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].arrowup,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].arrowdown,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].esc
];
// Dropdown commit key codes.
const defaultCommitKeyCodes = [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].enter,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].tab
];
/**
 * The mention UI feature.
 */ class MentionUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * The mention view.
	 */ _mentionsView;
    /**
	 * Stores mention feeds configurations.
	 */ _mentionsConfigurations;
    /**
	 * The contextual balloon plugin instance.
	 */ _balloon;
    _items = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"]();
    _lastRequested;
    /**
	 * Debounced feed requester. It uses `lodash#debounce` method to delay function call.
	 */ _requestFeedDebounced;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'MentionUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ContextualBalloon"]
        ];
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        this._mentionsView = this._createMentionView();
        this._mentionsConfigurations = new Map();
        this._requestFeedDebounced = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$debounce$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__debounce$3e$__["debounce"])(this._requestFeed, 100);
        editor.config.define('mention', {
            feeds: []
        });
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const commitKeys = editor.config.get('mention.commitKeys') || defaultCommitKeyCodes;
        const handledKeyCodes = defaultHandledKeyCodes.concat(commitKeys);
        this._balloon = editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ContextualBalloon"]);
        // Key listener that handles navigation in mention view.
        editor.editing.view.document.on('keydown', (evt, data)=>{
            if (isHandledKey(data.keyCode) && this._isUIVisible) {
                data.preventDefault();
                evt.stop(); // Required for Enter key overriding.
                if (data.keyCode == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].arrowdown) {
                    this._mentionsView.selectNext();
                }
                if (data.keyCode == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].arrowup) {
                    this._mentionsView.selectPrevious();
                }
                if (commitKeys.includes(data.keyCode)) {
                    this._mentionsView.executeSelected();
                }
                if (data.keyCode == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keyCodes"].esc) {
                    this._hideUIAndRemoveMarker();
                }
            }
        }, {
            priority: 'highest'
        }); // Required to override the Enter key.
        // Close the dropdown upon clicking outside of the plugin UI.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clickOutsideHandler"])({
            emitter: this._mentionsView,
            activator: ()=>this._isUIVisible,
            contextElements: ()=>[
                    this._balloon.view.element
                ],
            callback: ()=>this._hideUIAndRemoveMarker()
        });
        const feeds = editor.config.get('mention.feeds');
        for (const mentionDescription of feeds){
            const { feed, marker, dropdownLimit } = mentionDescription;
            if (!isValidMentionMarker(marker)) {
                /**
				 * The marker must be a single character.
				 *
				 * Correct markers: `'@'`, `'#'`.
				 *
				 * Incorrect markers: `'$$'`, `'[@'`.
				 *
				 * See {@link module:mention/mentionconfig~MentionConfig}.
				 *
				 * @error mentionconfig-incorrect-marker
				 * @param marker Configured marker
				 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('mentionconfig-incorrect-marker', null, {
                    marker
                });
            }
            const feedCallback = typeof feed == 'function' ? feed.bind(this.editor) : createFeedCallback(feed);
            const itemRenderer = mentionDescription.itemRenderer;
            const definition = {
                marker,
                feedCallback,
                itemRenderer,
                dropdownLimit
            };
            this._mentionsConfigurations.set(marker, definition);
        }
        this._setupTextWatcher(feeds);
        this.listenTo(editor, 'change:isReadOnly', ()=>{
            this._hideUIAndRemoveMarker();
        });
        this.on('requestFeed:response', (evt, data)=>this._handleFeedResponse(data));
        this.on('requestFeed:error', ()=>this._hideUIAndRemoveMarker());
        /**
		 * Checks if a given key code is handled by the mention UI.
		 */ function isHandledKey(keyCode) {
            return handledKeyCodes.includes(keyCode);
        }
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        // Destroy created UI components as they are not automatically destroyed (see ckeditor5#1341).
        this._mentionsView.destroy();
    }
    /**
	 * Returns true when {@link #_mentionsView} is in the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon} and it is
	 * currently visible.
	 */ get _isUIVisible() {
        return this._balloon.visibleView === this._mentionsView;
    }
    /**
	 * Creates the {@link #_mentionsView}.
	 */ _createMentionView() {
        const locale = this.editor.locale;
        const mentionsView = new MentionsView(locale);
        mentionsView.items.bindTo(this._items).using((data)=>{
            const { item, marker } = data;
            const { dropdownLimit: markerDropdownLimit } = this._mentionsConfigurations.get(marker);
            // Set to 10 by default for backwards compatibility. See: #10479
            const dropdownLimit = markerDropdownLimit || this.editor.config.get('mention.dropdownLimit') || 10;
            if (mentionsView.items.length >= dropdownLimit) {
                return null;
            }
            const listItemView = new MentionListItemView(locale);
            const view = this._renderItem(item, marker);
            view.delegate('execute').to(listItemView);
            listItemView.children.add(view);
            listItemView.item = item;
            listItemView.marker = marker;
            listItemView.on('execute', ()=>{
                mentionsView.fire('execute', {
                    item,
                    marker
                });
            });
            return listItemView;
        });
        mentionsView.on('execute', (evt, data)=>{
            const editor = this.editor;
            const model = editor.model;
            const item = data.item;
            const marker = data.marker;
            const mentionMarker = editor.model.markers.get('mention');
            // Create a range on matched text.
            const end = model.createPositionAt(model.document.selection.focus);
            const start = model.createPositionAt(mentionMarker.getStart());
            const range = model.createRange(start, end);
            this._hideUIAndRemoveMarker();
            editor.execute('mention', {
                mention: item,
                text: item.text,
                marker,
                range
            });
            editor.editing.view.focus();
        });
        return mentionsView;
    }
    /**
	 * Returns item renderer for the marker.
	 */ _getItemRenderer(marker) {
        const { itemRenderer } = this._mentionsConfigurations.get(marker);
        return itemRenderer;
    }
    /**
	 * Requests a feed from a configured callbacks.
	 */ _requestFeed(marker, feedText) {
        // @if CK_DEBUG_MENTION // console.log( '%c[Feed]%c Requesting for', 'color: blue', 'color: black', `"${ feedText }"` );
        // Store the last requested feed - it is used to discard any out-of order requests.
        this._lastRequested = feedText;
        const { feedCallback } = this._mentionsConfigurations.get(marker);
        const feedResponse = feedCallback(feedText);
        const isAsynchronous = feedResponse instanceof Promise;
        // For synchronous feeds (e.g. callbacks, arrays) fire the response event immediately.
        if (!isAsynchronous) {
            this.fire('requestFeed:response', {
                feed: feedResponse,
                marker,
                feedText
            });
            return;
        }
        // Handle the asynchronous responses.
        feedResponse.then((response)=>{
            // Check the feed text of this response with the last requested one so either:
            if (this._lastRequested == feedText) {
                // It is the same and fire the response event.
                this.fire('requestFeed:response', {
                    feed: response,
                    marker,
                    feedText
                });
            } else {
                // It is different - most probably out-of-order one, so fire the discarded event.
                this.fire('requestFeed:discarded', {
                    feed: response,
                    marker,
                    feedText
                });
            }
        }).catch((error)=>{
            this.fire('requestFeed:error', {
                error
            });
            /**
				 * The callback used for obtaining mention autocomplete feed thrown and error and the mention UI was hidden or
				 * not displayed at all.
				 *
				 * @error mention-feed-callback-error
				 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('mention-feed-callback-error', {
                marker
            });
        });
    }
    /**
	 * Registers a text watcher for the marker.
	 */ _setupTextWatcher(feeds) {
        const editor = this.editor;
        const feedsWithPattern = feeds.map((feed)=>({
                ...feed,
                pattern: createRegExp(feed.marker, feed.minimumCharacters || 0)
            }));
        const watcher = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextWatcher"](editor.model, createTestCallback(feedsWithPattern));
        watcher.on('matched', (evt, data)=>{
            const markerDefinition = getLastValidMarkerInText(feedsWithPattern, data.text);
            const selection = editor.model.document.selection;
            const focus = selection.focus;
            const markerPosition = editor.model.createPositionAt(focus.parent, markerDefinition.position);
            if (isPositionInExistingMention(focus) || isMarkerInExistingMention(markerPosition)) {
                this._hideUIAndRemoveMarker();
                return;
            }
            const feedText = requestFeedText(markerDefinition, data.text);
            const matchedTextLength = markerDefinition.marker.length + feedText.length;
            // Create a marker range.
            const start = focus.getShiftedBy(-matchedTextLength);
            const end = focus.getShiftedBy(-feedText.length);
            const markerRange = editor.model.createRange(start, end);
            // @if CK_DEBUG_MENTION // console.group( '%c[TextWatcher]%c matched', 'color: red', 'color: black', `"${ feedText }"` );
            // @if CK_DEBUG_MENTION // console.log( 'data#text', `"${ data.text }"` );
            // @if CK_DEBUG_MENTION // console.log( 'data#range', data.range.start.path, data.range.end.path );
            // @if CK_DEBUG_MENTION // console.log( 'marker definition', markerDefinition );
            // @if CK_DEBUG_MENTION // console.log( 'marker range', markerRange.start.path, markerRange.end.path );
            if (checkIfStillInCompletionMode(editor)) {
                const mentionMarker = editor.model.markers.get('mention');
                // Update the marker - user might've moved the selection to other mention trigger.
                editor.model.change((writer)=>{
                    // @if CK_DEBUG_MENTION // console.log( '%c[Editing]%c Updating the marker.', 'color: purple', 'color: black' );
                    writer.updateMarker(mentionMarker, {
                        range: markerRange
                    });
                });
            } else {
                editor.model.change((writer)=>{
                    // @if CK_DEBUG_MENTION // console.log( '%c[Editing]%c Adding the marker.', 'color: purple', 'color: black' );
                    writer.addMarker('mention', {
                        range: markerRange,
                        usingOperation: false,
                        affectsData: false
                    });
                });
            }
            this._requestFeedDebounced(markerDefinition.marker, feedText);
        // @if CK_DEBUG_MENTION // console.groupEnd();
        });
        watcher.on('unmatched', ()=>{
            this._hideUIAndRemoveMarker();
        });
        const mentionCommand = editor.commands.get('mention');
        watcher.bind('isEnabled').to(mentionCommand);
        return watcher;
    }
    /**
	 * Handles the feed response event data.
	 */ _handleFeedResponse(data) {
        const { feed, marker } = data;
        // eslint-disable-next-line max-len
        // @if CK_DEBUG_MENTION // console.log( `%c[Feed]%c Response for "${ data.feedText }" (${ feed.length })`, 'color: blue', 'color: black', feed );
        // If the marker is not in the document happens when the selection had changed and the 'mention' marker was removed.
        if (!checkIfStillInCompletionMode(this.editor)) {
            return;
        }
        // Reset the view.
        this._items.clear();
        for (const feedItem of feed){
            const item = typeof feedItem != 'object' ? {
                id: feedItem,
                text: feedItem
            } : feedItem;
            this._items.add({
                item,
                marker
            });
        }
        const mentionMarker = this.editor.model.markers.get('mention');
        if (this._items.length) {
            this._showOrUpdateUI(mentionMarker);
        } else {
            // Do not show empty mention UI.
            this._hideUIAndRemoveMarker();
        }
    }
    /**
	 * Shows the mentions balloon. If the panel is already visible, it will reposition it.
	 */ _showOrUpdateUI(markerMarker) {
        if (this._isUIVisible) {
            // @if CK_DEBUG_MENTION // console.log( '%c[UI]%c Updating position.', 'color: green', 'color: black' );
            // Update balloon position as the mention list view may change its size.
            this._balloon.updatePosition(this._getBalloonPanelPositionData(markerMarker, this._mentionsView.position));
        } else {
            // @if CK_DEBUG_MENTION // console.log( '%c[UI]%c Showing the UI.', 'color: green', 'color: black' );
            this._balloon.add({
                view: this._mentionsView,
                position: this._getBalloonPanelPositionData(markerMarker, this._mentionsView.position),
                singleViewMode: true
            });
        }
        this._mentionsView.position = this._balloon.view.position;
        this._mentionsView.selectFirst();
    }
    /**
	 * Hides the mentions balloon and removes the 'mention' marker from the markers collection.
	 */ _hideUIAndRemoveMarker() {
        // Remove the mention view from balloon before removing marker - it is used by balloon position target().
        if (this._balloon.hasView(this._mentionsView)) {
            // @if CK_DEBUG_MENTION // console.log( '%c[UI]%c Hiding the UI.', 'color: green', 'color: black' );
            this._balloon.remove(this._mentionsView);
        }
        if (checkIfStillInCompletionMode(this.editor)) {
            // @if CK_DEBUG_MENTION // console.log( '%c[Editing]%c Removing marker.', 'color: purple', 'color: black' );
            this.editor.model.change((writer)=>writer.removeMarker('mention'));
        }
        // Make the last matched position on panel view undefined so the #_getBalloonPanelPositionData() method will return all positions
        // on the next call.
        this._mentionsView.position = undefined;
    }
    /**
	 * Renders a single item in the autocomplete list.
	 */ _renderItem(item, marker) {
        const editor = this.editor;
        let view;
        let label = item.id;
        const renderer = this._getItemRenderer(marker);
        if (renderer) {
            const renderResult = renderer(item);
            if (typeof renderResult != 'string') {
                view = new DomWrapperView(editor.locale, renderResult);
            } else {
                label = renderResult;
            }
        }
        if (!view) {
            const buttonView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](editor.locale);
            buttonView.label = label;
            buttonView.withText = true;
            view = buttonView;
        }
        return view;
    }
    /**
	 * Creates a position options object used to position the balloon panel.
	 *
	 * @param mentionMarker
	 * @param preferredPosition The name of the last matched position name.
	 */ _getBalloonPanelPositionData(mentionMarker, preferredPosition) {
        const editor = this.editor;
        const editing = editor.editing;
        const domConverter = editing.view.domConverter;
        const mapper = editing.mapper;
        const uiLanguageDirection = editor.locale.uiLanguageDirection;
        return {
            target: ()=>{
                let modelRange = mentionMarker.getRange();
                // Target the UI to the model selection range - the marker has been removed so probably the UI will not be shown anyway.
                // The logic is used by ContextualBalloon to display another panel in the same place.
                if (modelRange.start.root.rootName == '$graveyard') {
                    modelRange = editor.model.document.selection.getFirstRange();
                }
                const viewRange = mapper.toViewRange(modelRange);
                const rangeRects = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"].getDomRangeRects(domConverter.viewRangeToDom(viewRange));
                return rangeRects.pop();
            },
            limiter: ()=>{
                const view = this.editor.editing.view;
                const viewDocument = view.document;
                const editableElement = viewDocument.selection.editableElement;
                if (editableElement) {
                    return view.domConverter.mapViewToDom(editableElement.root);
                }
                return null;
            },
            positions: getBalloonPanelPositions(preferredPosition, uiLanguageDirection)
        };
    }
}
/**
 * Returns the balloon positions data callbacks.
 */ function getBalloonPanelPositions(preferredPosition, uiLanguageDirection) {
    const positions = {
        // Positions the panel to the southeast of the caret rectangle.
        'caret_se': (targetRect)=>{
            return {
                top: targetRect.bottom + VERTICAL_SPACING,
                left: targetRect.right,
                name: 'caret_se',
                config: {
                    withArrow: false
                }
            };
        },
        // Positions the panel to the northeast of the caret rectangle.
        'caret_ne': (targetRect, balloonRect)=>{
            return {
                top: targetRect.top - balloonRect.height - VERTICAL_SPACING,
                left: targetRect.right,
                name: 'caret_ne',
                config: {
                    withArrow: false
                }
            };
        },
        // Positions the panel to the southwest of the caret rectangle.
        'caret_sw': (targetRect, balloonRect)=>{
            return {
                top: targetRect.bottom + VERTICAL_SPACING,
                left: targetRect.right - balloonRect.width,
                name: 'caret_sw',
                config: {
                    withArrow: false
                }
            };
        },
        // Positions the panel to the northwest of the caret rect.
        'caret_nw': (targetRect, balloonRect)=>{
            return {
                top: targetRect.top - balloonRect.height - VERTICAL_SPACING,
                left: targetRect.right - balloonRect.width,
                name: 'caret_nw',
                config: {
                    withArrow: false
                }
            };
        }
    };
    // Returns only the last position if it was matched to prevent the panel from jumping after the first match.
    if (Object.prototype.hasOwnProperty.call(positions, preferredPosition)) {
        return [
            positions[preferredPosition]
        ];
    }
    // By default, return all position callbacks ordered depending on the UI language direction.
    return uiLanguageDirection !== 'rtl' ? [
        positions.caret_se,
        positions.caret_sw,
        positions.caret_ne,
        positions.caret_nw
    ] : [
        positions.caret_sw,
        positions.caret_se,
        positions.caret_nw,
        positions.caret_ne
    ];
}
/**
 * Returns a marker definition of the last valid occurring marker in a given string.
 * If there is no valid marker in a string, it returns undefined.
 *
 * Example of returned object:
 *
 * ```ts
 * {
 * 	marker: '@',
 * 	position: 4,
 * 	minimumCharacters: 0
 * }
 * ````
 *
 * @param feedsWithPattern Registered feeds in editor for mention plugin with created RegExp for matching marker.
 * @param text String to find the marker in
 * @returns Matched marker's definition
 */ function getLastValidMarkerInText(feedsWithPattern, text) {
    let lastValidMarker;
    for (const feed of feedsWithPattern){
        const currentMarkerLastIndex = text.lastIndexOf(feed.marker);
        if (currentMarkerLastIndex > 0 && !text.substring(currentMarkerLastIndex - 1).match(feed.pattern)) {
            continue;
        }
        if (!lastValidMarker || currentMarkerLastIndex >= lastValidMarker.position) {
            lastValidMarker = {
                marker: feed.marker,
                position: currentMarkerLastIndex,
                minimumCharacters: feed.minimumCharacters,
                pattern: feed.pattern
            };
        }
    }
    return lastValidMarker;
}
/**
 * Creates a RegExp pattern for the marker.
 *
 * Function has to be exported to achieve 100% code coverage.
 */ function createRegExp(marker, minimumCharacters) {
    const numberOfCharacters = minimumCharacters == 0 ? '*' : `{${minimumCharacters},}`;
    const openAfterCharacters = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].features.isRegExpUnicodePropertySupported ? '\\p{Ps}\\p{Pi}"\'' : '\\(\\[{"\'';
    const mentionCharacters = '.';
    // I wanted to make an util out of it, but since this regexp uses "u" flag, it became difficult.
    // When "u" flag is used, the regexp has "strict" escaping rules, i.e. if you try to escape a character that does not need
    // to be escaped, RegExp() will throw. It made it difficult to write a generic util, because different characters are
    // allowed in different context. For example, escaping "-" sometimes was correct, but sometimes it threw an error.
    marker = marker.replace(/[.*+?^${}()\-|[\]\\]/g, '\\$&');
    // The pattern consists of 3 groups:
    //
    // - 0 (non-capturing): Opening sequence - start of the line, space or an opening punctuation character like "(" or "\"",
    // - 1: The marker character(s),
    // - 2: Mention input (taking the minimal length into consideration to trigger the UI),
    //
    // The pattern matches up to the caret (end of string switch - $).
    //               (0:      opening sequence       )(1: marker  )(2:                typed mention              )$
    const pattern = `(?:^|[ ${openAfterCharacters}])(${marker})(${mentionCharacters}${numberOfCharacters})$`;
    return new RegExp(pattern, 'u');
}
/**
 * Creates a test callback for the marker to be used in the text watcher instance.
 *
 * @param feedsWithPattern Feeds of mention plugin configured in editor with RegExp to match marker in text
 */ function createTestCallback(feedsWithPattern) {
    const textMatcher = (text)=>{
        const markerDefinition = getLastValidMarkerInText(feedsWithPattern, text);
        if (!markerDefinition) {
            return false;
        }
        let splitStringFrom = 0;
        if (markerDefinition.position !== 0) {
            splitStringFrom = markerDefinition.position - 1;
        }
        const textToTest = text.substring(splitStringFrom);
        return markerDefinition.pattern.test(textToTest);
    };
    return textMatcher;
}
/**
 * Creates a text matcher from the marker.
 */ function requestFeedText(markerDefinition, text) {
    let splitStringFrom = 0;
    if (markerDefinition.position !== 0) {
        splitStringFrom = markerDefinition.position - 1;
    }
    const regExp = createRegExp(markerDefinition.marker, 0);
    const textToMatch = text.substring(splitStringFrom);
    const match = textToMatch.match(regExp);
    return match[2];
}
/**
 * The default feed callback.
 */ function createFeedCallback(feedItems) {
    return (feedText)=>{
        const filteredItems = feedItems // Make the default mention feed case-insensitive.
        .filter((item)=>{
            // Item might be defined as object.
            const itemId = typeof item == 'string' ? item : String(item.id);
            // The default feed is case insensitive.
            return itemId.toLowerCase().includes(feedText.toLowerCase());
        });
        return filteredItems;
    };
}
/**
 * Checks if position in inside or right after a text with a mention.
 */ function isPositionInExistingMention(position) {
    // The text watcher listens only to changed range in selection - so the selection attributes are not yet available
    // and you cannot use selection.hasAttribute( 'mention' ) just yet.
    // See https://github.com/ckeditor/ckeditor5-engine/issues/1723.
    const hasMention = position.textNode && position.textNode.hasAttribute('mention');
    const nodeBefore = position.nodeBefore;
    return hasMention || nodeBefore && nodeBefore.is('$text') && nodeBefore.hasAttribute('mention');
}
/**
 * Checks if the closest marker offset is at the beginning of a mention.
 *
 * See https://github.com/ckeditor/ckeditor5/issues/11400.
 */ function isMarkerInExistingMention(markerPosition) {
    const nodeAfter = markerPosition.nodeAfter;
    return nodeAfter && nodeAfter.is('$text') && nodeAfter.hasAttribute('mention');
}
/**
 * Checks if string is a valid mention marker.
 */ function isValidMentionMarker(marker) {
    return !!marker;
}
/**
 * Checks the mention plugins is in completion mode (e.g. when typing is after a valid mention string like @foo).
 */ function checkIfStillInCompletionMode(editor) {
    return editor.model.markers.has('mention');
}
/**
 * The mention plugin.
 *
 * For a detailed overview, check the {@glink features/mentions Mention feature} guide.
 */ class Mention extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    toMentionAttribute(viewElement, data) {
        return _toMentionAttribute(viewElement, data);
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Mention';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            MentionEditing,
            MentionUI
        ];
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-minimap/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Minimap": (()=>Minimap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
;
;
;
;
const toPx$1 = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUnit"])('px');
/**
 * The internal `<iframe>` view that hosts the minimap content.
 *
 * @internal
 */ class MinimapIframeView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IframeView"] {
    /**
	 * Cached view constructor options for re-use in other methods.
	 */ _options;
    /**
	 * Creates an instance of the internal minimap iframe.
	 */ constructor(locale, options){
        super(locale);
        const bind = this.bindTemplate;
        this.set('top', 0);
        this.set('height', 0);
        this._options = options;
        this.extendTemplate({
            attributes: {
                tabindex: -1,
                'aria-hidden': 'true',
                class: [
                    'ck-minimap__iframe'
                ],
                style: {
                    top: bind.to('top', (top)=>toPx$1(top)),
                    height: bind.to('height', (height)=>toPx$1(height))
                }
            }
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        return super.render().then(()=>{
            this._prepareDocument();
        });
    }
    /**
	 * Sets the new height of the iframe.
	 */ setHeight(newHeight) {
        this.height = newHeight;
    }
    /**
	 * Sets the top offset of the iframe to move it around vertically.
	 */ setTopOffset(newOffset) {
        this.top = newOffset;
    }
    /**
	 * Sets the internal structure of the `<iframe>` readying it to display the
	 * minimap element.
	 */ _prepareDocument() {
        const iframeDocument = this.element.contentWindow.document;
        const domRootClone = iframeDocument.adoptNode(this._options.domRootClone);
        const boxStyles = this._options.useSimplePreview ? `
			.ck.ck-editor__editable_inline img {
				filter: contrast( 0 );
			}

			p, li, a, figcaption, span {
				background: hsl(0, 0%, 80%) !important;
				color: hsl(0, 0%, 80%) !important;
			}

			h1, h2, h3, h4 {
				background: hsl(0, 0%, 60%) !important;
				color: hsl(0, 0%, 60%) !important;
			}
		` : '';
        const pageStyles = this._options.pageStyles.map((definition)=>{
            if (typeof definition === 'string') {
                return `<style>${definition}</style>`;
            } else {
                return `<link rel="stylesheet" type="text/css" href="${definition.href}">`;
            }
        }).join('\n');
        const html = `<!DOCTYPE html><html lang="en">
			<head>
				<meta charset="utf-8">
				<meta name="viewport" content="width=device-width, initial-scale=1">
				${pageStyles}
				<style>
					html, body {
						margin: 0 !important;
						padding: 0 !important;
					}

					html {
						overflow: hidden;
					}

					body {
						transform: scale( ${this._options.scaleRatio} );
						transform-origin: 0 0;
						overflow: visible;
					}

					.ck.ck-editor__editable_inline {
						margin: 0 !important;
						border-color: transparent !important;
						outline-color: transparent !important;
						box-shadow: none !important;
					}

					.ck.ck-content {
						background: white;
					}

					${boxStyles}
				</style>
			</head>
			<body class="${this._options.extraClasses || ''}"></body>
		</html>`;
        iframeDocument.open();
        iframeDocument.write(html);
        iframeDocument.close();
        iframeDocument.body.appendChild(domRootClone);
    }
}
const toPx = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUnit"])('px');
/**
 * The position tracker visualizing the visible subset of the content. Displayed over the minimap.
 *
 * @internal
 */ class MinimapPositionTrackerView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    constructor(locale){
        super(locale);
        const bind = this.bindTemplate;
        this.set('height', 0);
        this.set('top', 0);
        this.set('scrollProgress', 0);
        this.set('_isDragging', false);
        this.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-minimap__position-tracker',
                    bind.if('_isDragging', 'ck-minimap__position-tracker_dragging')
                ],
                style: {
                    top: bind.to('top', (top)=>toPx(top)),
                    height: bind.to('height', (height)=>toPx(height))
                },
                'data-progress': bind.to('scrollProgress')
            },
            on: {
                mousedown: bind.to(()=>{
                    this._isDragging = true;
                })
            }
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        this.listenTo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document, 'mousemove', (evt, data)=>{
            if (!this._isDragging) {
                return;
            }
            this.fire('drag', data.movementY);
        }, {
            useCapture: true
        });
        this.listenTo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document, 'mouseup', ()=>{
            this._isDragging = false;
        }, {
            useCapture: true
        });
    }
    /**
	 * Sets the new height of the tracker to visualize the subset of the content visible to the user.
	 */ setHeight(newHeight) {
        this.height = newHeight;
    }
    /**
	 * Sets the top offset of the tracker to move it around vertically.
	 */ setTopOffset(newOffset) {
        this.top = newOffset;
    }
    /**
	 * Sets the scroll progress (in %) to inform the user using a label when the tracker is being dragged.
	 */ setScrollProgress(newProgress) {
        this.scrollProgress = newProgress;
    }
}
/**
 * The main view of the minimap. It renders the original content but scaled down with a tracker element
 * visualizing the subset of the content visible to the user and allowing interactions (scrolling, dragging).
 *
 * @internal
 */ class MinimapView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * An instance of the tracker view displayed over the minimap.
	 */ _positionTrackerView;
    /**
	 * The scale ratio of the minimap relative to the original editing DOM root with the content.
	 */ _scaleRatio;
    /**
	 * An instance of the iframe view that hosts the minimap.
	 */ _minimapIframeView;
    /**
	 * Creates an instance of the minimap view.
	 */ constructor({ locale, scaleRatio, pageStyles, extraClasses, useSimplePreview, domRootClone }){
        super(locale);
        const bind = this.bindTemplate;
        this._positionTrackerView = new MinimapPositionTrackerView(locale);
        this._positionTrackerView.delegate('drag').to(this);
        this._scaleRatio = scaleRatio;
        this._minimapIframeView = new MinimapIframeView(locale, {
            useSimplePreview,
            pageStyles,
            extraClasses,
            scaleRatio,
            domRootClone
        });
        this.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-minimap'
                ]
            },
            children: [
                this._positionTrackerView
            ],
            on: {
                click: bind.to(this._handleMinimapClick.bind(this)),
                wheel: bind.to(this._handleMinimapMouseWheel.bind(this))
            }
        });
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        this._minimapIframeView.destroy();
        super.destroy();
    }
    /**
	 * Returns the DOM {@link module:utils/dom/rect~Rect} height of the minimap.
	 */ get height() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](this.element).height;
    }
    /**
	 * Returns the number of available space (pixels) the position tracker (visible subset of the content) can use to scroll vertically.
	 */ get scrollHeight() {
        return Math.max(0, Math.min(this.height, this._minimapIframeView.height) - this._positionTrackerView.height);
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        this._minimapIframeView.render();
        this.element.appendChild(this._minimapIframeView.element);
    }
    /**
	 * Sets the new height of the minimap (in px) to respond to the changes in the original editing DOM root.
	 *
	 * **Note**:The provided value should be the `offsetHeight` of the original editing DOM root.
	 */ setContentHeight(newHeight) {
        this._minimapIframeView.setHeight(newHeight * this._scaleRatio);
    }
    /**
	 * Sets the minimap scroll progress.
	 *
	 * The minimap scroll progress is linked to the original editing DOM root and its scrollable container (ancestor).
	 * Changing the progress will alter the vertical position of the minimap (and its position tracker) and give the user an accurate
	 * overview of the visible document.
	 *
	 * **Note**: The value should be between 0 and 1. 0 when the DOM root has not been scrolled, 1 when the
	 * scrolling has reached the end.
	 */ setScrollProgress(newScrollProgress) {
        const iframeView = this._minimapIframeView;
        const positionTrackerView = this._positionTrackerView;
        // The scrolling should end when the bottom edge of the iframe touches the bottom edge of the minimap.
        if (iframeView.height < this.height) {
            iframeView.setTopOffset(0);
            positionTrackerView.setTopOffset((iframeView.height - positionTrackerView.height) * newScrollProgress);
        } else {
            const totalOffset = iframeView.height - this.height;
            iframeView.setTopOffset(-totalOffset * newScrollProgress);
            positionTrackerView.setTopOffset((this.height - positionTrackerView.height) * newScrollProgress);
        }
        positionTrackerView.setScrollProgress(Math.round(newScrollProgress * 100));
    }
    /**
	 * Sets the new height of the tracker (in px) to visualize the subset of the content visible to the user.
	 */ setPositionTrackerHeight(trackerHeight) {
        this._positionTrackerView.setHeight(trackerHeight * this._scaleRatio);
    }
    /**
	 * @param data DOM event data
	 */ _handleMinimapClick(data) {
        const positionTrackerView = this._positionTrackerView;
        if (data.target === positionTrackerView.element) {
            return;
        }
        const trackerViewRect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](positionTrackerView.element);
        const diff = data.clientY - trackerViewRect.top - trackerViewRect.height / 2;
        const percentage = diff / this._minimapIframeView.height;
        this.fire('click', percentage);
    }
    /**
	 * @param data DOM event data
	 */ _handleMinimapMouseWheel(data) {
        this.fire('drag', data.deltaY * this._scaleRatio);
    }
}
/**
 * Clones the editing view DOM root by using a dedicated pair of {@link module:engine/view/renderer~Renderer} and
 * {@link module:engine/view/domconverter~DomConverter}. The DOM root clone updates incrementally to stay in sync with the
 * source root.
 *
 * @internal
 * @param editor The editor instance the original editing root belongs to.
 * @param rootName The name of the root to clone.
 * @returns The editing root DOM clone element.
 */ function cloneEditingViewDomRoot(editor, rootName) {
    const viewDocument = editor.editing.view.document;
    const viewRoot = viewDocument.getRoot(rootName);
    const domConverter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DomConverter"](viewDocument);
    const renderer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Renderer"](domConverter, viewDocument.selection);
    const domRootClone = editor.editing.view.getDomRoot().cloneNode();
    domConverter.bindElements(domRootClone, viewRoot);
    renderer.markToSync('children', viewRoot);
    renderer.markToSync('attributes', viewRoot);
    viewRoot.on('change:children', (evt, node)=>renderer.markToSync('children', node));
    viewRoot.on('change:attributes', (evt, node)=>renderer.markToSync('attributes', node));
    viewRoot.on('change:text', (evt, node)=>renderer.markToSync('text', node));
    renderer.render();
    editor.editing.view.on('render', ()=>renderer.render());
    // TODO: Cleanup after destruction.
    editor.on('destroy', ()=>{
        domConverter.unbindDomElement(domRootClone);
    });
    return domRootClone;
}
/**
 * Harvests all web page styles, for instance, to allow re-using them in an `<iframe>` preserving the look of the content.
 *
 * The returned data format is as follows:
 *
 * ```ts
 * [
 * 	'p { color: red; ... } h2 { font-size: 2em; ... } ...',
 * 	'.spacing { padding: 1em; ... }; ...',
 * 	'...',
 * 	{ href: 'http://link.to.external.stylesheet' },
 * 	{ href: '...' }
 * ]
 * ```
 *
 * **Note**: For stylesheets with `href` different than window origin, an object is returned because
 * accessing rules of these styles may cause CORS errors (depending on the configuration of the web page).
 *
 * @internal
 */ function getPageStyles() {
    return Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document.styleSheets).map((styleSheet)=>{
        // CORS
        if (styleSheet.href && !styleSheet.href.startsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window.location.origin)) {
            return {
                href: styleSheet.href
            };
        }
        return Array.from(styleSheet.cssRules).filter((rule)=>!(rule instanceof CSSMediaRule)).map((rule)=>rule.cssText).join(' \n');
    });
}
/**
 * Gets dimensions rectangle according to passed DOM element. Returns whole window's size for `body` element.
 *
 * @internal
 */ function getDomElementRect(domElement) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](domElement === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document.body ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window : domElement);
}
/**
 * Gets client height according to passed DOM element. Returns window's height for `body` element.
 *
 * @internal
 */ function getClientHeight(domElement) {
    return domElement === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document.body ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window.innerHeight : domElement.clientHeight;
}
/**
 * Returns the DOM element itself if it's not a `body` element, whole window otherwise.
 *
 * @internal
 */ function getScrollable(domElement) {
    return domElement === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document.body ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window : domElement;
}
/**
 * The content minimap feature.
 */ class Minimap extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Minimap';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * The reference to the view of the minimap.
	 */ _minimapView;
    /**
	 * The DOM element closest to the editable element of the editor as returned
	 * by {@link module:ui/editorui/editorui~EditorUI#getEditableElement}.
	 */ _scrollableRootAncestor;
    /**
	 * The DOM element closest to the editable element of the editor as returned
	 * by {@link module:ui/editorui/editorui~EditorUI#getEditableElement}.
	 */ _editingRootElement;
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        this._minimapView = null;
        this._scrollableRootAncestor = null;
        this.listenTo(editor.ui, 'ready', this._onUiReady.bind(this));
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this._minimapView.destroy();
        this._minimapView.element.remove();
    }
    /**
	 * Initializes the minimap view element and starts the layout synchronization
	 * on the editing view `render` event.
	 */ _onUiReady() {
        const editor = this.editor;
        // TODO: This will not work with the multi-root editor.
        const editingRootElement = this._editingRootElement = editor.ui.getEditableElement();
        this._scrollableRootAncestor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findClosestScrollableAncestor"])(editingRootElement);
        // DOM root element is not yet attached to the document.
        if (!editingRootElement.ownerDocument.body.contains(editingRootElement)) {
            editor.ui.once('update', this._onUiReady.bind(this));
            return;
        }
        this._initializeMinimapView();
        this.listenTo(editor.editing.view, 'render', ()=>{
            if (editor.state !== 'ready') {
                return;
            }
            this._syncMinimapToEditingRootScrollPosition();
        });
        this._syncMinimapToEditingRootScrollPosition();
    }
    /**
	 * Initializes the minimap view and attaches listeners that make it responsive to the environment (document)
	 * but also allow the minimap to control the document (scroll position).
	 */ _initializeMinimapView() {
        const editor = this.editor;
        const locale = editor.locale;
        const useSimplePreview = editor.config.get('minimap.useSimplePreview');
        // TODO: Throw an error if there is no `minimap` in config.
        const minimapContainerElement = editor.config.get('minimap.container');
        const scrollableRootAncestor = this._scrollableRootAncestor;
        // TODO: This should be dynamic, the root width could change as the viewport scales if not fixed unit.
        const editingRootElementWidth = getDomElementRect(this._editingRootElement).width;
        const minimapContainerWidth = getDomElementRect(minimapContainerElement).width;
        const minimapScaleRatio = minimapContainerWidth / editingRootElementWidth;
        const minimapView = this._minimapView = new MinimapView({
            locale,
            scaleRatio: minimapScaleRatio,
            pageStyles: getPageStyles(),
            extraClasses: editor.config.get('minimap.extraClasses'),
            useSimplePreview,
            domRootClone: cloneEditingViewDomRoot(editor)
        });
        minimapView.render();
        // Scrollable ancestor scroll -> minimap position update.
        minimapView.listenTo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document, 'scroll', (evt, data)=>{
            if (scrollableRootAncestor === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document.body) {
                if (data.target !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].document) {
                    return;
                }
            } else if (data.target !== scrollableRootAncestor) {
                return;
            }
            this._syncMinimapToEditingRootScrollPosition();
        }, {
            useCapture: true,
            usePassive: true
        });
        // Viewport resize -> minimap position update.
        minimapView.listenTo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window, 'resize', ()=>{
            this._syncMinimapToEditingRootScrollPosition();
        });
        // Dragging the visible content area -> document (scrollable) position update.
        minimapView.on('drag', (evt, movementY)=>{
            let movementYPercentage;
            if (minimapView.scrollHeight === 0) {
                movementYPercentage = 0;
            } else {
                movementYPercentage = movementY / minimapView.scrollHeight;
            }
            const absoluteScrollProgress = movementYPercentage * (scrollableRootAncestor.scrollHeight - getClientHeight(scrollableRootAncestor));
            const scrollable = getScrollable(scrollableRootAncestor);
            scrollable.scrollBy(0, Math.round(absoluteScrollProgress));
        });
        // Clicking the minimap -> center the document (scrollable) to the corresponding position.
        minimapView.on('click', (evt, percentage)=>{
            const absoluteScrollProgress = percentage * scrollableRootAncestor.scrollHeight;
            const scrollable = getScrollable(scrollableRootAncestor);
            scrollable.scrollBy(0, Math.round(absoluteScrollProgress));
        });
        minimapContainerElement.appendChild(minimapView.element);
    }
    /**
	 * @private
	 */ _syncMinimapToEditingRootScrollPosition() {
        const editingRootElement = this._editingRootElement;
        const minimapView = this._minimapView;
        minimapView.setContentHeight(editingRootElement.offsetHeight);
        const editingRootRect = getDomElementRect(editingRootElement);
        const scrollableRootAncestorRect = getDomElementRect(this._scrollableRootAncestor);
        let scrollProgress;
        // @if CK_DEBUG_MINIMAP // RectDrawer.clear();
        // @if CK_DEBUG_MINIMAP // RectDrawer.draw( scrollableRootAncestorRect, { outlineColor: 'red' }, 'scrollableRootAncestor' );
        // @if CK_DEBUG_MINIMAP // RectDrawer.draw( editingRootRect, { outlineColor: 'green' }, 'editingRoot' );
        // The root is completely visible in the scrollable ancestor.
        if (scrollableRootAncestorRect.contains(editingRootRect)) {
            scrollProgress = 0;
        } else {
            if (editingRootRect.top > scrollableRootAncestorRect.top) {
                scrollProgress = 0;
            } else {
                scrollProgress = (editingRootRect.top - scrollableRootAncestorRect.top) / (scrollableRootAncestorRect.height - editingRootRect.height);
                scrollProgress = Math.max(0, Math.min(scrollProgress, 1));
            }
        }
        // The intersection helps to change the tracker height when there is a lot of padding around the root.
        // Note: It is **essential** that the height is set first because the progress depends on the correct tracker height.
        minimapView.setPositionTrackerHeight(scrollableRootAncestorRect.getIntersection(editingRootRect).height);
        minimapView.setScrollProgress(scrollProgress);
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-page-break/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "PageBreak": (()=>PageBreak),
    "PageBreakEditing": (()=>PageBreakEditing),
    "PageBreakUI": (()=>PageBreakUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-widget/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
;
;
;
/**
 * The page break command.
 *
 * The command is registered by {@link module:page-break/pagebreakediting~PageBreakEditing} as `'pageBreak'`.
 *
 * To insert a page break at the current selection, execute the command:
 *
 *		editor.execute( 'pageBreak' );
 */ class PageBreakCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const schema = model.schema;
        const selection = model.document.selection;
        this.isEnabled = isPageBreakAllowedInParent(selection, schema, model);
    }
    /**
	 * Executes the command.
	 *
	 * @fires execute
	 */ execute() {
        const model = this.editor.model;
        model.change((writer)=>{
            const pageBreakElement = writer.createElement('pageBreak');
            model.insertObject(pageBreakElement, null, null, {
                setSelection: 'after'
            });
        });
    }
}
/**
 * Checks if a page break is allowed by the schema in the optimal insertion parent.
 */ function isPageBreakAllowedInParent(selection, schema, model) {
    const parent = getInsertPageBreakParent(selection, model);
    return schema.checkChild(parent, 'pageBreak');
}
/**
 * Returns a node that will be used to insert a page break with `model.insertContent` to check if the page break can be placed there.
 */ function getInsertPageBreakParent(selection, model) {
    const insertionRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findOptimalInsertionRange"])(selection, model);
    const parent = insertionRange.start.parent;
    if (parent.isEmpty && !parent.is('element', '$root')) {
        return parent.parent;
    }
    return parent;
}
/**
 * The page break editing feature.
 */ class PageBreakEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'PageBreakEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        const t = editor.t;
        const conversion = editor.conversion;
        schema.register('pageBreak', {
            inheritAllFrom: '$blockObject'
        });
        conversion.for('dataDowncast').elementToStructure({
            model: 'pageBreak',
            view: (modelElement, { writer })=>{
                const divElement = writer.createContainerElement('div', {
                    class: 'page-break',
                    // If user has no `.ck-content` styles, it should always break a page during print.
                    style: 'page-break-after: always'
                }, // https://github.com/ckeditor/ckeditor5-page-break/pull/1#discussion_r328934062.
                writer.createContainerElement('span', {
                    style: 'display: none'
                }));
                return divElement;
            }
        });
        conversion.for('editingDowncast').elementToStructure({
            model: 'pageBreak',
            view: (modelElement, { writer })=>{
                const label = t('Page break');
                const viewWrapper = writer.createContainerElement('div');
                const viewLabelElement = writer.createRawElement('span', {
                    class: 'page-break__label'
                }, function(domElement) {
                    domElement.innerText = t('Page break');
                });
                writer.addClass('page-break', viewWrapper);
                writer.insert(writer.createPositionAt(viewWrapper, 0), viewLabelElement);
                return toPageBreakWidget(viewWrapper, writer, label);
            }
        });
        conversion.for('upcast').elementToElement({
            view: (element)=>{
                // For upcast conversion it's enough if we check for element style and verify if it's empty
                // or contains only hidden span element.
                const hasPageBreakBefore = element.getStyle('page-break-before') == 'always';
                const hasPageBreakAfter = element.getStyle('page-break-after') == 'always';
                if (!hasPageBreakBefore && !hasPageBreakAfter) {
                    return null;
                }
                // The "page break" div accepts only single child or no child at all.
                if (element.childCount == 1) {
                    const viewSpan = element.getChild(0);
                    // The child must be the "span" element that is not displayed.
                    if (!viewSpan.is('element', 'span') || viewSpan.getStyle('display') != 'none') {
                        return null;
                    }
                } else if (element.childCount > 1) {
                    return null;
                }
                return {
                    name: true
                };
            },
            model: 'pageBreak',
            // This conversion must be checked before <br> conversion because some editors use
            // <br style="page-break-before:always"> as a page break marker.
            converterPriority: 'high'
        });
        editor.commands.add('pageBreak', new PageBreakCommand(editor));
    }
}
/**
 * Converts a given {@link module:engine/view/element~Element} to a page break widget:
 * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to
 *   recognize the page break widget element.
 * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.
 */ function toPageBreakWidget(viewElement, writer, label) {
    writer.setCustomProperty('pageBreak', true, viewElement);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toWidget"])(viewElement, writer, {
        label
    });
}
var pageBreakIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M3.598.687h1.5v5h-1.5zm14.5 0h1.5v5h-1.5z\"/><path d=\"M19.598 4.187v1.5h-16v-1.5zm-16 14.569h1.5v-5h-1.5zm14.5 0h1.5v-5h-1.5z\"/><path d=\"M19.598 15.256v-1.5h-16v1.5zM5.081 9h6v2h-6zm8 0h6v2h-6zm-9.483 1L0 12.5v-5z\"/></svg>";
/**
 * The page break UI plugin.
 */ class PageBreakUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'PageBreakUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        // Add pageBreak button to feature components.
        editor.ui.componentFactory.add('pageBreak', ()=>{
            const view = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
            view.set({
                tooltip: true
            });
            return view;
        });
        editor.ui.componentFactory.add('menuBar:pageBreak', ()=>this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]));
    }
    /**
	 * Creates a button for page break command to use either in toolbar or in menu bar.
	 */ _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = editor.commands.get('pageBreak');
        const view = new ButtonClass(editor.locale);
        const t = locale.t;
        view.set({
            label: t('Page break'),
            icon: pageBreakIcon
        });
        view.bind('isEnabled').to(command, 'isEnabled');
        // Execute the command.
        this.listenTo(view, 'execute', ()=>{
            editor.execute('pageBreak');
            editor.editing.view.focus();
        });
        return view;
    }
}
/**
 * The page break feature.
 *
 * It provides the possibility to insert a page break into the rich-text editor.
 *
 * For a detailed overview, check the {@glink features/page-break Page break feature} documentation.
 */ class PageBreak extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            PageBreakEditing,
            PageBreakUI,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$widget$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Widget"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'PageBreak';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-paste-from-office/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "MSWordNormalizer": (()=>MSWordNormalizer),
    "PasteFromOffice": (()=>PasteFromOffice),
    "parseHtml": (()=>parseHtml)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$clipboard$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-clipboard/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
;
;
;
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module paste-from-office/filters/bookmark
 */ /**
 * Transforms `<a>` elements which are bookmarks by moving their children after the element.
 */ function transformBookmarks(documentFragment, writer) {
    const elementsToChange = [];
    for (const value of writer.createRangeIn(documentFragment)){
        const element = value.item;
        if (element.is('element', 'a') && !element.hasAttribute('href') && (element.hasAttribute('id') || element.hasAttribute('name'))) {
            elementsToChange.push(element);
        }
    }
    for (const element of elementsToChange){
        const index = element.parent.getChildIndex(element) + 1;
        const children = element.getChildren();
        writer.insertChild(index, children, element.parent);
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module paste-from-office/filters/utils
 */ /**
 * Normalizes CSS length value to 'px'.
 *
 * @internal
 */ function convertCssLengthToPx(value) {
    const numericValue = parseFloat(value);
    if (value.endsWith('pt')) {
        // 1pt = 1in / 72
        return toPx(numericValue * 96 / 72);
    } else if (value.endsWith('pc')) {
        // 1pc = 12pt = 1in / 6.
        return toPx(numericValue * 12 * 96 / 72);
    } else if (value.endsWith('in')) {
        // 1in = 2.54cm = 96px
        return toPx(numericValue * 96);
    } else if (value.endsWith('cm')) {
        // 1cm = 96px / 2.54
        return toPx(numericValue * 96 / 2.54);
    } else if (value.endsWith('mm')) {
        // 1mm = 1cm / 10
        return toPx(numericValue / 10 * 96 / 2.54);
    }
    return value;
}
/**
 * Returns true for value with 'px' unit.
 *
 * @internal
 */ function isPx(value) {
    return value !== undefined && value.endsWith('px');
}
/**
 * Returns a rounded 'px' value.
 *
 * @internal
 */ function toPx(value) {
    return value.toFixed(2).replace(/\.?0+$/, '') + 'px';
}
/**
 * Transforms Word specific list-like elements to the semantic HTML lists.
 *
 * Lists in Word are represented by block elements with special attributes like:
 *
 * ```xml
 * <p class=MsoListParagraphCxSpFirst style='mso-list:l1 level1 lfo1'>...</p> // Paragraph based list.
 * <h1 style='mso-list:l0 level1 lfo1'>...</h1> // Heading 1 based list.
 * ```
 *
 * @param documentFragment The view structure to be transformed.
 * @param stylesString Styles from which list-like elements styling will be extracted.
 */ function transformListItemLikeElementsIntoLists(documentFragment, stylesString, hasMultiLevelListPlugin) {
    if (!documentFragment.childCount) {
        return;
    }
    const writer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UpcastWriter"](documentFragment.document);
    const itemLikeElements = findAllItemLikeElements(documentFragment, writer);
    if (!itemLikeElements.length) {
        return;
    }
    const encounteredLists = {};
    const stack = [];
    for (const itemLikeElement of itemLikeElements){
        if (itemLikeElement.indent !== undefined) {
            if (!isListContinuation(itemLikeElement)) {
                stack.length = 0;
            }
            // Combined list ID for addressing encounter lists counters.
            const originalListId = `${itemLikeElement.id}:${itemLikeElement.indent}`;
            // Normalized list item indentation.
            const indent = Math.min(itemLikeElement.indent - 1, stack.length);
            // Trimming of the list stack on list ID change.
            if (indent < stack.length && stack[indent].id !== itemLikeElement.id) {
                stack.length = indent;
            }
            // Trimming of the list stack on lower indent list encountered.
            if (indent < stack.length - 1) {
                stack.length = indent + 1;
            } else {
                const listStyle = detectListStyle(itemLikeElement, stylesString);
                // Create a new OL/UL if required (greater indent or different list type).
                if (indent > stack.length - 1 || stack[indent].listElement.name != listStyle.type) {
                    // Check if there is some start index to set from a previous list.
                    if (indent == 0 && listStyle.type == 'ol' && itemLikeElement.id !== undefined && encounteredLists[originalListId]) {
                        listStyle.startIndex = encounteredLists[originalListId];
                    }
                    const listElement = createNewEmptyList(listStyle, writer, hasMultiLevelListPlugin);
                    // Apply list padding only if we have margins for the item and the parent item.
                    if (isPx(itemLikeElement.marginLeft) && (indent == 0 || isPx(stack[indent - 1].marginLeft))) {
                        let marginLeft = itemLikeElement.marginLeft;
                        if (indent > 0) {
                            // Convert the padding from absolute to relative.
                            marginLeft = toPx(parseFloat(marginLeft) - parseFloat(stack[indent - 1].marginLeft));
                        }
                        writer.setStyle('padding-left', marginLeft, listElement);
                    }
                    // Insert the new OL/UL.
                    if (stack.length == 0) {
                        const parent = itemLikeElement.element.parent;
                        const index = parent.getChildIndex(itemLikeElement.element) + 1;
                        writer.insertChild(index, listElement, parent);
                    } else {
                        const parentListItems = stack[indent - 1].listItemElements;
                        writer.appendChild(listElement, parentListItems[parentListItems.length - 1]);
                    }
                    // Update the list stack for other items to reference.
                    stack[indent] = {
                        ...itemLikeElement,
                        listElement,
                        listItemElements: []
                    };
                    // Prepare list counter for start index.
                    if (indent == 0 && itemLikeElement.id !== undefined) {
                        encounteredLists[originalListId] = listStyle.startIndex || 1;
                    }
                }
            }
            // Use LI if it is already it or create a new LI element.
            // https://github.com/ckeditor/ckeditor5/issues/15964
            const listItem = itemLikeElement.element.name == 'li' ? itemLikeElement.element : writer.createElement('li');
            // Append the LI to OL/UL.
            writer.appendChild(listItem, stack[indent].listElement);
            stack[indent].listItemElements.push(listItem);
            // Increment list counter.
            if (indent == 0 && itemLikeElement.id !== undefined) {
                encounteredLists[originalListId]++;
            }
            // Append list block to LI.
            if (itemLikeElement.element != listItem) {
                writer.appendChild(itemLikeElement.element, listItem);
            }
            // Clean list block.
            removeBulletElement(itemLikeElement.element, writer);
            writer.removeStyle('text-indent', itemLikeElement.element); // #12361
            writer.removeStyle('margin-left', itemLikeElement.element);
        } else {
            // Other blocks in a list item.
            const stackItem = stack.find((stackItem)=>stackItem.marginLeft == itemLikeElement.marginLeft);
            // This might be a paragraph that has known margin, but it is not a real list block.
            if (stackItem) {
                const listItems = stackItem.listItemElements;
                // Append block to LI.
                writer.appendChild(itemLikeElement.element, listItems[listItems.length - 1]);
                writer.removeStyle('margin-left', itemLikeElement.element);
            } else {
                stack.length = 0;
            }
        }
    }
}
/**
 * Removes paragraph wrapping content inside a list item.
 */ function unwrapParagraphInListItem(documentFragment, writer) {
    for (const value of writer.createRangeIn(documentFragment)){
        const element = value.item;
        if (element.is('element', 'li')) {
            // Google Docs allows for single paragraph inside LI.
            const firstChild = element.getChild(0);
            if (firstChild && firstChild.is('element', 'p')) {
                writer.unwrapElement(firstChild);
            }
        }
    }
}
/**
 * Finds all list-like elements in a given document fragment.
 *
 * @param documentFragment Document fragment in which to look for list-like nodes.
 * @returns Array of found list-like items. Each item is an object containing:
 */ function findAllItemLikeElements(documentFragment, writer) {
    const range = writer.createRangeIn(documentFragment);
    const itemLikeElements = [];
    const foundMargins = new Set();
    for (const item of range.getItems()){
        // https://github.com/ckeditor/ckeditor5/issues/15964
        if (!item.is('element') || !item.name.match(/^(p|h\d+|li|div)$/)) {
            continue;
        }
        // Try to rely on margin-left style to find paragraphs visually aligned with previously encountered list item.
        let marginLeft = getMarginLeftNormalized(item);
        // Ignore margin-left 0 style if there is no MsoList... class.
        if (marginLeft !== undefined && parseFloat(marginLeft) == 0 && !Array.from(item.getClassNames()).find((className)=>className.startsWith('MsoList'))) {
            marginLeft = undefined;
        }
        // List item or a following list item block.
        if (item.hasStyle('mso-list') || marginLeft !== undefined && foundMargins.has(marginLeft)) {
            const itemData = getListItemData(item);
            itemLikeElements.push({
                element: item,
                id: itemData.id,
                order: itemData.order,
                indent: itemData.indent,
                marginLeft
            });
            if (marginLeft !== undefined) {
                foundMargins.add(marginLeft);
            }
        } else {
            foundMargins.clear();
        }
    }
    return itemLikeElements;
}
/**
 * Whether the given element is possibly a list continuation. Previous element was wrapped into a list
 * or the current element already is inside a list.
 */ function isListContinuation(currentItem) {
    const previousSibling = currentItem.element.previousSibling;
    if (!previousSibling) {
        // If it's a li inside ul or ol like in here: https://github.com/ckeditor/ckeditor5/issues/15964.
        return isList(currentItem.element.parent);
    }
    // Even with the same id the list does not have to be continuous (#43).
    return isList(previousSibling);
}
function isList(element) {
    return element.is('element', 'ol') || element.is('element', 'ul');
}
/**
 * Extracts list item style from the provided CSS.
 *
 * List item style is extracted from the CSS stylesheet. Each list with its specific style attribute
 * value (`mso-list:l1 level1 lfo1`) has its dedicated properties in a CSS stylesheet defined with a selector like:
 *
 * ```css
 * @list l1:level1 { ... }
 * ```
 *
 * It contains `mso-level-number-format` property which defines list numbering/bullet style. If this property
 * is not defined it means default `decimal` numbering.
 *
 * Here CSS string representation is used as `mso-level-number-format` property is an invalid CSS property
 * and will be removed during CSS parsing.
 *
 * @param listLikeItem List-like item for which list style will be searched for. Usually
 * a result of `findAllItemLikeElements()` function.
 * @param stylesString CSS stylesheet.
 * @returns An object with properties:
 *
 * * type - List type, could be `ul` or `ol`.
 * * startIndex - List start index, valid only for ordered lists.
 * * style - List style, for example: `decimal`, `lower-roman`, etc. It is extracted
 *     directly from Word stylesheet and adjusted to represent proper values for the CSS `list-style-type` property.
 *     If it cannot be adjusted, the `null` value is returned.
 */ function detectListStyle(listLikeItem, stylesString) {
    const listStyleRegexp = new RegExp(`@list l${listLikeItem.id}:level${listLikeItem.indent}\\s*({[^}]*)`, 'gi');
    const listStyleTypeRegex = /mso-level-number-format:([^;]{0,100});/gi;
    const listStartIndexRegex = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi;
    const legalStyleListRegex = new RegExp(`@list\\s+l${listLikeItem.id}:level\\d\\s*{[^{]*mso-level-text:"%\\d\\\\.`, 'gi');
    const multiLevelNumberFormatTypeRegex = new RegExp(`@list l${listLikeItem.id}:level\\d\\s*{[^{]*mso-level-number-format:`, 'gi');
    const legalStyleListMatch = legalStyleListRegex.exec(stylesString);
    const multiLevelNumberFormatMatch = multiLevelNumberFormatTypeRegex.exec(stylesString);
    // Multi level lists in Word have mso-level-number-format attribute except legal lists,
    // so we used that. If list has legal list match and doesn't has mso-level-number-format
    // then this is legal-list.
    const islegalStyleList = legalStyleListMatch && !multiLevelNumberFormatMatch;
    const listStyleMatch = listStyleRegexp.exec(stylesString);
    let listStyleType = 'decimal'; // Decimal is default one.
    let type = 'ol'; // <ol> is default list.
    let startIndex = null;
    if (listStyleMatch && listStyleMatch[1]) {
        const listStyleTypeMatch = listStyleTypeRegex.exec(listStyleMatch[1]);
        if (listStyleTypeMatch && listStyleTypeMatch[1]) {
            listStyleType = listStyleTypeMatch[1].trim();
            type = listStyleType !== 'bullet' && listStyleType !== 'image' ? 'ol' : 'ul';
        }
        // Styles for the numbered lists are always defined in the Word CSS stylesheet.
        // Unordered lists MAY contain a value for the Word CSS definition `mso-level-text` but sometimes
        // this tag is missing. And because of that, we cannot depend on that. We need to predict the list style value
        // based on the list style marker element.
        if (listStyleType === 'bullet') {
            const bulletedStyle = findBulletedListStyle(listLikeItem.element);
            if (bulletedStyle) {
                listStyleType = bulletedStyle;
            }
        } else {
            const listStartIndexMatch = listStartIndexRegex.exec(listStyleMatch[1]);
            if (listStartIndexMatch && listStartIndexMatch[1]) {
                startIndex = parseInt(listStartIndexMatch[1]);
            }
        }
        if (islegalStyleList) {
            type = 'ol';
        }
    }
    return {
        type,
        startIndex,
        style: mapListStyleDefinition(listStyleType),
        isLegalStyleList: islegalStyleList
    };
}
/**
 * Tries to extract the `list-style-type` value based on the marker element for bulleted list.
 */ function findBulletedListStyle(element) {
    // https://github.com/ckeditor/ckeditor5/issues/15964
    if (element.name == 'li' && element.parent.name == 'ul' && element.parent.hasAttribute('type')) {
        return element.parent.getAttribute('type');
    }
    const listMarkerElement = findListMarkerNode(element);
    if (!listMarkerElement) {
        return null;
    }
    const listMarker = listMarkerElement._data;
    if (listMarker === 'o') {
        return 'circle';
    } else if (listMarker === '·') {
        return 'disc';
    } else if (listMarker === '§') {
        return 'square';
    }
    return null;
}
/**
 * Tries to find a text node that represents the marker element (list-style-type).
 */ function findListMarkerNode(element) {
    // If the first child is a text node, it is the data for the element.
    // The list-style marker is not present here.
    if (element.getChild(0).is('$text')) {
        return null;
    }
    for (const childNode of element.getChildren()){
        // The list-style marker will be inside the `<span>` element. Let's ignore all non-span elements.
        // It may happen that the `<a>` element is added as the first child. Most probably, it's an anchor element.
        if (!childNode.is('element', 'span')) {
            continue;
        }
        const textNodeOrElement = childNode.getChild(0);
        if (!textNodeOrElement) {
            continue;
        }
        // If already found the marker element, use it.
        if (textNodeOrElement.is('$text')) {
            return textNodeOrElement;
        }
        return textNodeOrElement.getChild(0);
    }
    /* istanbul ignore next -- @preserve */ return null;
}
/**
 * Parses the `list-style-type` value extracted directly from the Word CSS stylesheet and returns proper CSS definition.
 */ function mapListStyleDefinition(value) {
    if (value.startsWith('arabic-leading-zero')) {
        return 'decimal-leading-zero';
    }
    switch(value){
        case 'alpha-upper':
            return 'upper-alpha';
        case 'alpha-lower':
            return 'lower-alpha';
        case 'roman-upper':
            return 'upper-roman';
        case 'roman-lower':
            return 'lower-roman';
        case 'circle':
        case 'disc':
        case 'square':
            return value;
        default:
            return null;
    }
}
/**
 * Creates a new list OL/UL element.
 */ function createNewEmptyList(listStyle, writer, hasMultiLevelListPlugin) {
    const list = writer.createElement(listStyle.type);
    // We do not support modifying the marker for a particular list item.
    // Set the value for the `list-style-type` property directly to the list container.
    if (listStyle.style) {
        writer.setStyle('list-style-type', listStyle.style, list);
    }
    if (listStyle.startIndex && listStyle.startIndex > 1) {
        writer.setAttribute('start', listStyle.startIndex, list);
    }
    if (listStyle.isLegalStyleList && hasMultiLevelListPlugin) {
        writer.addClass('legal-list', list);
    }
    return list;
}
/**
 * Extracts list item information from Word specific list-like element style:
 *
 * ```
 * `style="mso-list:l1 level1 lfo1"`
 * ```
 *
 * where:
 *
 * ```
 * * `l1` is a list id (however it does not mean this is a continuous list - see #43),
 * * `level1` is a list item indentation level,
 * * `lfo1` is a list insertion order in a document.
 * ```
 *
 * @param element Element from which style data is extracted.
 */ function getListItemData(element) {
    const listStyle = element.getStyle('mso-list');
    if (listStyle === undefined) {
        return {};
    }
    const idMatch = listStyle.match(/(^|\s{1,100})l(\d+)/i);
    const orderMatch = listStyle.match(/\s{0,100}lfo(\d+)/i);
    const indentMatch = listStyle.match(/\s{0,100}level(\d+)/i);
    if (idMatch && orderMatch && indentMatch) {
        return {
            id: idMatch[2],
            order: orderMatch[1],
            indent: parseInt(indentMatch[1])
        };
    }
    return {
        indent: 1 // Handle empty mso-list style as a marked for default list item.
    };
}
/**
 * Removes span with a numbering/bullet from a given element.
 */ function removeBulletElement(element, writer) {
    // Matcher for finding `span` elements holding lists numbering/bullets.
    const bulletMatcher = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matcher"]({
        name: 'span',
        styles: {
            'mso-list': 'Ignore'
        }
    });
    const range = writer.createRangeIn(element);
    for (const value of range){
        if (value.type === 'elementStart' && bulletMatcher.match(value.item)) {
            writer.remove(value.item);
        }
    }
}
/**
 * Returns element left margin normalized to 'px' if possible.
 */ function getMarginLeftNormalized(element) {
    const value = element.getStyle('margin-left');
    if (value === undefined || value.endsWith('px')) {
        return value;
    }
    return convertCssLengthToPx(value);
}
/**
 * Replaces source attribute of all `<img>` elements representing regular
 * images (not the Word shapes) with inlined base64 image representation extracted from RTF or Blob data.
 *
 * @param documentFragment Document fragment on which transform images.
 * @param rtfData The RTF data from which images representation will be used.
 */ function replaceImagesSourceWithBase64(documentFragment, rtfData) {
    if (!documentFragment.childCount) {
        return;
    }
    const upcastWriter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UpcastWriter"](documentFragment.document);
    const shapesIds = findAllShapesIds(documentFragment, upcastWriter);
    removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, upcastWriter);
    insertMissingImgs(shapesIds, documentFragment, upcastWriter);
    removeAllShapeElements(documentFragment, upcastWriter);
    const images = findAllImageElementsWithLocalSource(documentFragment, upcastWriter);
    if (images.length) {
        replaceImagesFileSourceWithInlineRepresentation(images, extractImageDataFromRtf(rtfData), upcastWriter);
    }
}
/**
 * Converts given HEX string to base64 representation.
 *
 * @internal
 * @param hexString The HEX string to be converted.
 * @returns Base64 representation of a given HEX string.
 */ function _convertHexToBase64(hexString) {
    return btoa(hexString.match(/\w{2}/g).map((char)=>{
        return String.fromCharCode(parseInt(char, 16));
    }).join(''));
}
/**
 * Finds all shapes (`<v:*>...</v:*>`) ids. Shapes can represent images (canvas)
 * or Word shapes (which does not have RTF or Blob representation).
 *
 * @param documentFragment Document fragment from which to extract shape ids.
 * @returns Array of shape ids.
 */ function findAllShapesIds(documentFragment, writer) {
    const range = writer.createRangeIn(documentFragment);
    const shapeElementsMatcher = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matcher"]({
        name: /v:(.+)/
    });
    const shapesIds = [];
    for (const value of range){
        if (value.type != 'elementStart') {
            continue;
        }
        const el = value.item;
        const previousSibling = el.previousSibling;
        const prevSiblingName = previousSibling && previousSibling.is('element') ? previousSibling.name : null;
        // List of ids which should not be considered as shapes.
        // https://github.com/ckeditor/ckeditor5/pull/15847#issuecomment-1941543983
        const exceptionIds = [
            'Chart'
        ];
        const isElementAShape = shapeElementsMatcher.match(el);
        const hasElementGfxdataAttribute = el.getAttribute('o:gfxdata');
        const isPreviousSiblingAShapeType = prevSiblingName === 'v:shapetype';
        const isElementIdInExceptionsArray = hasElementGfxdataAttribute && exceptionIds.some((item)=>el.getAttribute('id').includes(item));
        // If shape element has 'o:gfxdata' attribute and is not directly before
        // `<v:shapetype>` element it means that it represents a Word shape.
        if (isElementAShape && hasElementGfxdataAttribute && !isPreviousSiblingAShapeType && !isElementIdInExceptionsArray) {
            shapesIds.push(value.item.getAttribute('id'));
        }
    }
    return shapesIds;
}
/**
 * Removes all `<img>` elements which represents Word shapes and not regular images.
 *
 * @param shapesIds Shape ids which will be checked against `<img>` elements.
 * @param documentFragment Document fragment from which to remove `<img>` elements.
 */ function removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, writer) {
    const range = writer.createRangeIn(documentFragment);
    const imageElementsMatcher = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matcher"]({
        name: 'img'
    });
    const imgs = [];
    for (const value of range){
        if (value.item.is('element') && imageElementsMatcher.match(value.item)) {
            const el = value.item;
            const shapes = el.getAttribute('v:shapes') ? el.getAttribute('v:shapes').split(' ') : [];
            if (shapes.length && shapes.every((shape)=>shapesIds.indexOf(shape) > -1)) {
                imgs.push(el);
            // Shapes may also have empty source while content is paste in some browsers (Safari).
            } else if (!el.getAttribute('src')) {
                imgs.push(el);
            }
        }
    }
    for (const img of imgs){
        writer.remove(img);
    }
}
/**
 * Removes all shape elements (`<v:*>...</v:*>`) so they do not pollute the output structure.
 *
 * @param documentFragment Document fragment from which to remove shape elements.
 */ function removeAllShapeElements(documentFragment, writer) {
    const range = writer.createRangeIn(documentFragment);
    const shapeElementsMatcher = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matcher"]({
        name: /v:(.+)/
    });
    const shapes = [];
    for (const value of range){
        if (value.type == 'elementStart' && shapeElementsMatcher.match(value.item)) {
            shapes.push(value.item);
        }
    }
    for (const shape of shapes){
        writer.remove(shape);
    }
}
/**
 * Inserts `img` tags if there is none after a shape.
 */ function insertMissingImgs(shapeIds, documentFragment, writer) {
    const range = writer.createRangeIn(documentFragment);
    const shapes = [];
    for (const value of range){
        if (value.type == 'elementStart' && value.item.is('element', 'v:shape')) {
            const id = value.item.getAttribute('id');
            if (shapeIds.includes(id)) {
                continue;
            }
            if (!containsMatchingImg(value.item.parent.getChildren(), id)) {
                shapes.push(value.item);
            }
        }
    }
    for (const shape of shapes){
        const attrs = {
            src: findSrc(shape)
        };
        if (shape.hasAttribute('alt')) {
            attrs.alt = shape.getAttribute('alt');
        }
        const img = writer.createElement('img', attrs);
        writer.insertChild(shape.index + 1, img, shape.parent);
    }
    function containsMatchingImg(nodes, id) {
        for (const node of nodes){
            /* istanbul ignore else -- @preserve */ if (node.is('element')) {
                if (node.name == 'img' && node.getAttribute('v:shapes') == id) {
                    return true;
                }
                if (containsMatchingImg(node.getChildren(), id)) {
                    return true;
                }
            }
        }
        return false;
    }
    function findSrc(shape) {
        for (const child of shape.getChildren()){
            /* istanbul ignore else -- @preserve */ if (child.is('element') && child.getAttribute('src')) {
                return child.getAttribute('src');
            }
        }
    }
}
/**
 * Finds all `<img>` elements in a given document fragment which have source pointing to local `file://` resource.
 *
 * @param documentFragment Document fragment in which to look for `<img>` elements.
 * @returns result All found images grouped by source type.
 */ function findAllImageElementsWithLocalSource(documentFragment, writer) {
    const range = writer.createRangeIn(documentFragment);
    const imageElementsMatcher = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matcher"]({
        name: 'img'
    });
    const imgs = [];
    for (const value of range){
        if (value.item.is('element') && imageElementsMatcher.match(value.item)) {
            if (value.item.getAttribute('src').startsWith('file://')) {
                imgs.push(value.item);
            }
        }
    }
    return imgs;
}
/**
 * Extracts all images HEX representations from a given RTF data.
 *
 * @param rtfData The RTF data from which to extract images HEX representation.
 * @returns Array of found HEX representations. Each array item is an object containing:
 *
 * * hex Image representation in HEX format.
 * * type Type of image, `image/png` or `image/jpeg`.
 */ function extractImageDataFromRtf(rtfData) {
    if (!rtfData) {
        return [];
    }
    const regexPictureHeader = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/;
    const regexPicture = new RegExp('(?:(' + regexPictureHeader.source + '))([\\da-fA-F\\s]+)\\}', 'g');
    const images = rtfData.match(regexPicture);
    const result = [];
    if (images) {
        for (const image of images){
            let imageType = false;
            if (image.includes('\\pngblip')) {
                imageType = 'image/png';
            } else if (image.includes('\\jpegblip')) {
                imageType = 'image/jpeg';
            }
            if (imageType) {
                result.push({
                    hex: image.replace(regexPictureHeader, '').replace(/[^\da-fA-F]/g, ''),
                    type: imageType
                });
            }
        }
    }
    return result;
}
/**
 * Replaces `src` attribute value of all given images with the corresponding base64 image representation.
 *
 * @param imageElements Array of image elements which will have its source replaced.
 * @param imagesHexSources Array of images hex sources (usually the result of `extractImageDataFromRtf()` function).
 * The array should be the same length as `imageElements` parameter.
 */ function replaceImagesFileSourceWithInlineRepresentation(imageElements, imagesHexSources, writer) {
    // Assume there is an equal amount of image elements and images HEX sources so they can be matched accordingly based on existing order.
    if (imageElements.length === imagesHexSources.length) {
        for(let i = 0; i < imageElements.length; i++){
            const newSrc = `data:${imagesHexSources[i].type};base64,${_convertHexToBase64(imagesHexSources[i].hex)}`;
            writer.setAttribute('src', newSrc, imageElements[i]);
        }
    }
}
/**
 * Cleanup MS attributes like styles, attributes and elements.
 *
 * @param documentFragment element `data.content` obtained from clipboard.
 */ function removeMSAttributes(documentFragment) {
    const elementsToUnwrap = [];
    const writer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UpcastWriter"](documentFragment.document);
    for (const { item } of writer.createRangeIn(documentFragment)){
        if (!item.is('element')) {
            continue;
        }
        for (const className of item.getClassNames()){
            if (/\bmso/gi.exec(className)) {
                writer.removeClass(className, item);
            }
        }
        for (const styleName of item.getStyleNames()){
            if (/\bmso/gi.exec(styleName)) {
                writer.removeStyle(styleName, item);
            }
        }
        if (item.is('element', 'w:sdt') || item.is('element', 'w:sdtpr') && item.isEmpty || item.is('element', 'o:p') && item.isEmpty) {
            elementsToUnwrap.push(item);
        }
    }
    for (const item of elementsToUnwrap){
        const itemParent = item.parent;
        const childIndex = itemParent.getChildIndex(item);
        writer.insertChild(childIndex, item.getChildren(), itemParent);
        writer.remove(item);
    }
}
const msWordMatch1 = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i;
const msWordMatch2 = /xmlns:o="urn:schemas-microsoft-com/i;
/**
 * Normalizer for the content pasted from Microsoft Word.
 */ class MSWordNormalizer {
    document;
    hasMultiLevelListPlugin;
    /**
	 * Creates a new `MSWordNormalizer` instance.
	 *
	 * @param document View document.
	 */ constructor(document, hasMultiLevelListPlugin = false){
        this.document = document;
        this.hasMultiLevelListPlugin = hasMultiLevelListPlugin;
    }
    /**
	 * @inheritDoc
	 */ isActive(htmlString) {
        return msWordMatch1.test(htmlString) || msWordMatch2.test(htmlString);
    }
    /**
	 * @inheritDoc
	 */ execute(data) {
        const writer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UpcastWriter"](this.document);
        const { body: documentFragment, stylesString } = data._parsedData;
        transformBookmarks(documentFragment, writer);
        transformListItemLikeElementsIntoLists(documentFragment, stylesString, this.hasMultiLevelListPlugin);
        replaceImagesSourceWithBase64(documentFragment, data.dataTransfer.getData('text/rtf'));
        removeMSAttributes(documentFragment);
        data.content = documentFragment;
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module paste-from-office/filters/removeboldwrapper
 */ /**
 * Removes the `<b>` tag wrapper added by Google Docs to a copied content.
 *
 * @param documentFragment element `data.content` obtained from clipboard
 */ function removeBoldWrapper(documentFragment, writer) {
    for (const child of documentFragment.getChildren()){
        if (child.is('element', 'b') && child.getStyle('font-weight') === 'normal') {
            const childIndex = documentFragment.getChildIndex(child);
            writer.remove(child);
            writer.insertChild(childIndex, child.getChildren(), documentFragment);
        }
    }
}
/**
 * Transforms `<br>` elements that are siblings to some block element into a paragraphs.
 *
 * @param documentFragment The view structure to be transformed.
 */ function transformBlockBrsToParagraphs(documentFragment, writer) {
    const viewDocument = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewDocument"](writer.document.stylesProcessor);
    const domConverter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DomConverter"](viewDocument, {
        renderingMode: 'data'
    });
    const blockElements = domConverter.blockElements;
    const inlineObjectElements = domConverter.inlineObjectElements;
    const elementsToReplace = [];
    for (const value of writer.createRangeIn(documentFragment)){
        const element = value.item;
        if (element.is('element', 'br')) {
            const nextSibling = findSibling(element, 'forward', writer, {
                blockElements,
                inlineObjectElements
            });
            const previousSibling = findSibling(element, 'backward', writer, {
                blockElements,
                inlineObjectElements
            });
            const nextSiblingIsBlock = isBlockViewElement(nextSibling, blockElements);
            const previousSiblingIsBlock = isBlockViewElement(previousSibling, blockElements);
            // If the <br> is surrounded by blocks then convert it to a paragraph:
            // * <p>foo</p>[<br>]<p>bar</p> -> <p>foo</p>[<p></p>]<p>bar</p>
            // * <p>foo</p>[<br>] -> <p>foo</p>[<p></p>]
            // * [<br>]<p>foo</p> -> [<p></p>]<p>foo</p>
            if (previousSiblingIsBlock || nextSiblingIsBlock) {
                elementsToReplace.push(element);
            }
        }
    }
    for (const element of elementsToReplace){
        if (element.hasClass('Apple-interchange-newline')) {
            writer.remove(element);
        } else {
            writer.replace(element, writer.createElement('p'));
        }
    }
}
/**
 * Returns sibling node, threats inline elements as transparent (but should stop on an inline objects).
 */ function findSibling(viewElement, direction, writer, { blockElements, inlineObjectElements }) {
    let position = writer.createPositionAt(viewElement, direction == 'forward' ? 'after' : 'before');
    // Find first position that is just before a first:
    // * text node,
    // * block element,
    // * inline object element.
    // It's ignoring any inline (non-object) elements like span, strong, etc.
    position = position.getLastMatchingPosition(({ item })=>item.is('element') && !blockElements.includes(item.name) && !inlineObjectElements.includes(item.name), {
        direction
    });
    return direction == 'forward' ? position.nodeAfter : position.nodeBefore;
}
/**
 * Returns true for view elements that are listed as block view elements.
 */ function isBlockViewElement(node, blockElements) {
    return !!node && node.is('element') && blockElements.includes(node.name);
}
const googleDocsMatch = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
/**
 * Normalizer for the content pasted from Google Docs.
 */ class GoogleDocsNormalizer {
    document;
    /**
	 * Creates a new `GoogleDocsNormalizer` instance.
	 *
	 * @param document View document.
	 */ constructor(document){
        this.document = document;
    }
    /**
	 * @inheritDoc
	 */ isActive(htmlString) {
        return googleDocsMatch.test(htmlString);
    }
    /**
	 * @inheritDoc
	 */ execute(data) {
        const writer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UpcastWriter"](this.document);
        const { body: documentFragment } = data._parsedData;
        removeBoldWrapper(documentFragment, writer);
        unwrapParagraphInListItem(documentFragment, writer);
        transformBlockBrsToParagraphs(documentFragment, writer);
        data.content = documentFragment;
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module paste-from-office/filters/removexmlns
 */ /**
 * Removes the `xmlns` attribute from table pasted from Google Sheets.
 *
 * @param documentFragment element `data.content` obtained from clipboard
 */ function removeXmlns(documentFragment, writer) {
    for (const child of documentFragment.getChildren()){
        if (child.is('element', 'table') && child.hasAttribute('xmlns')) {
            writer.removeAttribute('xmlns', child);
        }
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module paste-from-office/filters/removegooglesheetstag
 */ /**
 * Removes the `<google-sheets-html-origin>` tag wrapper added by Google Sheets to a copied content.
 *
 * @param documentFragment element `data.content` obtained from clipboard
 */ function removeGoogleSheetsTag(documentFragment, writer) {
    for (const child of documentFragment.getChildren()){
        if (child.is('element', 'google-sheets-html-origin')) {
            const childIndex = documentFragment.getChildIndex(child);
            writer.remove(child);
            writer.insertChild(childIndex, child.getChildren(), documentFragment);
        }
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module paste-from-office/filters/removeinvalidtablewidth
 */ /**
 * Removes the `width:0px` style from table pasted from Google Sheets.
 *
 * @param documentFragment element `data.content` obtained from clipboard
 */ function removeInvalidTableWidth(documentFragment, writer) {
    for (const child of documentFragment.getChildren()){
        if (child.is('element', 'table') && child.getStyle('width') === '0px') {
            writer.removeStyle('width', child);
        }
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module paste-from-office/filters/removestyleblock
 */ /**
 * Removes `<style>` block added by Google Sheets to a copied content.
 *
 * @param documentFragment element `data.content` obtained from clipboard
 */ function removeStyleBlock(documentFragment, writer) {
    for (const child of Array.from(documentFragment.getChildren())){
        if (child.is('element', 'style')) {
            writer.remove(child);
        }
    }
}
const googleSheetsMatch = /<google-sheets-html-origin/i;
/**
 * Normalizer for the content pasted from Google Sheets.
 */ class GoogleSheetsNormalizer {
    document;
    /**
	 * Creates a new `GoogleSheetsNormalizer` instance.
	 *
	 * @param document View document.
	 */ constructor(document){
        this.document = document;
    }
    /**
	 * @inheritDoc
	 */ isActive(htmlString) {
        return googleSheetsMatch.test(htmlString);
    }
    /**
	 * @inheritDoc
	 */ execute(data) {
        const writer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UpcastWriter"](this.document);
        const { body: documentFragment } = data._parsedData;
        removeGoogleSheetsTag(documentFragment, writer);
        removeXmlns(documentFragment, writer);
        removeInvalidTableWidth(documentFragment, writer);
        removeStyleBlock(documentFragment, writer);
        data.content = documentFragment;
    }
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module paste-from-office/filters/space
 */ /**
 * Replaces last space preceding elements closing tag with `&nbsp;`. Such operation prevents spaces from being removed
 * during further DOM/View processing (see especially {@link module:engine/view/domconverter~DomConverter#_processDomInlineNodes}).
 * This method also takes into account Word specific `<o:p></o:p>` empty tags.
 * Additionally multiline sequences of spaces and new lines between tags are removed (see #39 and #40).
 *
 * @param htmlString HTML string in which spacing should be normalized.
 * @returns Input HTML with spaces normalized.
 */ function normalizeSpacing(htmlString) {
    // Run normalizeSafariSpaceSpans() two times to cover nested spans.
    return normalizeSafariSpaceSpans(normalizeSafariSpaceSpans(htmlString)) // Remove all \r\n from "spacerun spans" so the last replace line doesn't strip all whitespaces.
    .replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, '$1$2').replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, '').replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, '$1 $2').replace(/ <\//g, '\u00A0</').replace(/ <o:p><\/o:p>/g, '\u00A0<o:p></o:p>') // Remove <o:p> block filler from empty paragraph. Safari uses \u00A0 instead of &nbsp;.
    .replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, '') // Remove all whitespaces when they contain any \r or \n.
    .replace(/>([^\S\r\n]*[\r\n]\s*)</g, '><');
}
/**
 * Normalizes spacing in special Word `spacerun spans` (`<span style='mso-spacerun:yes'>\s+</span>`) by replacing
 * all spaces with `&nbsp; ` pairs. This prevents spaces from being removed during further DOM/View processing
 * (see especially {@link module:engine/view/domconverter~DomConverter#_processDomInlineNodes}).
 *
 * @param htmlDocument Native `Document` object in which spacing should be normalized.
 */ function normalizeSpacerunSpans(htmlDocument) {
    htmlDocument.querySelectorAll('span[style*=spacerun]').forEach((el)=>{
        const htmlElement = el;
        const innerTextLength = htmlElement.innerText.length || 0;
        htmlElement.innerText = Array(innerTextLength + 1).join('\u00A0 ').substr(0, innerTextLength);
    });
}
/**
 * Normalizes specific spacing generated by Safari when content pasted from Word (`<span class="Apple-converted-space"> </span>`)
 * by replacing all spaces sequences longer than 1 space with `&nbsp; ` pairs. This prevents spaces from being removed during
 * further DOM/View processing (see especially {@link module:engine/view/domconverter~DomConverter#_processDataFromDomText}).
 *
 * This function is similar to {@link module:clipboard/utils/normalizeclipboarddata normalizeClipboardData util} but uses
 * regular spaces / &nbsp; sequence for replacement.
 *
 * @param htmlString HTML string in which spacing should be normalized
 * @returns Input HTML with spaces normalized.
 */ function normalizeSafariSpaceSpans(htmlString) {
    return htmlString.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (fullMatch, spaces)=>{
        return spaces.length === 1 ? ' ' : Array(spaces.length + 1).join('\u00A0 ').substr(0, spaces.length);
    });
}
/**
 * Parses the provided HTML extracting contents of `<body>` and `<style>` tags.
 *
 * @param htmlString HTML string to be parsed.
 */ function parseHtml(htmlString, stylesProcessor) {
    const domParser = new DOMParser();
    // Remove Word specific "if comments" so content inside is not omitted by the parser.
    htmlString = htmlString.replace(/<!--\[if gte vml 1]>/g, '');
    // Clean the <head> section of MS Windows specific tags. See https://github.com/ckeditor/ckeditor5/issues/15333.
    // The regular expression matches the <o:SmartTagType> tag with optional attributes (with or without values).
    htmlString = htmlString.replace(/<o:SmartTagType(?:\s+[^\s>=]+(?:="[^"]*")?)*\s*\/?>/gi, '');
    const normalizedHtml = normalizeSpacing(cleanContentAfterBody(htmlString));
    // Parse htmlString as native Document object.
    const htmlDocument = domParser.parseFromString(normalizedHtml, 'text/html');
    normalizeSpacerunSpans(htmlDocument);
    // Get `innerHTML` first as transforming to View modifies the source document.
    const bodyString = htmlDocument.body.innerHTML;
    // Transform document.body to View.
    const bodyView = documentToView(htmlDocument, stylesProcessor);
    // Extract stylesheets.
    const stylesObject = extractStyles(htmlDocument);
    return {
        body: bodyView,
        bodyString,
        styles: stylesObject.styles,
        stylesString: stylesObject.stylesString
    };
}
/**
 * Transforms native `Document` object into {@link module:engine/view/documentfragment~DocumentFragment}. Comments are skipped.
 *
 * @param htmlDocument Native `Document` object to be transformed.
 */ function documentToView(htmlDocument, stylesProcessor) {
    const viewDocument = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewDocument"](stylesProcessor);
    const domConverter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DomConverter"](viewDocument, {
        renderingMode: 'data'
    });
    const fragment = htmlDocument.createDocumentFragment();
    const nodes = htmlDocument.body.childNodes;
    while(nodes.length > 0){
        fragment.appendChild(nodes[0]);
    }
    return domConverter.domToView(fragment, {
        skipComments: true
    });
}
/**
 * Extracts both `CSSStyleSheet` and string representation from all `style` elements available in a provided `htmlDocument`.
 *
 * @param htmlDocument Native `Document` object from which styles will be extracted.
 */ function extractStyles(htmlDocument) {
    const styles = [];
    const stylesString = [];
    const styleTags = Array.from(htmlDocument.getElementsByTagName('style'));
    for (const style of styleTags){
        if (style.sheet && style.sheet.cssRules && style.sheet.cssRules.length) {
            styles.push(style.sheet);
            stylesString.push(style.innerHTML);
        }
    }
    return {
        styles,
        stylesString: stylesString.join(' ')
    };
}
/**
 * Removes leftover content from between closing </body> and closing </html> tag:
 *
 * ```html
 * <html><body><p>Foo Bar</p></body><span>Fo</span></html> -> <html><body><p>Foo Bar</p></body></html>
 * ```
 *
 * This function is used as specific browsers (Edge) add some random content after `body` tag when pasting from Word.
 * @param htmlString The HTML string to be cleaned.
 * @returns The HTML string with leftover content removed.
 */ function cleanContentAfterBody(htmlString) {
    const bodyCloseTag = '</body>';
    const htmlCloseTag = '</html>';
    const bodyCloseIndex = htmlString.indexOf(bodyCloseTag);
    if (bodyCloseIndex < 0) {
        return htmlString;
    }
    const htmlCloseIndex = htmlString.indexOf(htmlCloseTag, bodyCloseIndex + bodyCloseTag.length);
    return htmlString.substring(0, bodyCloseIndex + bodyCloseTag.length) + (htmlCloseIndex >= 0 ? htmlString.substring(htmlCloseIndex) : '');
}
/**
 * The Paste from Office plugin.
 *
 * This plugin handles content pasted from Office apps and transforms it (if necessary)
 * to a valid structure which can then be understood by the editor features.
 *
 * Transformation is made by a set of predefined {@link module:paste-from-office/normalizer~Normalizer normalizers}.
 * This plugin includes following normalizers:
 * * {@link module:paste-from-office/normalizers/mswordnormalizer~MSWordNormalizer Microsoft Word normalizer}
 * * {@link module:paste-from-office/normalizers/googledocsnormalizer~GoogleDocsNormalizer Google Docs normalizer}
 *
 * For more information about this feature check the {@glink api/paste-from-office package page}.
 */ class PasteFromOffice extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'PasteFromOffice';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$clipboard$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClipboardPipeline"]
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const clipboardPipeline = editor.plugins.get('ClipboardPipeline');
        const viewDocument = editor.editing.view.document;
        const normalizers = [];
        const hasMultiLevelListPlugin = this.editor.plugins.has('MultiLevelList');
        normalizers.push(new MSWordNormalizer(viewDocument, hasMultiLevelListPlugin));
        normalizers.push(new GoogleDocsNormalizer(viewDocument));
        normalizers.push(new GoogleSheetsNormalizer(viewDocument));
        clipboardPipeline.on('inputTransformation', (evt, data)=>{
            if (data._isTransformedWithPasteFromOffice) {
                return;
            }
            const codeBlock = editor.model.document.selection.getFirstPosition().parent;
            if (codeBlock.is('element', 'codeBlock')) {
                return;
            }
            const htmlString = data.dataTransfer.getData('text/html');
            const activeNormalizer = normalizers.find((normalizer)=>normalizer.isActive(htmlString));
            if (activeNormalizer) {
                if (!data._parsedData) {
                    data._parsedData = parseHtml(htmlString, viewDocument.stylesProcessor);
                }
                activeNormalizer.execute(data);
                data._isTransformedWithPasteFromOffice = true;
            }
        }, {
            priority: 'high'
        });
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-remove-format/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "RemoveFormat": (()=>RemoveFormat),
    "RemoveFormatEditing": (()=>RemoveFormatEditing),
    "RemoveFormatUI": (()=>RemoveFormatUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
;
;
;
var removeFormatIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z\"/></svg>";
const REMOVE_FORMAT = 'removeFormat';
/**
 * The remove format UI plugin. It registers the `'removeFormat'` button which can be
 * used in the toolbar.
 */ class RemoveFormatUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'RemoveFormatUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.ui.componentFactory.add(REMOVE_FORMAT, ()=>{
            const view = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
            view.set({
                tooltip: true
            });
            return view;
        });
        editor.ui.componentFactory.add(`menuBar:${REMOVE_FORMAT}`, ()=>this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]));
    }
    /**
	 * Creates a button for remove format command to use either in toolbar or in menu bar.
	 */ _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = editor.commands.get(REMOVE_FORMAT);
        const view = new ButtonClass(editor.locale);
        const t = locale.t;
        view.set({
            label: t('Remove Format'),
            icon: removeFormatIcon
        });
        view.bind('isEnabled').to(command, 'isEnabled');
        // Execute the command.
        this.listenTo(view, 'execute', ()=>{
            editor.execute(REMOVE_FORMAT);
            editor.editing.view.focus();
        });
        return view;
    }
}
/**
 * The remove format command.
 *
 * It is used by the {@link module:remove-format/removeformat~RemoveFormat remove format feature}
 * to clear the formatting in the selection.
 *
 * ```ts
 * editor.execute( 'removeFormat' );
 * ```
 */ class RemoveFormatCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        this.isEnabled = !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(this._getFormattingItems(model.document.selection, model.schema));
    }
    /**
	 * @inheritDoc
	 */ execute() {
        const model = this.editor.model;
        const schema = model.schema;
        model.change((writer)=>{
            for (const item of this._getFormattingItems(model.document.selection, schema)){
                if (item.is('selection')) {
                    for (const attributeName of this._getFormattingAttributes(item, schema)){
                        writer.removeSelectionAttribute(attributeName);
                    }
                } else {
                    // Workaround for items with multiple removable attributes. See
                    // https://github.com/ckeditor/ckeditor5-remove-format/pull/1#pullrequestreview-220515609
                    const itemRange = writer.createRangeOn(item);
                    for (const attributeName of this._getFormattingAttributes(item, schema)){
                        writer.removeAttribute(attributeName, itemRange);
                    }
                }
            }
        });
    }
    /**
	 * Returns an iterable of items in a selection (including the selection itself) that have formatting model
	 * attributes to be removed by the feature.
	 *
	 * @param schema The schema describing the item.
	 */ *_getFormattingItems(selection, schema) {
        const itemHasRemovableFormatting = (item)=>{
            return !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(this._getFormattingAttributes(item, schema));
        };
        // Check formatting on selected items that are not blocks.
        for (const curRange of selection.getRanges()){
            for (const item of curRange.getItems()){
                if (!schema.isBlock(item) && itemHasRemovableFormatting(item)) {
                    yield item;
                }
            }
        }
        // Check formatting from selected blocks.
        for (const block of selection.getSelectedBlocks()){
            if (itemHasRemovableFormatting(block)) {
                yield block;
            }
        }
        // Finally the selection might be formatted as well, so make sure to check it.
        if (itemHasRemovableFormatting(selection)) {
            yield selection;
        }
    }
    /**
	 * Returns an iterable of formatting attributes of a given model item.
	 *
	 * **Note:** Formatting items have the `isFormatting` property set to `true`.
	 *
	 * @param schema The schema describing the item.
	 * @returns The names of formatting attributes found in a given item.
	 */ *_getFormattingAttributes(item, schema) {
        for (const [attributeName] of item.getAttributes()){
            const attributeProperties = schema.getAttributeProperties(attributeName);
            if (attributeProperties && attributeProperties.isFormatting) {
                yield attributeName;
            }
        }
    }
}
/**
 * The remove format editing plugin.
 *
 * It registers the {@link module:remove-format/removeformatcommand~RemoveFormatCommand removeFormat} command.
 */ class RemoveFormatEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'RemoveFormatEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.commands.add('removeFormat', new RemoveFormatCommand(editor));
    }
}
/**
 * The remove format plugin.
 *
 * This is a "glue" plugin which loads the {@link module:remove-format/removeformatediting~RemoveFormatEditing}
 * and {@link module:remove-format/removeformatui~RemoveFormatUI} plugins.
 *
 * For a detailed overview, check out the {@glink features/remove-format remove format} feature documentation.
 */ class RemoveFormat extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            RemoveFormatEditing,
            RemoveFormatUI
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'RemoveFormat';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-restricted-editing/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "RestrictedEditingMode": (()=>RestrictedEditingMode),
    "RestrictedEditingModeEditing": (()=>RestrictedEditingModeEditing),
    "RestrictedEditingModeUI": (()=>RestrictedEditingModeUI),
    "StandardEditingMode": (()=>StandardEditingMode),
    "StandardEditingModeEditing": (()=>StandardEditingModeEditing),
    "StandardEditingModeUI": (()=>StandardEditingModeUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
;
;
;
;
/**
 * The command that allows navigation across the exceptions in the edited document.
 */ class RestrictedEditingModeNavigationCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * The direction of the command.
	 */ _direction;
    /**
	 * Creates an instance of the command.
	 *
	 * @param editor The editor instance.
	 * @param direction The direction that the command works.
	 */ constructor(editor, direction){
        super(editor);
        // It does not affect data so should be enabled in read-only mode and in restricted editing mode.
        this.affectsData = false;
        this._direction = direction;
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        this.isEnabled = this._checkEnabled();
    }
    /**
	 * Executes the command.
	 *
	 * @fires execute
	 */ execute() {
        const position = getNearestExceptionRange(this.editor.model, this._direction);
        if (!position) {
            return;
        }
        this.editor.model.change((writer)=>{
            writer.setSelection(position);
        });
    }
    /**
	 * Checks whether the command can be enabled in the current context.
	 *
	 * @returns Whether the command should be enabled.
	 */ _checkEnabled() {
        return !!getNearestExceptionRange(this.editor.model, this._direction);
    }
}
/**
 * Returns the range of the exception marker closest to the last position of the model selection.
 */ function getNearestExceptionRange(model, direction) {
    const selection = model.document.selection;
    const selectionPosition = selection.getFirstPosition();
    const markerRanges = [];
    // Get all exception marker positions that start after/before the selection position.
    for (const marker of model.markers.getMarkersGroup('restrictedEditingException')){
        const markerRange = marker.getRange();
        // Checking parent because there two positions <paragraph>foo^</paragraph><paragraph>^bar</paragraph>
        // are touching but they will represent different markers.
        const isMarkerRangeTouching = selectionPosition.isTouching(markerRange.start) && selectionPosition.hasSameParentAs(markerRange.start) || selectionPosition.isTouching(markerRange.end) && selectionPosition.hasSameParentAs(markerRange.end);
        // <paragraph>foo <marker≥b[]ar</marker> baz</paragraph>
        // <paragraph>foo <marker≥b[ar</marker> ba]z</paragraph>
        // <paragraph>foo <marker≥bar</marker>[] baz</paragraph>
        // <paragraph>foo []<marker≥bar</marker> baz</paragraph>
        if (markerRange.containsPosition(selectionPosition) || isMarkerRangeTouching) {
            continue;
        }
        if (direction === 'forward' && markerRange.start.isAfter(selectionPosition)) {
            markerRanges.push(markerRange);
        } else if (direction === 'backward' && markerRange.end.isBefore(selectionPosition)) {
            markerRanges.push(markerRange);
        }
    }
    if (!markerRanges.length) {
        return;
    }
    // Get the marker closest to the selection position among many. To know that, we need to sort
    // them first.
    return markerRanges.sort((rangeA, rangeB)=>{
        if (direction === 'forward') {
            return rangeA.start.isAfter(rangeB.start) ? 1 : -1;
        } else {
            return rangeA.start.isBefore(rangeB.start) ? 1 : -1;
        }
    }).shift();
}
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module restricted-editing/restrictededitingmode/utils
 */ /**
 * Returns a single "restricted-editing-exception" marker at a given position. Contrary to
 * {@link module:engine/model/markercollection~MarkerCollection#getMarkersAtPosition}, it returnd a marker also when the postion is
 * equal to one of the marker's start or end positions.
 */ function getMarkerAtPosition(editor, position) {
    for (const marker of editor.model.markers){
        const markerRange = marker.getRange();
        if (isPositionInRangeBoundaries(markerRange, position)) {
            if (marker.name.startsWith('restrictedEditingException:')) {
                return marker;
            }
        }
    }
}
/**
 * Checks if the position is fully contained in the range. Positions equal to range start or end are considered "in".
 */ function isPositionInRangeBoundaries(range, position) {
    return range.containsPosition(position) || range.end.isEqual(position) || range.start.isEqual(position);
}
/**
 * Checks if the selection is fully contained in the marker. Positions on marker boundaries are considered "in".
 *
 * ```xml
 * <marker>[]foo</marker> -> true
 * <marker>f[oo]</marker> -> true
 * <marker>f[oo</marker> ba]r -> false
 * <marker>foo</marker> []bar -> false
 * ```
 */ function isSelectionInMarker(selection, marker) {
    if (!marker) {
        return false;
    }
    const markerRange = marker.getRange();
    if (selection.isCollapsed) {
        return isPositionInRangeBoundaries(markerRange, selection.focus);
    }
    return markerRange.containsRange(selection.getFirstRange(), true);
}
const HIGHLIGHT_CLASS = 'restricted-editing-exception_selected';
/**
 * Adds a visual highlight style to a restricted editing exception that the selection is anchored to.
 *
 * The highlight is turned on by adding the `.restricted-editing-exception_selected` class to the
 * exception in the view:
 *
 * * The class is removed before the conversion starts, as callbacks added with the `'highest'` priority
 * to {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} events.
 * * The class is added in the view post-fixer, after other changes in the model tree are converted to the view.
 *
 * This way, adding and removing the highlight does not interfere with conversion.
 */ function setupExceptionHighlighting(editor) {
    const view = editor.editing.view;
    const model = editor.model;
    const highlightedMarkers = new Set();
    // Adding the class.
    view.document.registerPostFixer((writer)=>{
        const modelSelection = model.document.selection;
        const marker = getMarkerAtPosition(editor, modelSelection.anchor);
        if (!marker) {
            return false;
        }
        for (const viewElement of editor.editing.mapper.markerNameToElements(marker.name)){
            writer.addClass(HIGHLIGHT_CLASS, viewElement);
            highlightedMarkers.add(viewElement);
        }
        return false;
    });
    // Removing the class.
    editor.conversion.for('editingDowncast').add((dispatcher)=>{
        // Make sure the highlight is removed on every possible event, before conversion is started.
        dispatcher.on('insert', removeHighlight, {
            priority: 'highest'
        });
        dispatcher.on('remove', removeHighlight, {
            priority: 'highest'
        });
        dispatcher.on('attribute', removeHighlight, {
            priority: 'highest'
        });
        dispatcher.on('cleanSelection', removeHighlight);
        function removeHighlight() {
            view.change((writer)=>{
                for (const item of highlightedMarkers.values()){
                    writer.removeClass(HIGHLIGHT_CLASS, item);
                    highlightedMarkers.delete(item);
                }
            });
        }
    });
}
/**
 * A post-fixer that prevents removing a collapsed marker from the document.
 */ function resurrectCollapsedMarkerPostFixer(editor) {
    // This post-fixer shouldn't be necessary after https://github.com/ckeditor/ckeditor5/issues/5778.
    return (writer)=>{
        let changeApplied = false;
        for (const { name, data } of editor.model.document.differ.getChangedMarkers()){
            if (name.startsWith('restrictedEditingException') && data.newRange && data.newRange.root.rootName == '$graveyard') {
                writer.updateMarker(name, {
                    range: writer.createRange(writer.createPositionAt(data.oldRange.start))
                });
                changeApplied = true;
            }
        }
        return changeApplied;
    };
}
/**
 * A post-fixer that extends a marker when the user types on its boundaries.
 */ function extendMarkerOnTypingPostFixer(editor) {
    // This post-fixer shouldn't be necessary after https://github.com/ckeditor/ckeditor5/issues/5778.
    return (writer)=>{
        let changeApplied = false;
        const schema = editor.model.schema;
        for (const change of editor.model.document.differ.getChanges()){
            if (change.type == 'insert' && schema.checkChild('$block', change.name)) {
                changeApplied = _tryExtendMarkerStart(editor, change.position, change.length, writer) || changeApplied;
                changeApplied = _tryExtendMarkedEnd(editor, change.position, change.length, writer) || changeApplied;
            }
        }
        return changeApplied;
    };
}
/**
 * A view highlight-to-marker conversion helper.
 *
 * @param config Conversion configuration.
 */ function upcastHighlightToMarker(config) {
    return (dispatcher)=>dispatcher.on('element:span', (evt, data, conversionApi)=>{
            const { writer } = conversionApi;
            const matcher = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matcher"](config.view);
            const matcherResult = matcher.match(data.viewItem);
            // If there is no match, this callback should not do anything.
            if (!matcherResult) {
                return;
            }
            const match = matcherResult.match;
            // Force consuming element's name (taken from upcast helpers elementToElement converter).
            match.name = true;
            const { modelRange: convertedChildrenRange } = conversionApi.convertChildren(data.viewItem, data.modelCursor);
            conversionApi.consumable.consume(data.viewItem, match);
            const markerName = config.model();
            const fakeMarkerStart = writer.createElement('$marker', {
                'data-name': markerName
            });
            const fakeMarkerEnd = writer.createElement('$marker', {
                'data-name': markerName
            });
            // Insert in reverse order to use converter content positions directly (without recalculating).
            writer.insert(fakeMarkerEnd, convertedChildrenRange.end);
            writer.insert(fakeMarkerStart, convertedChildrenRange.start);
            data.modelRange = writer.createRange(writer.createPositionBefore(fakeMarkerStart), writer.createPositionAfter(fakeMarkerEnd));
            data.modelCursor = data.modelRange.end;
        });
}
/**
 * Extend marker if change detected on marker's start position.
 */ function _tryExtendMarkerStart(editor, position, length, writer) {
    const markerAtStart = getMarkerAtPosition(editor, position.getShiftedBy(length));
    if (markerAtStart && markerAtStart.getStart().isEqual(position.getShiftedBy(length))) {
        writer.updateMarker(markerAtStart, {
            range: writer.createRange(markerAtStart.getStart().getShiftedBy(-length), markerAtStart.getEnd())
        });
        return true;
    }
    return false;
}
/**
 * Extend marker if change detected on marker's end position.
 */ function _tryExtendMarkedEnd(editor, position, length, writer) {
    const markerAtEnd = getMarkerAtPosition(editor, position);
    if (markerAtEnd && markerAtEnd.getEnd().isEqual(position)) {
        writer.updateMarker(markerAtEnd, {
            range: writer.createRange(markerAtEnd.getStart(), markerAtEnd.getEnd().getShiftedBy(length))
        });
        return true;
    }
    return false;
}
const COMMAND_FORCE_DISABLE_ID = 'RestrictedEditingMode';
/**
 * The restricted editing mode editing feature.
 *
 * * It introduces the exception marker group that renders to `<span>` elements with the `restricted-editing-exception` CSS class.
 * * It registers the `'goToPreviousRestrictedEditingException'` and `'goToNextRestrictedEditingException'` commands.
 * * It also enables highlighting exception markers that are selected.
 */ class RestrictedEditingModeEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * Command names that are enabled outside the non-restricted regions.
	 */ _alwaysEnabled;
    /**
	 * Commands allowed in non-restricted areas.
	 *
	 * Commands always enabled combine typing feature commands: `'input'`, `'insertText'`, `'delete'`, and `'deleteForward'` with
	 * commands defined in the feature configuration.
	 */ _allowedInException;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'RestrictedEditingModeEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('restrictedEditing', {
            allowedCommands: [
                'bold',
                'italic',
                'link',
                'unlink'
            ],
            allowedAttributes: [
                'bold',
                'italic',
                'linkHref'
            ]
        });
        this._alwaysEnabled = new Set([
            'undo',
            'redo'
        ]);
        this._allowedInException = new Set([
            'input',
            'insertText',
            'delete',
            'deleteForward'
        ]);
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        const allowedCommands = editor.config.get('restrictedEditing.allowedCommands');
        allowedCommands.forEach((commandName)=>this._allowedInException.add(commandName));
        this._setupConversion();
        this._setupCommandsToggling();
        this._setupRestrictions();
        // Commands & keystrokes that allow navigation in the content.
        editor.commands.add('goToPreviousRestrictedEditingException', new RestrictedEditingModeNavigationCommand(editor, 'backward'));
        editor.commands.add('goToNextRestrictedEditingException', new RestrictedEditingModeNavigationCommand(editor, 'forward'));
        this.listenTo(editingView.document, 'tab', (evt, data)=>{
            const commandName = !data.shiftKey ? 'goToNextRestrictedEditingException' : 'goToPreviousRestrictedEditingException';
            const command = editor.commands.get(commandName);
            if (command.isEnabled) {
                editor.execute(commandName);
                // Stop the event in the DOM: no listener in the web page will be triggered by this event.
                data.preventDefault();
                data.stopPropagation();
            }
            // Stop the event bubbling in the editor: no more callbacks will be executed for this keystroke.
            evt.stop();
        }, {
            context: '$capture'
        });
        editor.keystrokes.set('Ctrl+A', getSelectAllHandler(editor));
        editingView.change((writer)=>{
            for (const root of editingView.document.roots){
                writer.addClass('ck-restricted-editing_mode_restricted', root);
            }
        });
        // Remove existing restricted editing markers when setting new data to prevent marker resurrection.
        // Without this, markers from removed content would be incorrectly restored due to the resurrection mechanism.
        // See more: https://github.com/ckeditor/ckeditor5/issues/9646#issuecomment-843064995
        editor.data.on('set', ()=>{
            editor.model.change((writer)=>{
                for (const marker of editor.model.markers.getMarkersGroup('restrictedEditingException')){
                    writer.removeMarker(marker.name);
                }
            });
        }, {
            priority: 'high'
        });
    }
    /**
	 * Makes the given command always enabled in the restricted editing mode (regardless
	 * of selection location).
	 *
	 * To enable some commands in non-restricted areas of the content use
	 * {@link module:restricted-editing/restrictededitingconfig~RestrictedEditingConfig#allowedCommands} configuration option.
	 *
	 * @param commandName Name of the command to enable.
	 */ enableCommand(commandName) {
        const command = this.editor.commands.get(commandName);
        command.clearForceDisabled(COMMAND_FORCE_DISABLE_ID);
        this._alwaysEnabled.add(commandName);
    }
    /**
	 * Sets up the restricted mode editing conversion:
	 *
	 * * ucpast & downcast converters,
	 * * marker highlighting in the edting area,
	 * * marker post-fixers.
	 */ _setupConversion() {
        const editor = this.editor;
        const model = editor.model;
        const doc = model.document;
        // The restricted editing does not attach additional data to the zones so there's no need for smarter markers managing.
        // Also, the markers will only be created when loading the data.
        let markerNumber = 0;
        editor.conversion.for('upcast').add(upcastHighlightToMarker({
            view: {
                name: 'span',
                classes: 'restricted-editing-exception'
            },
            model: ()=>{
                markerNumber++; // Starting from restrictedEditingException:1 marker.
                return `restrictedEditingException:${markerNumber}`;
            }
        }));
        // Currently the marker helpers are tied to other use-cases and do not render a collapsed marker as highlight.
        // Also, markerToHighlight can not convert marker on an inline object. It handles only text and widgets,
        // but it is not a case in the data pipeline. That's why there are 3 downcast converters for them:
        //
        // 1. The custom inline item (text or inline object) converter (but not the selection).
        editor.conversion.for('downcast').add((dispatcher)=>{
            dispatcher.on('addMarker:restrictedEditingException', (evt, data, conversionApi)=>{
                // Only convert per-item conversion.
                if (!data.item) {
                    return;
                }
                // Do not convert the selection or non-inline items.
                if (data.item.is('selection') || !conversionApi.schema.isInline(data.item)) {
                    return;
                }
                if (!conversionApi.consumable.consume(data.item, evt.name)) {
                    return;
                }
                const viewWriter = conversionApi.writer;
                const viewElement = viewWriter.createAttributeElement('span', {
                    class: 'restricted-editing-exception'
                }, {
                    id: data.markerName,
                    priority: -10
                });
                const viewRange = conversionApi.mapper.toViewRange(data.range);
                const rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);
                for (const element of rangeAfterWrap.getItems()){
                    if (element.is('attributeElement') && element.isSimilar(viewElement)) {
                        conversionApi.mapper.bindElementToMarker(element, data.markerName);
                        break;
                    }
                }
            });
        });
        // 2. The marker-to-highlight converter for the document selection.
        editor.conversion.for('downcast').markerToHighlight({
            model: 'restrictedEditingException',
            // Use callback to return new object every time new marker instance is created - otherwise it will be seen as the same marker.
            view: ()=>{
                return {
                    name: 'span',
                    classes: 'restricted-editing-exception',
                    priority: -10
                };
            }
        });
        // 3. And for collapsed marker we need to render it as an element.
        // Additionally, the editing pipeline should always display a collapsed marker.
        editor.conversion.for('editingDowncast').markerToElement({
            model: 'restrictedEditingException',
            view: (markerData, { writer })=>{
                return writer.createUIElement('span', {
                    class: 'restricted-editing-exception restricted-editing-exception_collapsed'
                });
            }
        });
        editor.conversion.for('dataDowncast').markerToElement({
            model: 'restrictedEditingException',
            view: (markerData, { writer })=>{
                return writer.createEmptyElement('span', {
                    class: 'restricted-editing-exception'
                });
            }
        });
        doc.registerPostFixer(extendMarkerOnTypingPostFixer(editor));
        doc.registerPostFixer(resurrectCollapsedMarkerPostFixer(editor));
        doc.registerPostFixer(ensureNewMarkerIsFlatPostFixer(editor));
        setupExceptionHighlighting(editor);
    }
    /**
	 * Setups additional editing restrictions beyond command toggling:
	 *
	 * * delete content range trimming
	 * * disabling input command outside exception marker
	 * * restricting clipboard holder to text only
	 * * restricting text attributes in content
	 */ _setupRestrictions() {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const viewDoc = editor.editing.view.document;
        const clipboard = editor.plugins.get('ClipboardPipeline');
        this.listenTo(model, 'deleteContent', restrictDeleteContent(editor), {
            priority: 'high'
        });
        const insertTextCommand = editor.commands.get('insertText');
        // The restricted editing might be configured without insert text support - ie allow only bolding or removing text.
        // This check is bit synthetic since only tests are used this way.
        if (insertTextCommand) {
            this.listenTo(insertTextCommand, 'execute', disallowInputExecForWrongRange(editor), {
                priority: 'high'
            });
        }
        // Block clipboard outside exception marker on paste and drop.
        this.listenTo(clipboard, 'contentInsertion', (evt)=>{
            if (!isRangeInsideSingleMarker(editor, selection.getFirstRange())) {
                evt.stop();
            }
        });
        // Block clipboard outside exception marker on cut.
        this.listenTo(viewDoc, 'clipboardOutput', (evt, data)=>{
            if (data.method == 'cut' && !isRangeInsideSingleMarker(editor, selection.getFirstRange())) {
                evt.stop();
            }
        }, {
            priority: 'high'
        });
        const allowedAttributes = editor.config.get('restrictedEditing.allowedAttributes');
        model.schema.addAttributeCheck(onlyAllowAttributesFromList(allowedAttributes));
        model.schema.addChildCheck(allowTextOnlyInClipboardHolder());
    }
    /**
	 * Sets up the command toggling which enables or disables commands based on the user selection.
	 */ _setupCommandsToggling() {
        const editor = this.editor;
        const model = editor.model;
        const doc = model.document;
        this._disableCommands();
        this.listenTo(doc.selection, 'change', this._checkCommands.bind(this));
        this.listenTo(doc, 'change:data', this._checkCommands.bind(this));
    }
    /**
	 * Checks if commands should be enabled or disabled based on the current selection.
	 */ _checkCommands() {
        const editor = this.editor;
        const selection = editor.model.document.selection;
        if (selection.rangeCount > 1) {
            this._disableCommands();
            return;
        }
        const marker = getMarkerAtPosition(editor, selection.focus);
        this._disableCommands();
        if (isSelectionInMarker(selection, marker)) {
            this._enableCommands(marker);
        }
    }
    /**
	 * Enables commands in non-restricted regions.
	 */ _enableCommands(marker) {
        const editor = this.editor;
        for (const [commandName, command] of editor.commands){
            if (!command.affectsData || this._alwaysEnabled.has(commandName)) {
                continue;
            }
            // Enable ony those commands that are allowed in the exception marker.
            if (!this._allowedInException.has(commandName)) {
                continue;
            }
            // Do not enable 'delete' and 'deleteForward' commands on the exception marker boundaries.
            if (isDeleteCommandOnMarkerBoundaries(commandName, editor.model.document.selection, marker.getRange())) {
                continue;
            }
            command.clearForceDisabled(COMMAND_FORCE_DISABLE_ID);
        }
    }
    /**
	 * Disables commands outside non-restricted regions.
	 */ _disableCommands() {
        const editor = this.editor;
        for (const [commandName, command] of editor.commands){
            if (!command.affectsData || this._alwaysEnabled.has(commandName)) {
                continue;
            }
            command.forceDisabled(COMMAND_FORCE_DISABLE_ID);
        }
    }
}
/**
 * Helper for handling Ctrl+A keydown behaviour.
 */ function getSelectAllHandler(editor) {
    return (_, cancel)=>{
        const model = editor.model;
        const selection = editor.model.document.selection;
        const marker = getMarkerAtPosition(editor, selection.focus);
        if (!marker) {
            return;
        }
        // If selection range is inside a restricted editing exception, select text only within the exception.
        //
        // Note: Second Ctrl+A press is also blocked and it won't select the entire text in the editor.
        const selectionRange = selection.getFirstRange();
        const markerRange = marker.getRange();
        if (markerRange.containsRange(selectionRange, true) || selection.isCollapsed) {
            cancel();
            model.change((writer)=>{
                writer.setSelection(marker.getRange());
            });
        }
    };
}
/**
 * Additional rule for enabling "delete" and "deleteForward" commands if selection is on range boundaries:
 *
 * Does not allow to enable command when selection focus is:
 * - is on marker start - "delete" - to prevent removing content before marker
 * - is on marker end - "deleteForward" - to prevent removing content after marker
 */ function isDeleteCommandOnMarkerBoundaries(commandName, selection, markerRange) {
    if (commandName == 'delete' && markerRange.start.isEqual(selection.focus)) {
        return true;
    }
    // Only for collapsed selection - non-collapsed selection that extends over a marker is handled elsewhere.
    if (commandName == 'deleteForward' && selection.isCollapsed && markerRange.end.isEqual(selection.focus)) {
        return true;
    }
    return false;
}
/**
 * Ensures that model.deleteContent() does not delete outside exception markers ranges.
 *
 * The enforced restrictions are:
 * - only execute deleteContent() inside exception markers
 * - restrict passed selection to exception marker
 */ function restrictDeleteContent(editor) {
    return (evt, args)=>{
        const [selection] = args;
        const marker = getMarkerAtPosition(editor, selection.focus) || getMarkerAtPosition(editor, selection.anchor);
        // Stop method execution if marker was not found at selection focus.
        if (!marker) {
            evt.stop();
            return;
        }
        // Collapsed selection inside exception marker does not require fixing.
        if (selection.isCollapsed) {
            return;
        }
        // Shrink the selection to the range inside exception marker.
        const allowedToDelete = marker.getRange().getIntersection(selection.getFirstRange());
        // Some features uses selection passed to model.deleteContent() to set the selection afterwards. For this we need to properly modify
        // either the document selection using change block...
        if (selection.is('documentSelection')) {
            editor.model.change((writer)=>{
                writer.setSelection(allowedToDelete);
            });
        } else {
            selection.setTo(allowedToDelete);
        }
    };
}
/**
 * Ensures that input command is executed with a range that is inside exception marker.
 *
 * This restriction is due to fact that using native spell check changes text outside exception marker.
 */ function disallowInputExecForWrongRange(editor) {
    return (evt, args)=>{
        const [options] = args;
        const { range } = options;
        // Only check "input" command executed with a range value.
        // Selection might be set in exception marker but passed range might point elsewhere.
        if (!range) {
            return;
        }
        if (!isRangeInsideSingleMarker(editor, range)) {
            evt.stop();
        }
    };
}
function isRangeInsideSingleMarker(editor, range) {
    const markerAtStart = getMarkerAtPosition(editor, range.start);
    const markerAtEnd = getMarkerAtPosition(editor, range.end);
    return markerAtStart && markerAtEnd && markerAtEnd === markerAtStart;
}
/**
 * Checks if new marker range is flat. Non-flat ranges might appear during upcast conversion in nested structures, ie tables.
 *
 * Note: This marker fixer only consider case which is possible to create using StandardEditing mode plugin.
 * Markers created by developer in the data might break in many other ways.
 *
 * See #6003.
 */ function ensureNewMarkerIsFlatPostFixer(editor) {
    return (writer)=>{
        let changeApplied = false;
        const changedMarkers = editor.model.document.differ.getChangedMarkers();
        for (const { data, name } of changedMarkers){
            if (!name.startsWith('restrictedEditingException')) {
                continue;
            }
            const newRange = data.newRange;
            if (!data.oldRange && !newRange.isFlat) {
                const start = newRange.start;
                const end = newRange.end;
                const startIsHigherInTree = start.path.length > end.path.length;
                const fixedStart = startIsHigherInTree ? newRange.start : writer.createPositionAt(end.parent, 0);
                const fixedEnd = startIsHigherInTree ? writer.createPositionAt(start.parent, 'end') : newRange.end;
                writer.updateMarker(name, {
                    range: writer.createRange(fixedStart, fixedEnd)
                });
                changeApplied = true;
            }
        }
        return changeApplied;
    };
}
function onlyAllowAttributesFromList(allowedAttributes) {
    return (context, attributeName)=>{
        if (context.startsWith('$clipboardHolder')) {
            return allowedAttributes.includes(attributeName);
        }
    };
}
function allowTextOnlyInClipboardHolder() {
    return (context, childDefinition)=>{
        if (context.startsWith('$clipboardHolder')) {
            return childDefinition.name === '$text';
        }
    };
}
var lockIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.5 6.5a3.5 3.5 0 0 1 3.495 3.308L19 10v2a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1v-2l.005-.192A3.5 3.5 0 0 1 15.5 6.5zm0 7.5a.5.5 0 0 0-.492.41L15 14.5v2a.5.5 0 0 0 .992.09L16 16.5v-2a.5.5 0 0 0-.5-.5zm0-6a2 2 0 0 0-2 2v2h4v-2a2 2 0 0 0-2-2zm-9.25 8a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5h5.5zm0-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5h5.5zm3-5a.75.75 0 0 1 0 1.5H.75a.75.75 0 0 1 0-1.5h8.5zm6-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 0 1 0-1.5h14.5z\"/></svg>";
/**
 * The restricted editing mode UI feature.
 *
 * It introduces the `'restrictedEditing'` dropdown that offers tools to navigate between exceptions across
 * the document.
 */ class RestrictedEditingModeUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'RestrictedEditingModeUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        editor.ui.componentFactory.add('restrictedEditing', (locale)=>{
            const dropdownView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDropdown"])(locale);
            const listItems = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"]();
            this._getButtonDefinitions().forEach(({ commandName, label, keystroke })=>{
                listItems.add(this._getButtonDefinition(commandName, label, keystroke));
            });
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addListToDropdown"])(dropdownView, listItems, {
                role: 'menu'
            });
            dropdownView.buttonView.set({
                label: t('Navigate editable regions'),
                icon: lockIcon,
                tooltip: true,
                isEnabled: true,
                isOn: false
            });
            this.listenTo(dropdownView, 'execute', (evt)=>{
                const { _commandName } = evt.source;
                editor.execute(_commandName);
                editor.editing.view.focus();
            });
            return dropdownView;
        });
        editor.ui.componentFactory.add('menuBar:restrictedEditing', (locale)=>{
            const menuView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuView"](locale);
            const listView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListView"](locale);
            listView.set({
                ariaLabel: t('Navigate editable regions'),
                role: 'menu'
            });
            menuView.buttonView.set({
                label: t('Navigate editable regions'),
                icon: lockIcon
            });
            menuView.panelView.children.add(listView);
            this._getButtonDefinitions().forEach(({ commandName, label, keystroke })=>{
                const listItemView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemView"](locale, menuView);
                const buttonView = this._createMenuBarButton(label, commandName, keystroke);
                buttonView.delegate('execute').to(menuView);
                listItemView.children.add(buttonView);
                listView.items.add(listItemView);
            });
            return menuView;
        });
    }
    /**
	 * Creates a button for restricted editing command to use in menu bar.
	 */ _createMenuBarButton(label, commandName, keystroke) {
        const editor = this.editor;
        const command = editor.commands.get(commandName);
        const view = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"](editor.locale);
        view.set({
            label,
            keystroke,
            isEnabled: true,
            isOn: false
        });
        view.bind('isEnabled').to(command);
        // Execute the command.
        this.listenTo(view, 'execute', ()=>{
            editor.execute(commandName);
            editor.editing.view.focus();
        });
        return view;
    }
    /**
	 * Returns a definition of the navigation button to be used in the dropdown.
	 *
	 * @param commandName The name of the command that the button represents.
	 * @param label The translated label of the button.
	 * @param keystroke The button keystroke.
	 */ _getButtonDefinition(commandName, label, keystroke) {
        const editor = this.editor;
        const command = editor.commands.get(commandName);
        const definition = {
            type: 'button',
            model: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewModel"]({
                label,
                withText: true,
                keystroke,
                withKeystroke: true,
                role: 'menuitem',
                _commandName: commandName
            })
        };
        definition.model.bind('isEnabled').to(command, 'isEnabled');
        return definition;
    }
    /**
	 * Returns definitions for UI buttons.
	 *
	 * @internal
	 */ _getButtonDefinitions() {
        const t = this.editor.locale.t;
        return [
            {
                commandName: 'goToPreviousRestrictedEditingException',
                label: t('Previous editable region'),
                keystroke: 'Shift+Tab'
            },
            {
                commandName: 'goToNextRestrictedEditingException',
                label: t('Next editable region'),
                keystroke: 'Tab'
            }
        ];
    }
}
/**
 * The restricted editing mode plugin.
 *
 * This is a "glue" plugin which loads the following plugins:
 *
 * * The {@link module:restricted-editing/restrictededitingmodeediting~RestrictedEditingModeEditing restricted mode editing feature}.
 * * The {@link module:restricted-editing/restrictededitingmodeui~RestrictedEditingModeUI restricted mode UI feature}.
 */ class RestrictedEditingMode extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'RestrictedEditingMode';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            RestrictedEditingModeEditing,
            RestrictedEditingModeUI
        ];
    }
}
/**
 * The command that toggles exceptions from the restricted editing on text.
 */ class RestrictedEditingExceptionCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const doc = model.document;
        this.value = !!doc.selection.getAttribute('restrictedEditingException');
        this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, 'restrictedEditingException');
    }
    /**
	 * @inheritDoc
	 */ execute(options = {}) {
        const model = this.editor.model;
        const document = model.document;
        const selection = document.selection;
        const valueToSet = options.forceValue === undefined ? !this.value : options.forceValue;
        model.change((writer)=>{
            const ranges = model.schema.getValidRanges(selection.getRanges(), 'restrictedEditingException');
            if (selection.isCollapsed) {
                if (valueToSet) {
                    writer.setSelectionAttribute('restrictedEditingException', valueToSet);
                } else {
                    const isSameException = (value)=>{
                        return value.item.getAttribute('restrictedEditingException') === this.value;
                    };
                    const focus = selection.focus;
                    const exceptionStart = focus.getLastMatchingPosition(isSameException, {
                        direction: 'backward'
                    });
                    const exceptionEnd = focus.getLastMatchingPosition(isSameException);
                    writer.removeSelectionAttribute('restrictedEditingException');
                    if (!(focus.isEqual(exceptionStart) || focus.isEqual(exceptionEnd))) {
                        writer.removeAttribute('restrictedEditingException', writer.createRange(exceptionStart, exceptionEnd));
                    }
                }
            } else {
                for (const range of ranges){
                    if (valueToSet) {
                        writer.setAttribute('restrictedEditingException', valueToSet, range);
                    } else {
                        writer.removeAttribute('restrictedEditingException', range);
                    }
                }
            }
        });
    }
}
/**
 * The standard editing mode editing feature.
 *
 * * It introduces the `restrictedEditingException` text attribute that is rendered as
 * a `<span>` element with the `restricted-editing-exception` CSS class.
 * * It registers the `'restrictedEditingException'` command.
 */ class StandardEditingModeEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'StandardEditingModeEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.model.schema.extend('$text', {
            allowAttributes: [
                'restrictedEditingException'
            ]
        });
        editor.conversion.for('upcast').elementToAttribute({
            model: 'restrictedEditingException',
            view: {
                name: 'span',
                classes: 'restricted-editing-exception'
            }
        });
        editor.conversion.for('downcast').attributeToElement({
            model: 'restrictedEditingException',
            view: (modelAttributeValue, { writer })=>{
                if (modelAttributeValue) {
                    // Make the restricted editing <span> outer-most in the view.
                    return writer.createAttributeElement('span', {
                        class: 'restricted-editing-exception'
                    }, {
                        priority: -10
                    });
                }
            }
        });
        editor.commands.add('restrictedEditingException', new RestrictedEditingExceptionCommand(editor));
        editor.editing.view.change((writer)=>{
            for (const root of editor.editing.view.document.roots){
                writer.addClass('ck-restricted-editing_mode_standard', root);
            }
        });
    }
}
var unlockIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6.25 16a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5h5.5zm0-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5h5.5zm3-5a.75.75 0 0 1 0 1.5H.75a.75.75 0 0 1 0-1.5h8.5zm6-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 0 1 0-1.5h14.5zm.25 5.5a3.5 3.5 0 0 1 3.143 1.959.75.75 0 0 1-1.36.636A2 2 0 0 0 13.5 10v2H19a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1v-2l.005-.192A3.5 3.5 0 0 1 15.5 6.5zm0 7.5a.5.5 0 0 0-.492.41L15 14.5v2a.5.5 0 0 0 .992.09L16 16.5v-2a.5.5 0 0 0-.5-.5z\"/></svg>";
/**
 * The standard editing mode UI feature.
 *
 * It introduces the `'restrictedEditingException'` button that marks text as unrestricted for editing.
 */ class StandardEditingModeUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'StandardEditingModeUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.ui.componentFactory.add('restrictedEditingException', ()=>{
            const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
            button.set({
                tooltip: true,
                isToggleable: true
            });
            return button;
        });
        editor.ui.componentFactory.add('menuBar:restrictedEditingException', ()=>{
            return this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
        });
    }
    /**
	 * Creates a button for restricted editing exception command to use either in toolbar or in menu bar.
	 */ _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = this.editor.commands.get('restrictedEditingException');
        const view = new ButtonClass(locale);
        const t = locale.t;
        view.icon = unlockIcon;
        view.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled');
        view.bind('label').to(command, 'value', (value)=>{
            return value ? t('Disable editing') : t('Enable editing');
        });
        // Execute the command.
        this.listenTo(view, 'execute', ()=>{
            editor.execute('restrictedEditingException');
            editor.editing.view.focus();
        });
        return view;
    }
}
/**
 * The standard editing mode plugin.
 *
 * This is a "glue" plugin that loads the following plugins:
 *
 * * The {@link module:restricted-editing/standardeditingmodeediting~StandardEditingModeEditing standard mode editing feature}.
 * * The {@link module:restricted-editing/standardeditingmodeui~StandardEditingModeUI standard mode UI feature}.
 */ class StandardEditingMode extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'StandardEditingMode';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    static get requires() {
        return [
            StandardEditingModeEditing,
            StandardEditingModeUI
        ];
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-show-blocks/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "ShowBlocks": (()=>ShowBlocks),
    "ShowBlocksCommand": (()=>ShowBlocksCommand),
    "ShowBlocksEditing": (()=>ShowBlocksEditing),
    "ShowBlocksUI": (()=>ShowBlocksUI)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
;
;
/**
 * The show blocks command.
 *
 * Displays the HTML element names for content blocks.
 */ class ShowBlocksCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        // It does not affect data so should be enabled in read-only mode.
        this.affectsData = false;
        this.value = false;
    }
    /**
	 * Toggles the visibility of content blocks.
	 */ execute() {
        const CLASS_NAME = 'ck-show-blocks';
        const view = this.editor.editing.view;
        view.change((writer)=>{
            // Multiroot support.
            for (const root of view.document.roots){
                if (!root.hasClass(CLASS_NAME)) {
                    writer.addClass(CLASS_NAME, root);
                    this.value = true;
                } else {
                    writer.removeClass(CLASS_NAME, root);
                    this.value = false;
                }
            }
        });
    }
}
/**
 * The show blocks editing plugin.
 */ class ShowBlocksEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ShowBlocksEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const { editor } = this;
        editor.commands.add('showBlocks', new ShowBlocksCommand(editor));
    }
}
var showBlocksIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m6.395 9.196 2.545-.007V6.498a.598.598 0 0 1 .598-.598h.299a.598.598 0 0 1 .598.598v6.877a.598.598 0 0 1-.598.598h-.299a.598.598 0 0 1-.598-.598v-2.691l-2.545.007v2.691a.598.598 0 0 1-.598.598h-.299a.598.598 0 0 1-.598-.598V6.505a.598.598 0 0 1 .598-.598h.299a.598.598 0 0 1 .598.598v2.691Z\"/><path d=\"M15.094 13.417V6.462a.562.562 0 0 0-.562-.562h-.782a1 1 0 0 0-.39.08l-1.017.43a.562.562 0 0 0-.343.517v.197c0 .4.406.67.775.519l.819-.337v6.111c0 .31.251.562.561.562h.377c.31 0 .562-.251.562-.562Z\"/><path d=\"M0 15.417v1.5h1.5v-1.5H0Z\"/><path d=\"M18.5 15.417v1.5H20v-1.5h-1.5Z\"/><path d=\"M18.5 12.333v1.5H20v-1.5h-1.5Z\"/><path d=\"M18.5 9.25v1.5H20v-1.5h-1.5Z\"/><path d=\"M18.5 6.167v1.5H20v-1.5h-1.5Z\"/><path d=\"M0 18.5v.5a1 1 0 0 0 1 1h.5v-1.5H0Z\"/><path d=\"M3.083 18.5V20h1.5v-1.5h-1.5Z\"/><path d=\"M6.167 18.5V20h1.5v-1.5h-1.5Z\"/><path d=\"M9.25 18.5V20h1.5v-1.5h-1.5Z\"/><path d=\"M12.333 18.5V20h1.5v-1.5h-1.5Z\"/><path d=\"M15.417 18.5V20h1.5v-1.5h-1.5Z\"/><path d=\"M18.5 18.5V20h.5a1 1 0 0 0 1-1v-.5h-1.5Z\"/><path clip-rule=\"evenodd\" d=\"M0 1a1 1 0 0 1 1-1h18a1 1 0 0 1 1 1v3.583h-1.5V1.5h-17v12.333H0V1Z\"/></svg>";
/**
 * The UI plugin of the show blocks feature.
 *
 * It registers the `'showBlocks'` UI button in the editor's {@link module:ui/componentfactory~ComponentFactory component factory}
 * that toggles the visibility of the HTML element names of content blocks.
 */ class ShowBlocksUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ShowBlocksUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.ui.componentFactory.add('showBlocks', ()=>{
            const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
            buttonView.set({
                tooltip: true,
                icon: showBlocksIcon
            });
            return buttonView;
        });
        editor.ui.componentFactory.add('menuBar:showBlocks', ()=>{
            return this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
        });
    }
    /**
	 * Creates a button for show blocks command to use either in toolbar or in menu bar.
	 */ _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = editor.commands.get('showBlocks');
        const view = new ButtonClass(locale);
        const t = locale.t;
        view.set({
            label: t('Show blocks'),
            isToggleable: true,
            role: 'menuitemcheckbox'
        });
        view.bind('isEnabled').to(command);
        view.bind('isOn').to(command, 'value', command, 'isEnabled', (value, isEnabled)=>value && isEnabled);
        // Execute the command.
        this.listenTo(view, 'execute', ()=>{
            editor.execute('showBlocks');
            editor.editing.view.focus();
        });
        return view;
    }
}
/**
 * The show blocks feature.
 *
 * For a detailed overview, check the {@glink features/show-blocks Show blocks} feature guide.
 */ class ShowBlocks extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ShowBlocks';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            ShowBlocksEditing,
            ShowBlocksUI
        ];
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-source-editing/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "SourceEditing": (()=>SourceEditing)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
;
;
;
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module source-editing/utils/formathtml
 */ /**
 * A simple (and naive) HTML code formatter that returns a formatted HTML markup that can be easily
 * parsed by human eyes. It beautifies the HTML code by adding new lines between elements that behave like block elements
 * (https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements
 * and a few more like `tr`, `td`, and similar ones) and inserting indents for nested content.
 *
 * WARNING: This function works only on a text that does not contain any indentations or new lines.
 * Calling this function on the already formatted text will damage the formatting.
 *
 * @param input An HTML string to format.
 */ function formatHtml(input) {
    // A list of block-like elements around which the new lines should be inserted, and within which
    // the indentation of their children should be increased.
    // The list is partially based on https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements that contains
    // a full list of HTML block-level elements.
    // A void element is an element that cannot have any child - https://html.spec.whatwg.org/multipage/syntax.html#void-elements.
    // Note that <pre> element is not listed on this list to avoid breaking whitespace formatting.
    // Note that <br> element is not listed and handled separately so no additional white spaces are injected.
    const elementsToFormat = [
        {
            name: 'address',
            isVoid: false
        },
        {
            name: 'article',
            isVoid: false
        },
        {
            name: 'aside',
            isVoid: false
        },
        {
            name: 'blockquote',
            isVoid: false
        },
        {
            name: 'details',
            isVoid: false
        },
        {
            name: 'dialog',
            isVoid: false
        },
        {
            name: 'dd',
            isVoid: false
        },
        {
            name: 'div',
            isVoid: false
        },
        {
            name: 'dl',
            isVoid: false
        },
        {
            name: 'dt',
            isVoid: false
        },
        {
            name: 'fieldset',
            isVoid: false
        },
        {
            name: 'figcaption',
            isVoid: false
        },
        {
            name: 'figure',
            isVoid: false
        },
        {
            name: 'footer',
            isVoid: false
        },
        {
            name: 'form',
            isVoid: false
        },
        {
            name: 'h1',
            isVoid: false
        },
        {
            name: 'h2',
            isVoid: false
        },
        {
            name: 'h3',
            isVoid: false
        },
        {
            name: 'h4',
            isVoid: false
        },
        {
            name: 'h5',
            isVoid: false
        },
        {
            name: 'h6',
            isVoid: false
        },
        {
            name: 'header',
            isVoid: false
        },
        {
            name: 'hgroup',
            isVoid: false
        },
        {
            name: 'hr',
            isVoid: true
        },
        {
            name: 'li',
            isVoid: false
        },
        {
            name: 'main',
            isVoid: false
        },
        {
            name: 'nav',
            isVoid: false
        },
        {
            name: 'ol',
            isVoid: false
        },
        {
            name: 'p',
            isVoid: false
        },
        {
            name: 'section',
            isVoid: false
        },
        {
            name: 'table',
            isVoid: false
        },
        {
            name: 'tbody',
            isVoid: false
        },
        {
            name: 'td',
            isVoid: false
        },
        {
            name: 'th',
            isVoid: false
        },
        {
            name: 'thead',
            isVoid: false
        },
        {
            name: 'tr',
            isVoid: false
        },
        {
            name: 'ul',
            isVoid: false
        }
    ];
    const elementNamesToFormat = elementsToFormat.map((element)=>element.name).join('|');
    // It is not the fastest way to format the HTML markup but the performance should be good enough.
    const lines = input // Add new line before and after `<tag>` and `</tag>`.
    // It may separate individual elements with two new lines, but this will be fixed below.
    .replace(new RegExp(`</?(${elementNamesToFormat})( .*?)?>`, 'g'), '\n$&\n') // Keep `<br>`s at the end of line to avoid adding additional whitespaces before `<br>`.
    .replace(/<br[^>]*>/g, '$&\n') // Divide input string into lines, which start with either an opening tag, a closing tag, or just a text.
    .split('\n');
    let indentCount = 0;
    let isPreformattedLine = false;
    return lines.filter((line)=>line.length).map((line)=>{
        isPreformattedLine = isPreformattedBlockLine(line, isPreformattedLine);
        if (isNonVoidOpeningTag(line, elementsToFormat)) {
            return indentLine(line, indentCount++);
        }
        if (isClosingTag(line, elementsToFormat)) {
            return indentLine(line, --indentCount);
        }
        if (isPreformattedLine === 'middle' || isPreformattedLine === 'last') {
            return line;
        }
        return indentLine(line, indentCount);
    }).join('\n');
}
/**
 * Checks, if an argument is an opening tag of a non-void element to be formatted.
 *
 * @param line String to check.
 * @param elementsToFormat Elements to be formatted.
 */ function isNonVoidOpeningTag(line, elementsToFormat) {
    return elementsToFormat.some((element)=>{
        if (element.isVoid) {
            return false;
        }
        if (!new RegExp(`<${element.name}( .*?)?>`).test(line)) {
            return false;
        }
        return true;
    });
}
/**
 * Checks, if an argument is a closing tag.
 *
 * @param line String to check.
 * @param elementsToFormat Elements to be formatted.
 */ function isClosingTag(line, elementsToFormat) {
    return elementsToFormat.some((element)=>{
        return new RegExp(`</${element.name}>`).test(line);
    });
}
/**
 * Indents a line by a specified number of characters.
 *
 * @param line Line to indent.
 * @param indentCount Number of characters to use for indentation.
 * @param indentChar Indentation character(s). 4 spaces by default.
 */ function indentLine(line, indentCount, indentChar = '    ') {
    // More about Math.max() here in https://github.com/ckeditor/ckeditor5/issues/10698.
    return `${indentChar.repeat(Math.max(0, indentCount))}${line}`;
}
/**
 * Checks whether a line belongs to a preformatted (`<pre>`) block.
 *
 * @param line Line to check.
 * @param isPreviousLinePreFormatted Information on whether the previous line was preformatted (and how).
 */ function isPreformattedBlockLine(line, isPreviousLinePreFormatted) {
    if (new RegExp('<pre( .*?)?>').test(line)) {
        return 'first';
    } else if (new RegExp('</pre>').test(line)) {
        return 'last';
    } else if (isPreviousLinePreFormatted === 'first' || isPreviousLinePreFormatted === 'middle') {
        return 'middle';
    } else {
        return false;
    }
}
const COMMAND_FORCE_DISABLE_ID = 'SourceEditingMode';
/**
 * The source editing feature.
 *
 * It provides the possibility to view and edit the source of the document.
 *
 * For a detailed overview, check the {@glink features/source-editing/source-editing source editing feature documentation} and the
 * {@glink api/source-editing package page}.
 */ class SourceEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SourceEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PendingActions"]
        ];
    }
    /**
	 * The element replacer instance used to replace the editing roots with the wrapper elements containing the document source.
	 */ _elementReplacer;
    /**
	 * Maps all root names to wrapper elements containing the document source.
	 */ _replacedRoots;
    /**
	 * Maps all root names to their document data.
	 */ _dataFromRoots;
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        this.set('isSourceEditingMode', false);
        this._elementReplacer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementReplacer"]();
        this._replacedRoots = new Map();
        this._dataFromRoots = new Map();
        editor.config.define('sourceEditing.allowCollaborationFeatures', false);
    }
    /**
	 * @inheritDoc
	 */ init() {
        this._checkCompatibility();
        const editor = this.editor;
        const t = editor.locale.t;
        editor.ui.componentFactory.add('sourceEditing', ()=>{
            const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
            buttonView.set({
                label: t('Source'),
                icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].source,
                tooltip: true,
                class: 'ck-source-editing-button'
            });
            return buttonView;
        });
        editor.ui.componentFactory.add('menuBar:sourceEditing', ()=>{
            const buttonView = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
            buttonView.set({
                label: t('Show source'),
                role: 'menuitemcheckbox'
            });
            return buttonView;
        });
        // Currently, the plugin handles the source editing mode by itself only for the classic editor. To use this plugin with other
        // integrations, listen to the `change:isSourceEditingMode` event and act accordingly.
        if (this._isAllowedToHandleSourceEditingMode()) {
            this.on('change:isSourceEditingMode', (evt, name, isSourceEditingMode)=>{
                if (isSourceEditingMode) {
                    this._hideVisibleDialog();
                    this._showSourceEditing();
                    this._disableCommands();
                } else {
                    this._hideSourceEditing();
                    this._enableCommands();
                }
            });
            this.on('change:isEnabled', (evt, name, isEnabled)=>this._handleReadOnlyMode(!isEnabled));
            this.listenTo(editor, 'change:isReadOnly', (evt, name, isReadOnly)=>this._handleReadOnlyMode(isReadOnly));
        }
        // Update the editor data while calling editor.getData() in the source editing mode.
        editor.data.on('get', ()=>{
            if (this.isSourceEditingMode) {
                this.updateEditorData();
            }
        }, {
            priority: 'high'
        });
    }
    /**
	 * Updates the source data in all hidden editing roots.
	 */ updateEditorData() {
        const editor = this.editor;
        const data = {};
        for (const [rootName, domSourceEditingElementWrapper] of this._replacedRoots){
            const oldData = this._dataFromRoots.get(rootName);
            const newData = domSourceEditingElementWrapper.dataset.value;
            // Do not set the data unless some changes have been made in the meantime.
            // This prevents empty undo steps after switching to the normal editor.
            if (oldData !== newData) {
                data[rootName] = newData;
                this._dataFromRoots.set(rootName, newData);
            }
        }
        if (Object.keys(data).length) {
            editor.data.set(data, {
                batchType: {
                    isUndoable: true
                },
                suppressErrorInCollaboration: true
            });
        }
    }
    _checkCompatibility() {
        const editor = this.editor;
        const allowCollaboration = editor.config.get('sourceEditing.allowCollaborationFeatures');
        if (!allowCollaboration && editor.plugins.has('RealTimeCollaborativeEditing')) {
            /**
			 * Source editing feature is not fully compatible with real-time collaboration,
			 * and using it may lead to data loss. Please read
			 * {@glink features/source-editing/source-editing#limitations-and-incompatibilities source editing feature guide} to learn more.
			 *
			 * If you understand the possible risk of data loss, you can enable the source editing
			 * by setting the
			 * {@link module:source-editing/sourceeditingconfig~SourceEditingConfig#allowCollaborationFeatures}
			 * configuration flag to `true`.
			 *
			 * @error source-editing-incompatible-with-real-time-collaboration
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('source-editing-incompatible-with-real-time-collaboration', null);
        }
        const collaborationPluginNamesToWarn = [
            'CommentsEditing',
            'TrackChangesEditing',
            'RevisionHistory'
        ];
        // Currently, the basic integration with Collaboration Features is to display a warning in the console.
        //
        // If `allowCollaboration` flag is set, do not show these warnings. If the flag is set, we assume that the integrator read
        // appropriate section of the guide so there's no use to spam the console with warnings.
        //
        if (!allowCollaboration && collaborationPluginNamesToWarn.some((pluginName)=>editor.plugins.has(pluginName))) {
            console.warn('You initialized the editor with the source editing feature and at least one of the collaboration features. ' + 'Please be advised that the source editing feature may not work, and be careful when editing document source ' + 'that contains markers created by the collaboration features.');
        }
        // Restricted Editing integration can also lead to problems. Warn the user accordingly.
        if (editor.plugins.has('RestrictedEditingModeEditing')) {
            console.warn('You initialized the editor with the source editing feature and restricted editing feature. ' + 'Please be advised that the source editing feature may not work, and be careful when editing document source ' + 'that contains markers created by the restricted editing feature.');
        }
    }
    /**
	 * Creates source editing wrappers that replace each editing root. Each wrapper contains the document source from the corresponding
	 * root.
	 *
	 * The wrapper element contains a textarea and it solves the problem, that the textarea element cannot auto expand its height based on
	 * the content it contains. The solution is to make the textarea more like a plain div element, which expands in height as much as it
	 * needs to, in order to display the whole document source without scrolling. The wrapper element is a parent for the textarea and for
	 * the pseudo-element `::after`, that replicates the look, content, and position of the textarea. The pseudo-element replica is hidden,
	 * but it is styled to be an identical visual copy of the textarea with the same content. Then, the wrapper is a grid container and both
	 * of its children (the textarea and the `::after` pseudo-element) are positioned within a CSS grid to occupy the same grid cell. The
	 * content in the pseudo-element `::after` is set in CSS and it stretches the grid to the appropriate size based on the textarea value.
	 * Since both children occupy the same grid cell, both have always the same height.
	 */ _showSourceEditing() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        const model = editor.model;
        model.change((writer)=>{
            writer.setSelection(null);
            writer.removeSelectionAttribute(model.document.selection.getAttributeKeys());
        });
        // It is not needed to iterate through all editing roots, as currently the plugin supports only the Classic Editor with a single
        // main root, but this code may help understand and use this feature in external integrations.
        for (const [rootName, domRootElement] of editingView.domRoots){
            const data = formatSource(editor.data.get({
                rootName
            }));
            const domSourceEditingElementTextarea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(domRootElement.ownerDocument, 'textarea', {
                rows: '1',
                'aria-label': 'Source code editing area'
            });
            const domSourceEditingElementWrapper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(domRootElement.ownerDocument, 'div', {
                class: 'ck-source-editing-area',
                'data-value': data
            }, [
                domSourceEditingElementTextarea
            ]);
            domSourceEditingElementTextarea.value = data;
            // Setting a value to textarea moves the input cursor to the end. We want the selection at the beginning.
            domSourceEditingElementTextarea.setSelectionRange(0, 0);
            // Bind the textarea's value to the wrapper's `data-value` property. Each change of the textarea's value updates the
            // wrapper's `data-value` property.
            domSourceEditingElementTextarea.addEventListener('input', ()=>{
                domSourceEditingElementWrapper.dataset.value = domSourceEditingElementTextarea.value;
                editor.ui.update();
            });
            editingView.change((writer)=>{
                const viewRoot = editingView.document.getRoot(rootName);
                writer.addClass('ck-hidden', viewRoot);
            });
            // Register the element so it becomes available for Alt+F10 and Esc navigation.
            editor.ui.setEditableElement('sourceEditing:' + rootName, domSourceEditingElementTextarea);
            this._replacedRoots.set(rootName, domSourceEditingElementWrapper);
            this._elementReplacer.replace(domRootElement, domSourceEditingElementWrapper);
            this._dataFromRoots.set(rootName, data);
        }
        this._focusSourceEditing();
    }
    /**
	 * Restores all hidden editing roots and sets the source data in them.
	 */ _hideSourceEditing() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        this.updateEditorData();
        editingView.change((writer)=>{
            for (const [rootName] of this._replacedRoots){
                writer.removeClass('ck-hidden', editingView.document.getRoot(rootName));
            }
        });
        this._elementReplacer.restore();
        this._replacedRoots.clear();
        this._dataFromRoots.clear();
        editingView.focus();
    }
    /**
	 * Focuses the textarea containing document source from the first editing root.
	 */ _focusSourceEditing() {
        const editor = this.editor;
        const [domSourceEditingElementWrapper] = this._replacedRoots.values();
        const textarea = domSourceEditingElementWrapper.querySelector('textarea');
        // The FocusObserver was disabled by View.render() while the DOM root was getting hidden and the replacer
        // revealed the textarea. So it couldn't notice that the DOM root got blurred in the process.
        // Let's sync this state manually here because otherwise Renderer will attempt to render selection
        // in an invisible DOM root.
        editor.editing.view.document.isFocused = false;
        textarea.focus();
    }
    /**
	 * Disables all commands.
	 */ _disableCommands() {
        const editor = this.editor;
        for (const command of editor.commands.commands()){
            command.forceDisabled(COMMAND_FORCE_DISABLE_ID);
        }
        // Comments archive UI plugin will be disabled manually too.
        if (editor.plugins.has('CommentsArchiveUI')) {
            editor.plugins.get('CommentsArchiveUI').forceDisabled(COMMAND_FORCE_DISABLE_ID);
        }
    }
    /**
	 * Clears forced disable for all commands, that was previously set through {@link #_disableCommands}.
	 */ _enableCommands() {
        const editor = this.editor;
        for (const command of editor.commands.commands()){
            command.clearForceDisabled(COMMAND_FORCE_DISABLE_ID);
        }
        // Comments archive UI plugin will be enabled manually too.
        if (editor.plugins.has('CommentsArchiveUI')) {
            editor.plugins.get('CommentsArchiveUI').clearForceDisabled(COMMAND_FORCE_DISABLE_ID);
        }
    }
    /**
	 * Adds or removes the `readonly` attribute from the textarea from all roots, if document source mode is active.
	 *
	 * @param isReadOnly Indicates whether all textarea elements should be read-only.
	 */ _handleReadOnlyMode(isReadOnly) {
        if (!this.isSourceEditingMode) {
            return;
        }
        for (const [, domSourceEditingElementWrapper] of this._replacedRoots){
            domSourceEditingElementWrapper.querySelector('textarea').readOnly = isReadOnly;
        }
    }
    /**
	 * Checks, if the plugin is allowed to handle the source editing mode by itself. Currently, the source editing mode is supported only
	 * for the {@link module:editor-classic/classiceditor~ClassicEditor classic editor}.
	 */ _isAllowedToHandleSourceEditingMode() {
        const editor = this.editor;
        const editable = editor.ui.view.editable;
        // Checks, if the editor's editable belongs to the editor's DOM tree.
        return editable && !editable.hasExternalElement;
    }
    /**
	 * If any {@link module:ui/dialog/dialogview~DialogView editor dialog} is currently visible, hide it.
	 */ _hideVisibleDialog() {
        if (this.editor.plugins.has('Dialog')) {
            const dialogPlugin = this.editor.plugins.get('Dialog');
            if (dialogPlugin.isOpen) {
                dialogPlugin.hide();
            }
        }
    }
    _createButton(ButtonClass) {
        const editor = this.editor;
        const buttonView = new ButtonClass(editor.locale);
        buttonView.set({
            withText: true,
            isToggleable: true
        });
        buttonView.bind('isOn').to(this, 'isSourceEditingMode');
        // The button should be disabled if one of the following conditions is met:
        buttonView.bind('isEnabled').to(this, 'isEnabled', editor, 'isReadOnly', editor.plugins.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PendingActions"]), 'hasAny', (isEnabled, isEditorReadOnly, hasAnyPendingActions)=>{
            // (1) The plugin itself is disabled.
            if (!isEnabled) {
                return false;
            }
            // (2) The editor is in read-only mode.
            if (isEditorReadOnly) {
                return false;
            }
            // (3) Any pending action is scheduled. It may change the model, so modifying the document source should be prevented
            // until the model is finally set.
            if (hasAnyPendingActions) {
                return false;
            }
            return true;
        });
        this.listenTo(buttonView, 'execute', ()=>{
            this.isSourceEditingMode = !this.isSourceEditingMode;
        });
        return buttonView;
    }
}
/**
 * Formats the content for a better readability.
 *
 * For a non-HTML source the unchanged input string is returned.
 *
 * @param input Input string to check.
 */ function formatSource(input) {
    if (!isHtml(input)) {
        return input;
    }
    return formatHtml(input);
}
/**
 * Checks, if the document source is HTML. It is sufficient to just check the first character from the document data.
 *
 * @param input Input string to check.
 */ function isHtml(input) {
    return input.startsWith('<');
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-special-characters/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "SpecialCharacters": (()=>SpecialCharacters),
    "SpecialCharactersArrows": (()=>SpecialCharactersArrows),
    "SpecialCharactersCurrency": (()=>SpecialCharactersCurrency),
    "SpecialCharactersEssentials": (()=>SpecialCharactersEssentials),
    "SpecialCharactersLatin": (()=>SpecialCharactersLatin),
    "SpecialCharactersMathematical": (()=>SpecialCharactersMathematical),
    "SpecialCharactersText": (()=>SpecialCharactersText)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-typing/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
;
;
;
;
/**
 * A grid of character tiles. It allows browsing special characters and selecting the character to
 * be inserted into the content.
 */ class CharacterGridView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * A collection of the child tile views. Each tile represents a particular character.
	 */ tiles;
    /**
	 * Tracks information about the DOM focus in the grid.
	 */ focusTracker;
    /**
	 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
	 */ keystrokes;
    /**
	 * Creates an instance of a character grid containing tiles representing special characters.
	 *
	 * @param locale The localization services instance.
	 */ constructor(locale){
        super(locale);
        this.tiles = this.createCollection();
        this.setTemplate({
            tag: 'div',
            children: [
                {
                    tag: 'div',
                    attributes: {
                        class: [
                            'ck',
                            'ck-character-grid__tiles'
                        ]
                    },
                    children: this.tiles
                }
            ],
            attributes: {
                class: [
                    'ck',
                    'ck-character-grid'
                ]
            }
        });
        this.focusTracker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusTracker"]();
        this.keystrokes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeystrokeHandler"]();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addKeyboardHandlingForGrid"])({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.tiles,
            numberOfColumns: ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window.getComputedStyle(this.element.firstChild) // Responsive .ck-character-grid__tiles
                .getPropertyValue('grid-template-columns').split(' ').length,
            uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
        });
    }
    /**
	 * Creates a new tile for the grid.
	 *
	 * @param character A human-readable character displayed as the label (e.g. "ε").
	 * @param name The name of the character (e.g. "greek small letter epsilon").
	 */ createTile(character, name) {
        const tile = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](this.locale);
        tile.set({
            label: character,
            withText: true,
            class: 'ck-character-grid__tile'
        });
        // Labels are vital for the users to understand what character they're looking at.
        // For now we're using native title attribute for that, see #5817.
        tile.extendTemplate({
            attributes: {
                title: name
            },
            on: {
                mouseover: tile.bindTemplate.to('mouseover'),
                focus: tile.bindTemplate.to('focus')
            }
        });
        tile.on('mouseover', ()=>{
            this.fire('tileHover', {
                name,
                character
            });
        });
        tile.on('focus', ()=>{
            this.fire('tileFocus', {
                name,
                character
            });
        });
        tile.on('execute', ()=>{
            this.fire('execute', {
                name,
                character
            });
        });
        return tile;
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        for (const item of this.tiles){
            this.focusTracker.add(item.element);
        }
        this.tiles.on('change', (eventInfo, { added, removed })=>{
            if (added.length > 0) {
                for (const item of added){
                    this.focusTracker.add(item.element);
                }
            }
            if (removed.length > 0) {
                for (const item of removed){
                    this.focusTracker.remove(item.element);
                }
            }
        });
        this.keystrokes.listenTo(this.element);
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this.keystrokes.destroy();
    }
    /**
	 * Focuses the first focusable in {@link ~CharacterGridView#tiles}.
	 */ focus() {
        this.tiles.first.focus();
    }
}
/**
 * The view displaying detailed information about a special character glyph, e.g. upon
 * hovering it with a mouse.
 */ class CharacterInfoView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    constructor(locale){
        super(locale);
        const bind = this.bindTemplate;
        this.set('character', null);
        this.set('name', null);
        this.bind('code').to(this, 'character', characterToUnicodeString);
        this.setTemplate({
            tag: 'div',
            children: [
                {
                    tag: 'span',
                    attributes: {
                        class: [
                            'ck-character-info__name'
                        ]
                    },
                    children: [
                        {
                            // Note: ZWSP to prevent vertical collapsing.
                            text: bind.to('name', (name)=>name ? name : '\u200B')
                        }
                    ]
                },
                {
                    tag: 'span',
                    attributes: {
                        class: [
                            'ck-character-info__code'
                        ]
                    },
                    children: [
                        {
                            text: bind.to('code')
                        }
                    ]
                }
            ],
            attributes: {
                class: [
                    'ck',
                    'ck-character-info'
                ]
            }
        });
    }
}
/**
 * Converts a character into a "Unicode string", for instance:
 *
 * "$" -> "U+0024"
 *
 * Returns an empty string when the character is `null`.
 */ function characterToUnicodeString(character) {
    if (character === null) {
        return '';
    }
    const hexCode = character.codePointAt(0).toString(16);
    return 'U+' + ('0000' + hexCode).slice(-4);
}
/**
 * A view that glues pieces of the special characters dropdown panel together:
 *
 * * the navigation view (allows selecting the category),
 * * the grid view (displays characters as a grid),
 * * and the info view (displays detailed info about a specific character).
 */ class SpecialCharactersView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * A collection of the focusable children of the view.
	 */ items;
    /**
	 * Tracks information about the DOM focus in the view.
	 */ focusTracker;
    /**
	 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
	 */ keystrokes;
    /**
	 * Helps cycling over focusable {@link #items} in the view.
	 */ _focusCycler;
    /**
	 * An instance of the `SpecialCharactersCategoriesView`.
	 */ categoriesView;
    /**
	 * An instance of the `CharacterGridView`.
	 */ gridView;
    /**
	 * An instance of the `CharacterInfoView`.
	 */ infoView;
    /**
	 * Creates an instance of the `SpecialCharactersView`.
	 */ constructor(locale, categoriesView, gridView, infoView){
        super(locale);
        this.categoriesView = categoriesView;
        this.gridView = gridView;
        this.infoView = infoView;
        this.items = this.createCollection();
        this.focusTracker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusTracker"]();
        this.keystrokes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeystrokeHandler"]();
        this._focusCycler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusCycler"]({
            focusables: this.items,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
                focusPrevious: 'shift + tab',
                focusNext: 'tab'
            }
        });
        this.setTemplate({
            tag: 'div',
            children: [
                this.categoriesView,
                this.gridView,
                this.infoView
            ],
            attributes: {
                // Avoid focus loss when the user clicks the area of the grid that is not a button.
                // https://github.com/ckeditor/ckeditor5/pull/12319#issuecomment-1231779819
                tabindex: '-1'
            }
        });
        this.items.add(this.categoriesView);
        this.items.add(this.gridView);
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        this.focusTracker.add(this.categoriesView.element);
        this.focusTracker.add(this.gridView.element);
        // Start listening for the keystrokes coming from #element.
        this.keystrokes.listenTo(this.element);
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
    }
    /**
	 * Focuses the first focusable in {@link #items}.
	 */ focus() {
        this._focusCycler.focusFirst();
    }
}
var specialCharactersIcon = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10 2.5a7.47 7.47 0 0 1 4.231 1.31 7.268 7.268 0 0 1 2.703 3.454 7.128 7.128 0 0 1 .199 4.353c-.39 1.436-1.475 2.72-2.633 3.677h2.013c0-.226.092-.443.254-.603a.876.876 0 0 1 1.229 0c.163.16.254.377.254.603v.853c0 .209-.078.41-.22.567a.873.873 0 0 1-.547.28l-.101.006h-4.695a.517.517 0 0 1-.516-.518v-1.265c0-.21.128-.398.317-.489a5.601 5.601 0 0 0 2.492-2.371 5.459 5.459 0 0 0 .552-3.693 5.53 5.53 0 0 0-1.955-3.2A5.71 5.71 0 0 0 10 4.206 5.708 5.708 0 0 0 6.419 5.46 5.527 5.527 0 0 0 4.46 8.663a5.457 5.457 0 0 0 .554 3.695 5.6 5.6 0 0 0 2.497 2.37.55.55 0 0 1 .317.49v1.264c0 .286-.23.518-.516.518H2.618a.877.877 0 0 1-.614-.25.845.845 0 0 1-.254-.603v-.853c0-.226.091-.443.254-.603a.876.876 0 0 1 1.228 0c.163.16.255.377.255.603h1.925c-1.158-.958-2.155-2.241-2.545-3.678a7.128 7.128 0 0 1 .199-4.352 7.268 7.268 0 0 1 2.703-3.455A7.475 7.475 0 0 1 10 2.5z\"/></svg>";
/**
 * A class representing the navigation part of the special characters UI. It is responsible
 * for describing the feature and allowing the user to select a particular character group.
 */ class SpecialCharactersCategoriesView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    _groupNames;
    _dropdownView;
    /**
	 * Creates an instance of the {@link module:special-characters/ui/specialcharacterscategoriesview~SpecialCharactersCategoriesView}
	 * class.
	 *
	 * @param locale The localization services instance.
	 * @param groupNames The names of the character groups.
	 */ constructor(locale, groupNames){
        super(locale);
        this.set('currentGroupName', Array.from(groupNames.entries())[0][0]);
        this._groupNames = groupNames;
        this._dropdownView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LabeledFieldView"](locale, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLabeledDropdown"]);
        this.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-character-categories'
                ]
            },
            children: [
                this._dropdownView
            ]
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        this._setupDropdown();
    }
    /**
	 * @inheritDoc
	 */ focus() {
        this._dropdownView.focus();
    }
    /**
	 * Creates dropdown item list, sets up bindings and fills properties.
	 */ _setupDropdown() {
        const items = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"]();
        for (const [name, label] of this._groupNames){
            const item = {
                type: 'button',
                model: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewModel"]({
                    name,
                    label,
                    role: 'menuitemradio',
                    withText: true
                })
            };
            item.model.bind('isOn').to(this, 'currentGroupName', (value)=>{
                return value === name;
            });
            items.add(item);
        }
        const t = this.locale.t;
        const accessibleLabel = t('Category');
        this._dropdownView.set({
            label: accessibleLabel,
            isEmpty: false
        });
        this._dropdownView.fieldView.panelPosition = this.locale.uiLanguageDirection === 'rtl' ? 'se' : 'sw';
        this._dropdownView.fieldView.buttonView.set({
            withText: true,
            tooltip: accessibleLabel,
            ariaLabel: accessibleLabel,
            ariaLabelledBy: undefined,
            isOn: false
        });
        this._dropdownView.fieldView.buttonView.bind('label').to(this, 'currentGroupName', (value)=>this._groupNames.get(value));
        this._dropdownView.fieldView.on('execute', ({ source })=>{
            this.currentGroupName = source.name;
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addListToDropdown"])(this._dropdownView.fieldView, items, {
            ariaLabel: accessibleLabel,
            role: 'menu'
        });
    }
}
const ALL_SPECIAL_CHARACTERS_GROUP = 'All';
/**
 * The special characters feature.
 *
 * Introduces the `'specialCharacters'` dropdown.
 */ class SpecialCharacters extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * Registered characters. A pair of a character name and its symbol.
	 */ _characters;
    /**
	 * Registered groups. Each group contains a displayed label and a collection with symbol names.
	 */ _groups;
    /**
	 * A label describing the "All" special characters category.
	 */ _allSpecialCharactersGroupLabel;
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Typing"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Dialog"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SpecialCharacters';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        const t = editor.t;
        this._characters = new Map();
        this._groups = new Map();
        this._allSpecialCharactersGroupLabel = t('All');
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.ui.componentFactory.add('specialCharacters', ()=>{
            const button = this._createDialogButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]);
            button.set({
                tooltip: true
            });
            return button;
        });
        editor.ui.componentFactory.add('menuBar:specialCharacters', ()=>{
            return this._createDialogButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"]);
        });
    }
    /**
	 * Adds a collection of special characters to the specified group. The title of a special character must be unique.
	 *
	 * **Note:** The "All" category name is reserved by the plugin and cannot be used as a new name for a special
	 * characters category.
	 */ addItems(groupName, items, options = {
        label: groupName
    }) {
        if (groupName === ALL_SPECIAL_CHARACTERS_GROUP) {
            /**
			 * The name "All" for a special category group cannot be used because it is a special category that displays all
			 * available special characters.
			 *
			 * @error special-character-invalid-group-name
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('special-character-invalid-group-name', null);
        }
        const group = this._getGroup(groupName, options.label);
        for (const item of items){
            group.items.add(item.title);
            this._characters.set(item.title, item.character);
        }
    }
    /**
	 * Returns special character groups in an order determined based on configuration and registration sequence.
	 */ getGroups() {
        const groups = Array.from(this._groups.keys());
        const order = this.editor.config.get('specialCharacters.order') || [];
        const invalidGroup = order.find((item)=>!groups.includes(item));
        if (invalidGroup) {
            /**
			 * One of the special character groups in the "specialCharacters.order" configuration doesn't exist.
			 *
			 * @error special-character-invalid-order-group-name
			 */ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CKEditorError"]('special-character-invalid-order-group-name', null, {
                invalidGroup
            });
        }
        return new Set([
            ...order,
            ...groups
        ]);
    }
    /**
	 * Returns a collection of special characters symbol names (titles).
	 */ getCharactersForGroup(groupName) {
        if (groupName === ALL_SPECIAL_CHARACTERS_GROUP) {
            return new Set(this._characters.keys());
        }
        const group = this._groups.get(groupName);
        if (group) {
            return group.items;
        }
    }
    /**
	 * Returns the symbol of a special character for the specified name. If the special character could not be found, `undefined`
	 * is returned.
	 *
	 * @param title The title of a special character.
	 */ getCharacter(title) {
        return this._characters.get(title);
    }
    /**
	 * Returns a group of special characters. If the group with the specified name does not exist, it will be created.
	 *
	 * @param groupName The name of the group to create.
	 * @param label The label describing the new group.
	 */ _getGroup(groupName, label) {
        if (!this._groups.has(groupName)) {
            this._groups.set(groupName, {
                items: new Set(),
                label
            });
        }
        return this._groups.get(groupName);
    }
    /**
	 * Updates the symbol grid depending on the currently selected character group.
	 */ _updateGrid(currentGroupName, gridView) {
        // Updating the grid starts with removing all tiles belonging to the old group.
        gridView.tiles.clear();
        const characterTitles = this.getCharactersForGroup(currentGroupName);
        for (const title of characterTitles){
            const character = this.getCharacter(title);
            gridView.tiles.add(gridView.createTile(character, title));
        }
    }
    /**
	 * Initializes the dropdown, used for lazy loading.
	 *
	 * @returns An object with `categoriesView`, `gridView` and `infoView` properties, containing UI parts.
	 */ _createDropdownPanelContent(locale) {
        const groupEntries = Array.from(this.getGroups()).map((name)=>[
                name,
                this._groups.get(name).label
            ]);
        // The map contains a name of category (an identifier) and its label (a translational string).
        const specialCharsGroups = new Map([
            // Add a special group that shows all available special characters.
            [
                ALL_SPECIAL_CHARACTERS_GROUP,
                this._allSpecialCharactersGroupLabel
            ],
            ...groupEntries
        ]);
        const categoriesView = new SpecialCharactersCategoriesView(locale, specialCharsGroups);
        const gridView = new CharacterGridView(locale);
        const infoView = new CharacterInfoView(locale);
        gridView.on('tileHover', (evt, data)=>{
            infoView.set(data);
        });
        gridView.on('tileFocus', (evt, data)=>{
            infoView.set(data);
        });
        // Update the grid of special characters when a user changed the character group.
        categoriesView.on('change:currentGroupName', (evt, propertyName, newValue)=>{
            this._updateGrid(newValue, gridView);
        });
        // Set the initial content of the special characters grid.
        this._updateGrid(categoriesView.currentGroupName, gridView);
        return {
            categoriesView,
            gridView,
            infoView
        };
    }
    /**
	 * Creates a button for toolbar and menu bar that will show special characters dialog.
	 */ _createDialogButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const buttonView = new ButtonClass(editor.locale);
        const command = editor.commands.get('insertText');
        const t = locale.t;
        const dialogPlugin = this.editor.plugins.get('Dialog');
        buttonView.set({
            label: t('Special characters'),
            icon: specialCharactersIcon,
            isToggleable: true
        });
        buttonView.bind('isOn').to(dialogPlugin, 'id', (id)=>id === 'specialCharacters');
        buttonView.bind('isEnabled').to(command, 'isEnabled');
        buttonView.on('execute', ()=>{
            if (dialogPlugin.id === 'specialCharacters') {
                dialogPlugin.hide();
                return;
            }
            this._showDialog();
        });
        return buttonView;
    }
    _showDialog() {
        const editor = this.editor;
        const dialog = editor.plugins.get('Dialog');
        const locale = editor.locale;
        const t = locale.t;
        const { categoriesView, gridView, infoView } = this._createDropdownPanelContent(locale);
        const content = new SpecialCharactersView(locale, categoriesView, gridView, infoView);
        gridView.on('execute', (evt, data)=>{
            editor.execute('insertText', {
                text: data.character
            });
        });
        dialog.show({
            id: 'specialCharacters',
            title: t('Special characters'),
            className: 'ck-special-characters',
            content,
            position: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DialogViewPosition"].EDITOR_TOP_SIDE
        });
    }
}
/**
 * A plugin that provides special characters for the "Arrows" category.
 *
 * ```ts
 * ClassicEditor
 *   .create( {
 *     plugins: [ ..., SpecialCharacters, SpecialCharactersArrows ],
 *   } )
 *   .then( ... )
 *   .catch( ... );
 * ```
 */ class SpecialCharactersArrows extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SpecialCharactersArrows';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        const plugin = editor.plugins.get('SpecialCharacters');
        plugin.addItems('Arrows', [
            {
                title: t('leftwards simple arrow'),
                character: '←'
            },
            {
                title: t('rightwards simple arrow'),
                character: '→'
            },
            {
                title: t('upwards simple arrow'),
                character: '↑'
            },
            {
                title: t('downwards simple arrow'),
                character: '↓'
            },
            {
                title: t('leftwards double arrow'),
                character: '⇐'
            },
            {
                title: t('rightwards double arrow'),
                character: '⇒'
            },
            {
                title: t('upwards double arrow'),
                character: '⇑'
            },
            {
                title: t('downwards double arrow'),
                character: '⇓'
            },
            {
                title: t('leftwards dashed arrow'),
                character: '⇠'
            },
            {
                title: t('rightwards dashed arrow'),
                character: '⇢'
            },
            {
                title: t('upwards dashed arrow'),
                character: '⇡'
            },
            {
                title: t('downwards dashed arrow'),
                character: '⇣'
            },
            {
                title: t('leftwards arrow to bar'),
                character: '⇤'
            },
            {
                title: t('rightwards arrow to bar'),
                character: '⇥'
            },
            {
                title: t('upwards arrow to bar'),
                character: '⤒'
            },
            {
                title: t('downwards arrow to bar'),
                character: '⤓'
            },
            {
                title: t('up down arrow with base'),
                character: '↨'
            },
            {
                title: t('back with leftwards arrow above'),
                character: '🔙'
            },
            {
                title: t('end with leftwards arrow above'),
                character: '🔚'
            },
            {
                title: t('on with exclamation mark with left right arrow above'),
                character: '🔛'
            },
            {
                title: t('soon with rightwards arrow above'),
                character: '🔜'
            },
            {
                title: t('top with upwards arrow above'),
                character: '🔝'
            }
        ], {
            label: t('Arrows')
        });
    }
}
/**
 * A plugin that provides special characters for the "Text" category.
 *
 * ```ts
 * ClassicEditor
 *   .create( {
 *     plugins: [ ..., SpecialCharacters, SpecialCharactersText ],
 *   } )
 *   .then( ... )
 *   .catch( ... );
 * ```
 */ class SpecialCharactersText extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SpecialCharactersText';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        const plugin = editor.plugins.get('SpecialCharacters');
        plugin.addItems('Text', [
            {
                character: '‹',
                title: t('Single left-pointing angle quotation mark')
            },
            {
                character: '›',
                title: t('Single right-pointing angle quotation mark')
            },
            {
                character: '«',
                title: t('Left-pointing double angle quotation mark')
            },
            {
                character: '»',
                title: t('Right-pointing double angle quotation mark')
            },
            {
                character: '‘',
                title: t('Left single quotation mark')
            },
            {
                character: '’',
                title: t('Right single quotation mark')
            },
            {
                character: '“',
                title: t('Left double quotation mark')
            },
            {
                character: '”',
                title: t('Right double quotation mark')
            },
            {
                character: '‚',
                title: t('Single low-9 quotation mark')
            },
            {
                character: '„',
                title: t('Double low-9 quotation mark')
            },
            {
                character: '¡',
                title: t('Inverted exclamation mark')
            },
            {
                character: '¿',
                title: t('Inverted question mark')
            },
            {
                character: '‥',
                title: t('Two dot leader')
            },
            {
                character: '…',
                title: t('Horizontal ellipsis')
            },
            {
                character: '‡',
                title: t('Double dagger')
            },
            {
                character: '‰',
                title: t('Per mille sign')
            },
            {
                character: '‱',
                title: t('Per ten thousand sign')
            },
            {
                character: '‼',
                title: t('Double exclamation mark')
            },
            {
                character: '⁈',
                title: t('Question exclamation mark')
            },
            {
                character: '⁉',
                title: t('Exclamation question mark')
            },
            {
                character: '⁇',
                title: t('Double question mark')
            },
            {
                character: '©',
                title: t('Copyright sign')
            },
            {
                character: '®',
                title: t('Registered sign')
            },
            {
                character: '™',
                title: t('Trade mark sign')
            },
            {
                character: '§',
                title: t('Section sign')
            },
            {
                character: '¶',
                title: t('Paragraph sign')
            },
            {
                character: '⁋',
                title: t('Reversed paragraph sign')
            }
        ], {
            label: t('Text')
        });
    }
}
/**
 * A plugin that provides special characters for the "Mathematical" category.
 *
 * ```ts
 * ClassicEditor
 *   .create( {
 *     plugins: [ ..., SpecialCharacters, SpecialCharactersMathematical ],
 *   } )
 *   .then( ... )
 *   .catch( ... );
 * ```
 */ class SpecialCharactersMathematical extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SpecialCharactersMathematical';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        const plugin = editor.plugins.get('SpecialCharacters');
        plugin.addItems('Mathematical', [
            {
                character: '<',
                title: t('Less-than sign')
            },
            {
                character: '>',
                title: t('Greater-than sign')
            },
            {
                character: '≤',
                title: t('Less-than or equal to')
            },
            {
                character: '≥',
                title: t('Greater-than or equal to')
            },
            {
                character: '–',
                title: t('En dash')
            },
            {
                character: '—',
                title: t('Em dash')
            },
            {
                character: '¯',
                title: t('Macron')
            },
            {
                character: '‾',
                title: t('Overline')
            },
            {
                character: '°',
                title: t('Degree sign')
            },
            {
                character: '−',
                title: t('Minus sign')
            },
            {
                character: '±',
                title: t('Plus-minus sign')
            },
            {
                character: '÷',
                title: t('Division sign')
            },
            {
                character: '⁄',
                title: t('Fraction slash')
            },
            {
                character: '×',
                title: t('Multiplication sign')
            },
            {
                character: 'ƒ',
                title: t('Latin small letter f with hook')
            },
            {
                character: '∫',
                title: t('Integral')
            },
            {
                character: '∑',
                title: t('N-ary summation')
            },
            {
                character: '∞',
                title: t('Infinity')
            },
            {
                character: '√',
                title: t('Square root')
            },
            {
                character: '∼',
                title: t('Tilde operator')
            },
            {
                character: '≅',
                title: t('Approximately equal to')
            },
            {
                character: '≈',
                title: t('Almost equal to')
            },
            {
                character: '≠',
                title: t('Not equal to')
            },
            {
                character: '≡',
                title: t('Identical to')
            },
            {
                character: '∈',
                title: t('Element of')
            },
            {
                character: '∉',
                title: t('Not an element of')
            },
            {
                character: '∋',
                title: t('Contains as member')
            },
            {
                character: '∏',
                title: t('N-ary product')
            },
            {
                character: '∧',
                title: t('Logical and')
            },
            {
                character: '∨',
                title: t('Logical or')
            },
            {
                character: '¬',
                title: t('Not sign')
            },
            {
                character: '∩',
                title: t('Intersection')
            },
            {
                character: '∪',
                title: t('Union')
            },
            {
                character: '∂',
                title: t('Partial differential')
            },
            {
                character: '∀',
                title: t('For all')
            },
            {
                character: '∃',
                title: t('There exists')
            },
            {
                character: '∅',
                title: t('Empty set')
            },
            {
                character: '∇',
                title: t('Nabla')
            },
            {
                character: '∗',
                title: t('Asterisk operator')
            },
            {
                character: '∝',
                title: t('Proportional to')
            },
            {
                character: '∠',
                title: t('Angle')
            },
            {
                character: '¼',
                title: t('Vulgar fraction one quarter')
            },
            {
                character: '½',
                title: t('Vulgar fraction one half')
            },
            {
                character: '¾',
                title: t('Vulgar fraction three quarters')
            }
        ], {
            label: t('Mathematical')
        });
    }
}
/**
 * A plugin that provides special characters for the "Latin" category.
 *
 * ```ts
 * ClassicEditor
 *   .create( {
 *     plugins: [ ..., SpecialCharacters, SpecialCharactersLatin ],
 *   } )
 *   .then( ... )
 *   .catch( ... );
 * ```
 */ class SpecialCharactersLatin extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SpecialCharactersLatin';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        const plugin = editor.plugins.get('SpecialCharacters');
        plugin.addItems('Latin', [
            {
                character: 'Ā',
                title: t('Latin capital letter a with macron')
            },
            {
                character: 'ā',
                title: t('Latin small letter a with macron')
            },
            {
                character: 'Ă',
                title: t('Latin capital letter a with breve')
            },
            {
                character: 'ă',
                title: t('Latin small letter a with breve')
            },
            {
                character: 'Ą',
                title: t('Latin capital letter a with ogonek')
            },
            {
                character: 'ą',
                title: t('Latin small letter a with ogonek')
            },
            {
                character: 'Ć',
                title: t('Latin capital letter c with acute')
            },
            {
                character: 'ć',
                title: t('Latin small letter c with acute')
            },
            {
                character: 'Ĉ',
                title: t('Latin capital letter c with circumflex')
            },
            {
                character: 'ĉ',
                title: t('Latin small letter c with circumflex')
            },
            {
                character: 'Ċ',
                title: t('Latin capital letter c with dot above')
            },
            {
                character: 'ċ',
                title: t('Latin small letter c with dot above')
            },
            {
                character: 'Č',
                title: t('Latin capital letter c with caron')
            },
            {
                character: 'č',
                title: t('Latin small letter c with caron')
            },
            {
                character: 'Ď',
                title: t('Latin capital letter d with caron')
            },
            {
                character: 'ď',
                title: t('Latin small letter d with caron')
            },
            {
                character: 'Đ',
                title: t('Latin capital letter d with stroke')
            },
            {
                character: 'đ',
                title: t('Latin small letter d with stroke')
            },
            {
                character: 'Ē',
                title: t('Latin capital letter e with macron')
            },
            {
                character: 'ē',
                title: t('Latin small letter e with macron')
            },
            {
                character: 'Ĕ',
                title: t('Latin capital letter e with breve')
            },
            {
                character: 'ĕ',
                title: t('Latin small letter e with breve')
            },
            {
                character: 'Ė',
                title: t('Latin capital letter e with dot above')
            },
            {
                character: 'ė',
                title: t('Latin small letter e with dot above')
            },
            {
                character: 'Ę',
                title: t('Latin capital letter e with ogonek')
            },
            {
                character: 'ę',
                title: t('Latin small letter e with ogonek')
            },
            {
                character: 'Ě',
                title: t('Latin capital letter e with caron')
            },
            {
                character: 'ě',
                title: t('Latin small letter e with caron')
            },
            {
                character: 'Ĝ',
                title: t('Latin capital letter g with circumflex')
            },
            {
                character: 'ĝ',
                title: t('Latin small letter g with circumflex')
            },
            {
                character: 'Ğ',
                title: t('Latin capital letter g with breve')
            },
            {
                character: 'ğ',
                title: t('Latin small letter g with breve')
            },
            {
                character: 'Ġ',
                title: t('Latin capital letter g with dot above')
            },
            {
                character: 'ġ',
                title: t('Latin small letter g with dot above')
            },
            {
                character: 'Ģ',
                title: t('Latin capital letter g with cedilla')
            },
            {
                character: 'ģ',
                title: t('Latin small letter g with cedilla')
            },
            {
                character: 'Ĥ',
                title: t('Latin capital letter h with circumflex')
            },
            {
                character: 'ĥ',
                title: t('Latin small letter h with circumflex')
            },
            {
                character: 'Ħ',
                title: t('Latin capital letter h with stroke')
            },
            {
                character: 'ħ',
                title: t('Latin small letter h with stroke')
            },
            {
                character: 'Ĩ',
                title: t('Latin capital letter i with tilde')
            },
            {
                character: 'ĩ',
                title: t('Latin small letter i with tilde')
            },
            {
                character: 'Ī',
                title: t('Latin capital letter i with macron')
            },
            {
                character: 'ī',
                title: t('Latin small letter i with macron')
            },
            {
                character: 'Ĭ',
                title: t('Latin capital letter i with breve')
            },
            {
                character: 'ĭ',
                title: t('Latin small letter i with breve')
            },
            {
                character: 'Į',
                title: t('Latin capital letter i with ogonek')
            },
            {
                character: 'į',
                title: t('Latin small letter i with ogonek')
            },
            {
                character: 'İ',
                title: t('Latin capital letter i with dot above')
            },
            {
                character: 'ı',
                title: t('Latin small letter dotless i')
            },
            {
                character: 'Ĳ',
                title: t('Latin capital ligature ij')
            },
            {
                character: 'ĳ',
                title: t('Latin small ligature ij')
            },
            {
                character: 'Ĵ',
                title: t('Latin capital letter j with circumflex')
            },
            {
                character: 'ĵ',
                title: t('Latin small letter j with circumflex')
            },
            {
                character: 'Ķ',
                title: t('Latin capital letter k with cedilla')
            },
            {
                character: 'ķ',
                title: t('Latin small letter k with cedilla')
            },
            {
                character: 'ĸ',
                title: t('Latin small letter kra')
            },
            {
                character: 'Ĺ',
                title: t('Latin capital letter l with acute')
            },
            {
                character: 'ĺ',
                title: t('Latin small letter l with acute')
            },
            {
                character: 'Ļ',
                title: t('Latin capital letter l with cedilla')
            },
            {
                character: 'ļ',
                title: t('Latin small letter l with cedilla')
            },
            {
                character: 'Ľ',
                title: t('Latin capital letter l with caron')
            },
            {
                character: 'ľ',
                title: t('Latin small letter l with caron')
            },
            {
                character: 'Ŀ',
                title: t('Latin capital letter l with middle dot')
            },
            {
                character: 'ŀ',
                title: t('Latin small letter l with middle dot')
            },
            {
                character: 'Ł',
                title: t('Latin capital letter l with stroke')
            },
            {
                character: 'ł',
                title: t('Latin small letter l with stroke')
            },
            {
                character: 'Ń',
                title: t('Latin capital letter n with acute')
            },
            {
                character: 'ń',
                title: t('Latin small letter n with acute')
            },
            {
                character: 'Ņ',
                title: t('Latin capital letter n with cedilla')
            },
            {
                character: 'ņ',
                title: t('Latin small letter n with cedilla')
            },
            {
                character: 'Ň',
                title: t('Latin capital letter n with caron')
            },
            {
                character: 'ň',
                title: t('Latin small letter n with caron')
            },
            {
                character: 'ŉ',
                title: t('Latin small letter n preceded by apostrophe')
            },
            {
                character: 'Ŋ',
                title: t('Latin capital letter eng')
            },
            {
                character: 'ŋ',
                title: t('Latin small letter eng')
            },
            {
                character: 'Ō',
                title: t('Latin capital letter o with macron')
            },
            {
                character: 'ō',
                title: t('Latin small letter o with macron')
            },
            {
                character: 'Ŏ',
                title: t('Latin capital letter o with breve')
            },
            {
                character: 'ŏ',
                title: t('Latin small letter o with breve')
            },
            {
                character: 'Ő',
                title: t('Latin capital letter o with double acute')
            },
            {
                character: 'ő',
                title: t('Latin small letter o with double acute')
            },
            {
                character: 'Œ',
                title: t('Latin capital ligature oe')
            },
            {
                character: 'œ',
                title: t('Latin small ligature oe')
            },
            {
                character: 'Ŕ',
                title: t('Latin capital letter r with acute')
            },
            {
                character: 'ŕ',
                title: t('Latin small letter r with acute')
            },
            {
                character: 'Ŗ',
                title: t('Latin capital letter r with cedilla')
            },
            {
                character: 'ŗ',
                title: t('Latin small letter r with cedilla')
            },
            {
                character: 'Ř',
                title: t('Latin capital letter r with caron')
            },
            {
                character: 'ř',
                title: t('Latin small letter r with caron')
            },
            {
                character: 'Ś',
                title: t('Latin capital letter s with acute')
            },
            {
                character: 'ś',
                title: t('Latin small letter s with acute')
            },
            {
                character: 'Ŝ',
                title: t('Latin capital letter s with circumflex')
            },
            {
                character: 'ŝ',
                title: t('Latin small letter s with circumflex')
            },
            {
                character: 'Ş',
                title: t('Latin capital letter s with cedilla')
            },
            {
                character: 'ş',
                title: t('Latin small letter s with cedilla')
            },
            {
                character: 'Š',
                title: t('Latin capital letter s with caron')
            },
            {
                character: 'š',
                title: t('Latin small letter s with caron')
            },
            {
                character: 'Ţ',
                title: t('Latin capital letter t with cedilla')
            },
            {
                character: 'ţ',
                title: t('Latin small letter t with cedilla')
            },
            {
                character: 'Ť',
                title: t('Latin capital letter t with caron')
            },
            {
                character: 'ť',
                title: t('Latin small letter t with caron')
            },
            {
                character: 'Ŧ',
                title: t('Latin capital letter t with stroke')
            },
            {
                character: 'ŧ',
                title: t('Latin small letter t with stroke')
            },
            {
                character: 'Ũ',
                title: t('Latin capital letter u with tilde')
            },
            {
                character: 'ũ',
                title: t('Latin small letter u with tilde')
            },
            {
                character: 'Ū',
                title: t('Latin capital letter u with macron')
            },
            {
                character: 'ū',
                title: t('Latin small letter u with macron')
            },
            {
                character: 'Ŭ',
                title: t('Latin capital letter u with breve')
            },
            {
                character: 'ŭ',
                title: t('Latin small letter u with breve')
            },
            {
                character: 'Ů',
                title: t('Latin capital letter u with ring above')
            },
            {
                character: 'ů',
                title: t('Latin small letter u with ring above')
            },
            {
                character: 'Ű',
                title: t('Latin capital letter u with double acute')
            },
            {
                character: 'ű',
                title: t('Latin small letter u with double acute')
            },
            {
                character: 'Ų',
                title: t('Latin capital letter u with ogonek')
            },
            {
                character: 'ų',
                title: t('Latin small letter u with ogonek')
            },
            {
                character: 'Ŵ',
                title: t('Latin capital letter w with circumflex')
            },
            {
                character: 'ŵ',
                title: t('Latin small letter w with circumflex')
            },
            {
                character: 'Ŷ',
                title: t('Latin capital letter y with circumflex')
            },
            {
                character: 'ŷ',
                title: t('Latin small letter y with circumflex')
            },
            {
                character: 'Ÿ',
                title: t('Latin capital letter y with diaeresis')
            },
            {
                character: 'Ź',
                title: t('Latin capital letter z with acute')
            },
            {
                character: 'ź',
                title: t('Latin small letter z with acute')
            },
            {
                character: 'Ż',
                title: t('Latin capital letter z with dot above')
            },
            {
                character: 'ż',
                title: t('Latin small letter z with dot above')
            },
            {
                character: 'Ž',
                title: t('Latin capital letter z with caron')
            },
            {
                character: 'ž',
                title: t('Latin small letter z with caron')
            },
            {
                character: 'ſ',
                title: t('Latin small letter long s')
            }
        ], {
            label: t('Latin')
        });
    }
}
/**
 * A plugin that provides special characters for the "Currency" category.
 *
 * ```ts
 * ClassicEditor
 *   .create( {
 *     plugins: [ ..., SpecialCharacters, SpecialCharactersCurrency ],
 *   } )
 *   .then( ... )
 *   .catch( ... );
 * ```
 */ class SpecialCharactersCurrency extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SpecialCharactersCurrency';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const t = editor.t;
        const plugin = editor.plugins.get('SpecialCharacters');
        plugin.addItems('Currency', [
            {
                character: '$',
                title: t('Dollar sign')
            },
            {
                character: '€',
                title: t('Euro sign')
            },
            {
                character: '¥',
                title: t('Yen sign')
            },
            {
                character: '£',
                title: t('Pound sign')
            },
            {
                character: '¢',
                title: t('Cent sign')
            },
            {
                character: '₠',
                title: t('Euro-currency sign')
            },
            {
                character: '₡',
                title: t('Colon sign')
            },
            {
                character: '₢',
                title: t('Cruzeiro sign')
            },
            {
                character: '₣',
                title: t('French franc sign')
            },
            {
                character: '₤',
                title: t('Lira sign')
            },
            {
                character: '¤',
                title: t('Currency sign')
            },
            {
                character: '₿',
                title: t('Bitcoin sign')
            },
            {
                character: '₥',
                title: t('Mill sign')
            },
            {
                character: '₦',
                title: t('Naira sign')
            },
            {
                character: '₧',
                title: t('Peseta sign')
            },
            {
                character: '₨',
                title: t('Rupee sign')
            },
            {
                character: '₩',
                title: t('Won sign')
            },
            {
                character: '₪',
                title: t('New sheqel sign')
            },
            {
                character: '₫',
                title: t('Dong sign')
            },
            {
                character: '₭',
                title: t('Kip sign')
            },
            {
                character: '₮',
                title: t('Tugrik sign')
            },
            {
                character: '₯',
                title: t('Drachma sign')
            },
            {
                character: '₰',
                title: t('German penny sign')
            },
            {
                character: '₱',
                title: t('Peso sign')
            },
            {
                character: '₲',
                title: t('Guarani sign')
            },
            {
                character: '₳',
                title: t('Austral sign')
            },
            {
                character: '₴',
                title: t('Hryvnia sign')
            },
            {
                character: '₵',
                title: t('Cedi sign')
            },
            {
                character: '₶',
                title: t('Livre tournois sign')
            },
            {
                character: '₷',
                title: t('Spesmilo sign')
            },
            {
                character: '₸',
                title: t('Tenge sign')
            },
            {
                character: '₹',
                title: t('Indian rupee sign')
            },
            {
                character: '₺',
                title: t('Turkish lira sign')
            },
            {
                character: '₻',
                title: t('Nordic mark sign')
            },
            {
                character: '₼',
                title: t('Manat sign')
            },
            {
                character: '₽',
                title: t('Ruble sign')
            }
        ], {
            label: t('Currency')
        });
    }
}
/**
 * A plugin combining a basic set of characters for the special characters plugin.
 *
 * ```ts
 * ClassicEditor
 *   .create( {
 *     plugins: [ ..., SpecialCharacters, SpecialCharactersEssentials ],
 *   } )
 *   .then( ... )
 *   .catch( ... );
 * ```
 */ class SpecialCharactersEssentials extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'SpecialCharactersEssentials';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            SpecialCharactersCurrency,
            SpecialCharactersText,
            SpecialCharactersMathematical,
            SpecialCharactersArrows,
            SpecialCharactersLatin
        ];
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-style/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Style": (()=>Style),
    "StyleEditing": (()=>StyleEditing),
    "StyleUI": (()=>StyleUI),
    "StyleUtils": (()=>StyleUtils)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-typing/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isObject$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/isObject.js [app-client] (ecmascript) <export default as isObject>");
;
;
;
;
;
/**
 * A class representing an individual button (style) in the grid. Renders a rich preview of the style.
 */ class StyleGridButtonView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"] {
    /**
	 * Definition of the style the button will apply when executed.
	 */ styleDefinition;
    /**
	 * The view rendering the preview of the style.
	 */ previewView;
    /**
	 * Creates an instance of the {@link module:style/ui/stylegridbuttonview~StyleGridButtonView} class.
	 *
	 * @param locale The localization services instance.
	 * @param styleDefinition Definition of the style.
	 */ constructor(locale, styleDefinition){
        super(locale);
        this.styleDefinition = styleDefinition;
        this.previewView = this._createPreview();
        this.set({
            label: styleDefinition.name,
            class: 'ck-style-grid__button',
            withText: true
        });
        this.extendTemplate({
            attributes: {
                role: 'option'
            }
        });
        this.children.add(this.previewView, 0);
    }
    /**
	 * Creates the view representing the preview of the style.
	 */ _createPreview() {
        const previewView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"](this.locale);
        previewView.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-reset_all-excluded',
                    'ck-style-grid__button__preview',
                    'ck-content'
                ],
                // The preview "AaBbCcDdEeFfGgHhIiJj" should not be read by screen readers because it is purely presentational.
                'aria-hidden': 'true'
            },
            children: [
                this.styleDefinition.previewTemplate
            ]
        });
        return previewView;
    }
}
/**
 * A class representing a grid of styles ({@link module:style/ui/stylegridbuttonview~StyleGridButtonView buttons}).
 * Allows users to select a style.
 */ class StyleGridView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * Tracks information about the DOM focus in the view.
	 */ focusTracker;
    /**
	 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
	 */ keystrokes;
    /**
	 * A collection of style {@link module:style/ui/stylegridbuttonview~StyleGridButtonView buttons}.
	 */ children;
    /**
	 * Creates an instance of the {@link module:style/ui/stylegridview~StyleGridView} class.
	 *
	 * @param locale The localization services instance.
	 * @param styleDefinitions Definitions of the styles.
	 */ constructor(locale, styleDefinitions){
        super(locale);
        this.focusTracker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusTracker"]();
        this.keystrokes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeystrokeHandler"]();
        this.set('activeStyles', []);
        this.set('enabledStyles', []);
        this.children = this.createCollection();
        this.children.delegate('execute').to(this);
        for (const definition of styleDefinitions){
            const gridTileView = new StyleGridButtonView(locale, definition);
            this.children.add(gridTileView);
        }
        this.on('change:activeStyles', ()=>{
            for (const child of this.children){
                child.isOn = this.activeStyles.includes(child.styleDefinition.name);
            }
        });
        this.on('change:enabledStyles', ()=>{
            for (const child of this.children){
                child.isEnabled = this.enabledStyles.includes(child.styleDefinition.name);
            }
        });
        this.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-style-grid'
                ],
                role: 'listbox'
            },
            children: this.children
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        for (const child of this.children){
            this.focusTracker.add(child.element);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addKeyboardHandlingForGrid"])({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.children,
            numberOfColumns: 3,
            uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
        });
        // Start listening for the keystrokes coming from the grid view.
        this.keystrokes.listenTo(this.element);
    }
    /**
	 * Focuses the first style button in the grid.
	 */ focus() {
        this.children.first.focus();
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
    }
}
/**
 * A class representing a group of styles (e.g. "block" or "inline").
 *
 * Renders a {@link module:style/ui/stylegridview~StyleGridView style grid} and a label.
 */ class StyleGroupView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * The styles grid of the group.
	 */ gridView;
    /**
	 * The label of the group.
	 */ labelView;
    /**
	 * Creates an instance of the {@link module:style/ui/stylegroupview~StyleGroupView} class.
	 *
	 * @param locale The localization services instance.
	 * @param label The localized label of the group.
	 * @param styleDefinitions Definitions of the styles in the group.
	 */ constructor(locale, label, styleDefinitions){
        super(locale);
        this.labelView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LabelView"](locale);
        this.labelView.text = label;
        this.gridView = new StyleGridView(locale, styleDefinitions);
        this.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-style-panel__style-group'
                ],
                role: 'group',
                'aria-labelledby': this.labelView.id
            },
            children: [
                this.labelView,
                this.gridView
            ]
        });
    }
}
/**
 * A class representing a panel with available content styles. It renders styles in button grids, grouped
 * in categories.
 */ class StylePanelView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * Tracks information about DOM focus in the panel.
	 */ focusTracker;
    /**
	 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
	 */ keystrokes;
    /**
	 * A collection of panel children.
	 */ children;
    /**
	 * A view representing block styles group.
	 */ blockStylesGroupView;
    /**
	 * A view representing inline styles group
	 */ inlineStylesGroupView;
    /**
	 * A collection of views that can be focused in the panel.
	 */ _focusables;
    /**
	 * Helps cycling over {@link #_focusables} in the panel.
	 */ _focusCycler;
    /**
	 * Creates an instance of the {@link module:style/ui/stylegroupview~StyleGroupView} class.
	 *
	 * @param locale The localization services instance.
	 * @param styleDefinitions Normalized definitions of the styles.
	 */ constructor(locale, styleDefinitions){
        super(locale);
        const t = locale.t;
        this.focusTracker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusTracker"]();
        this.keystrokes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeystrokeHandler"]();
        this.children = this.createCollection();
        this.blockStylesGroupView = new StyleGroupView(locale, t('Block styles'), styleDefinitions.block);
        this.inlineStylesGroupView = new StyleGroupView(locale, t('Text styles'), styleDefinitions.inline);
        this.set('activeStyles', []);
        this.set('enabledStyles', []);
        this._focusables = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewCollection"]();
        this._focusCycler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusCycler"]({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
                // Navigate style groups backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
                focusPrevious: [
                    'shift + tab'
                ],
                // Navigate style groups forward using the <kbd>Tab</kbd> key.
                focusNext: [
                    'tab'
                ]
            }
        });
        if (styleDefinitions.block.length) {
            this.children.add(this.blockStylesGroupView);
        }
        if (styleDefinitions.inline.length) {
            this.children.add(this.inlineStylesGroupView);
        }
        this.blockStylesGroupView.gridView.delegate('execute').to(this);
        this.inlineStylesGroupView.gridView.delegate('execute').to(this);
        this.blockStylesGroupView.gridView.bind('activeStyles', 'enabledStyles').to(this, 'activeStyles', 'enabledStyles');
        this.inlineStylesGroupView.gridView.bind('activeStyles', 'enabledStyles').to(this, 'activeStyles', 'enabledStyles');
        this.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-style-panel'
                ]
            },
            children: this.children
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        // Register the views as focusable.
        this._focusables.add(this.blockStylesGroupView.gridView);
        this._focusables.add(this.inlineStylesGroupView.gridView);
        // Register the views in the focus tracker.
        this.focusTracker.add(this.blockStylesGroupView.gridView.element);
        this.focusTracker.add(this.inlineStylesGroupView.gridView.element);
        this.keystrokes.listenTo(this.element);
    }
    /**
	 * Focuses the first focusable element in the panel.
	 */ focus() {
        this._focusCycler.focusFirst();
    }
    /**
	 * Focuses the last focusable element in the panel.
	 */ focusLast() {
        this._focusCycler.focusLast();
    }
}
// These are intermediate element names that can't be rendered as style preview because they don't make sense standalone.
const NON_PREVIEWABLE_ELEMENT_NAMES = [
    'caption',
    'colgroup',
    'dd',
    'dt',
    'figcaption',
    'legend',
    'li',
    'optgroup',
    'option',
    'rp',
    'rt',
    'summary',
    'tbody',
    'td',
    'tfoot',
    'th',
    'thead',
    'tr'
];
class StyleUtils extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    _htmlSupport;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'StyleUtils';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        this.decorate('isStyleEnabledForBlock');
        this.decorate('isStyleActiveForBlock');
        this.decorate('getAffectedBlocks');
        this.decorate('isStyleEnabledForInlineSelection');
        this.decorate('isStyleActiveForInlineSelection');
        this.decorate('getAffectedInlineSelectable');
        this.decorate('getStylePreview');
        this.decorate('configureGHSDataFilter');
    }
    /**
	 * @inheritDoc
	 */ init() {
        this._htmlSupport = this.editor.plugins.get('GeneralHtmlSupport');
    }
    /**
	 * Normalizes {@link module:style/styleconfig~StyleConfig#definitions} in the configuration of the styles feature.
	 * The structure of normalized styles looks as follows:
	 *
	 * ```ts
	 * {
	 * 	block: [
	 * 		<module:style/style~StyleDefinition>,
	 * 		<module:style/style~StyleDefinition>,
	 * 		...
	 * 	],
	 * 	inline: [
	 * 		<module:style/style~StyleDefinition>,
	 * 		<module:style/style~StyleDefinition>,
	 * 		...
	 * 	]
	 * }
	 * ```
	 *
	 * @returns An object with normalized style definitions grouped into `block` and `inline` categories (arrays).
	 */ normalizeConfig(dataSchema, styleDefinitions = []) {
        const normalizedDefinitions = {
            block: [],
            inline: []
        };
        for (const definition of styleDefinitions){
            const modelElements = [];
            const ghsAttributes = [];
            for (const ghsDefinition of dataSchema.getDefinitionsForView(definition.element)){
                const appliesToBlock = 'appliesToBlock' in ghsDefinition ? ghsDefinition.appliesToBlock : false;
                if (ghsDefinition.isBlock || appliesToBlock) {
                    if (typeof appliesToBlock == 'string') {
                        modelElements.push(appliesToBlock);
                    } else if (ghsDefinition.isBlock) {
                        const ghsBlockDefinition = ghsDefinition;
                        modelElements.push(ghsDefinition.model);
                        if (ghsBlockDefinition.paragraphLikeModel) {
                            modelElements.push(ghsBlockDefinition.paragraphLikeModel);
                        }
                    }
                } else {
                    ghsAttributes.push(ghsDefinition.model);
                }
            }
            const previewTemplate = this.getStylePreview(definition, [
                {
                    text: 'AaBbCcDdEeFfGgHhIiJj'
                }
            ]);
            if (modelElements.length) {
                normalizedDefinitions.block.push({
                    ...definition,
                    previewTemplate,
                    modelElements,
                    isBlock: true
                });
            } else {
                normalizedDefinitions.inline.push({
                    ...definition,
                    previewTemplate,
                    ghsAttributes
                });
            }
        }
        return normalizedDefinitions;
    }
    /**
	 * Verifies if the given style is applicable to the provided block element.
	 *
	 * @internal
	 */ isStyleEnabledForBlock(definition, block) {
        const model = this.editor.model;
        const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
        if (!model.schema.checkAttribute(block, attributeName)) {
            return false;
        }
        return definition.modelElements.includes(block.name);
    }
    /**
	 * Returns true if the given style is applied to the specified block element.
	 *
	 * @internal
	 */ isStyleActiveForBlock(definition, block) {
        const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
        const ghsAttributeValue = block.getAttribute(attributeName);
        return this.hasAllClasses(ghsAttributeValue, definition.classes);
    }
    /**
	 * Returns an array of block elements that style should be applied to.
	 *
	 * @internal
	 */ getAffectedBlocks(definition, block) {
        if (definition.modelElements.includes(block.name)) {
            return [
                block
            ];
        }
        return null;
    }
    /**
	 * Verifies if the given style is applicable to the provided document selection.
	 *
	 * @internal
	 */ isStyleEnabledForInlineSelection(definition, selection) {
        const model = this.editor.model;
        for (const ghsAttributeName of definition.ghsAttributes){
            if (model.schema.checkAttributeInSelection(selection, ghsAttributeName)) {
                return true;
            }
        }
        return false;
    }
    /**
	 * Returns true if the given style is applied to the specified document selection.
	 *
	 * @internal
	 */ isStyleActiveForInlineSelection(definition, selection) {
        for (const ghsAttributeName of definition.ghsAttributes){
            const ghsAttributeValue = this._getValueFromFirstAllowedNode(selection, ghsAttributeName);
            if (this.hasAllClasses(ghsAttributeValue, definition.classes)) {
                return true;
            }
        }
        return false;
    }
    /**
	 * Returns a selectable that given style should be applied to.
	 *
	 * @internal
	 */ getAffectedInlineSelectable(definition, selection) {
        return selection;
    }
    /**
	 * Returns the `TemplateDefinition` used by styles dropdown to render style preview.
	 *
	 * @internal
	 */ getStylePreview(definition, children) {
        const { element, classes } = definition;
        return {
            tag: isPreviewable(element) ? element : 'div',
            attributes: {
                class: classes
            },
            children
        };
    }
    /**
	 * Verifies if all classes are present in the given GHS attribute.
	 *
	 * @internal
	 */ hasAllClasses(ghsAttributeValue, classes) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isObject$3e$__["isObject"])(ghsAttributeValue) && hasClassesProperty(ghsAttributeValue) && classes.every((className)=>ghsAttributeValue.classes.includes(className));
    }
    /**
	 * This is where the styles feature configures the GHS feature. This method translates normalized
	 * {@link module:style/styleconfig~StyleDefinition style definitions} to
	 * {@link module:engine/view/matcher~MatcherObjectPattern matcher patterns} and feeds them to the GHS
	 * {@link module:html-support/datafilter~DataFilter} plugin.
	 *
	 * @internal
	 */ configureGHSDataFilter({ block, inline }) {
        const ghsDataFilter = this.editor.plugins.get('DataFilter');
        ghsDataFilter.loadAllowedConfig(block.map(normalizedStyleDefinitionToMatcherPattern));
        ghsDataFilter.loadAllowedConfig(inline.map(normalizedStyleDefinitionToMatcherPattern));
    }
    /**
	 * Checks the attribute value of the first node in the selection that allows the attribute.
	 * For the collapsed selection, returns the selection attribute.
	 *
	 * @param selection The document selection.
	 * @param attributeName Name of the GHS attribute.
	 * @returns The attribute value.
	 */ _getValueFromFirstAllowedNode(selection, attributeName) {
        const model = this.editor.model;
        const schema = model.schema;
        if (selection.isCollapsed) {
            return selection.getAttribute(attributeName);
        }
        for (const range of selection.getRanges()){
            for (const item of range.getItems()){
                if (schema.checkAttribute(item, attributeName)) {
                    return item.getAttribute(attributeName);
                }
            }
        }
        return null;
    }
}
/**
 * Checks if given object has `classes` property which is an array.
 *
 * @param obj Object to check.
 */ function hasClassesProperty(obj) {
    return Boolean(obj.classes) && Array.isArray(obj.classes);
}
/**
 * Decides whether an element should be created in the preview or a substitute `<div>` should
 * be used instead. This avoids previewing a standalone `<td>`, `<li>`, etc. without a parent.
 *
 * @param elementName Name of the element
 * @returns Boolean indicating whether the element can be rendered.
 */ function isPreviewable(elementName) {
    return !NON_PREVIEWABLE_ELEMENT_NAMES.includes(elementName);
}
/**
 * Translates a normalized style definition to a view matcher pattern.
 */ function normalizedStyleDefinitionToMatcherPattern({ element, classes }) {
    return {
        name: element,
        classes
    };
}
/**
 * The UI plugin of the style feature .
 *
 * It registers the `'style'` UI dropdown in the editor's {@link module:ui/componentfactory~ComponentFactory component factory}
 * that displays a grid of styles and allows changing styles of the content.
 */ class StyleUI extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'StyleUI';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            StyleUtils
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const dataSchema = editor.plugins.get('DataSchema');
        const styleUtils = editor.plugins.get('StyleUtils');
        const styleDefinitions = editor.config.get('style.definitions');
        const normalizedStyleDefinitions = styleUtils.normalizeConfig(dataSchema, styleDefinitions);
        // Add the dropdown to the component factory.
        editor.ui.componentFactory.add('style', (locale)=>{
            const t = locale.t;
            const dropdown = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDropdown"])(locale);
            const styleCommand = editor.commands.get('style');
            dropdown.once('change:isOpen', ()=>{
                const panelView = new StylePanelView(locale, normalizedStyleDefinitions);
                // Put the styles panel is the dropdown.
                dropdown.panelView.children.add(panelView);
                // Close the dropdown when a style is selected in the styles panel.
                panelView.delegate('execute').to(dropdown);
                // Bind the state of the styles panel to the command.
                panelView.bind('activeStyles').to(styleCommand, 'value');
                panelView.bind('enabledStyles').to(styleCommand, 'enabledStyles');
            });
            // The entire dropdown will be disabled together with the command (e.g. when the editor goes read-only).
            dropdown.bind('isEnabled').to(styleCommand);
            // This dropdown has no icon. It displays text label depending on the selection.
            dropdown.buttonView.withText = true;
            // The label of the dropdown is dynamic and depends on how many styles are active at a time.
            dropdown.buttonView.bind('label').to(styleCommand, 'value', (value)=>{
                if (value.length > 1) {
                    return t('Multiple styles');
                } else if (value.length === 1) {
                    return value[0];
                } else {
                    return t('Styles');
                }
            });
            // The dropdown has a static CSS class for easy customization. There's another CSS class
            // that gets displayed when multiple styles are active at a time allowing visual customization of
            // the label.
            dropdown.bind('class').to(styleCommand, 'value', (value)=>{
                const classes = [
                    'ck-style-dropdown'
                ];
                if (value.length > 1) {
                    classes.push('ck-style-dropdown_multiple-active');
                }
                return classes.join(' ');
            });
            // Execute the command when a style is selected in the styles panel.
            // Also focus the editable after executing the command.
            // It overrides a default behaviour where the focus is moved to the dropdown button (#12125).
            dropdown.on('execute', (evt)=>{
                editor.execute('style', {
                    styleName: evt.source.styleDefinition.name
                });
                editor.editing.view.focus();
            });
            return dropdown;
        });
    }
}
/**
 * Style command.
 *
 * Applies and removes styles from selection and elements.
 */ class StyleCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * Normalized definitions of the styles.
	 */ _styleDefinitions;
    /**
	 * The StyleUtils plugin.
	 */ _styleUtils;
    /**
	 * Creates an instance of the command.
	 *
	 * @param editor Editor on which this command will be used.
	 * @param styleDefinitions Normalized definitions of the styles.
	 */ constructor(editor, styleDefinitions){
        super(editor);
        this.set('value', []);
        this.set('enabledStyles', []);
        this._styleDefinitions = styleDefinitions;
        this._styleUtils = this.editor.plugins.get(StyleUtils);
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const value = new Set();
        const enabledStyles = new Set();
        // Inline styles.
        for (const definition of this._styleDefinitions.inline){
            // Check if this inline style is enabled.
            if (this._styleUtils.isStyleEnabledForInlineSelection(definition, selection)) {
                enabledStyles.add(definition.name);
            }
            // Check if this inline style is active.
            if (this._styleUtils.isStyleActiveForInlineSelection(definition, selection)) {
                value.add(definition.name);
            }
        }
        // Block styles.
        const firstBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(selection.getSelectedBlocks()) || selection.getFirstPosition().parent;
        if (firstBlock) {
            const ancestorBlocks = firstBlock.getAncestors({
                includeSelf: true,
                parentFirst: true
            });
            for (const block of ancestorBlocks){
                if (block.is('rootElement')) {
                    break;
                }
                for (const definition of this._styleDefinitions.block){
                    // Check if this block style is enabled.
                    if (!this._styleUtils.isStyleEnabledForBlock(definition, block)) {
                        continue;
                    }
                    enabledStyles.add(definition.name);
                    // Check if this block style is active.
                    if (this._styleUtils.isStyleActiveForBlock(definition, block)) {
                        value.add(definition.name);
                    }
                }
                // E.g. reached a model table when the selection is in a cell. The command should not modify
                // ancestors of a table.
                if (model.schema.isObject(block)) {
                    break;
                }
            }
        }
        this.enabledStyles = Array.from(enabledStyles).sort();
        this.isEnabled = this.enabledStyles.length > 0;
        this.value = this.isEnabled ? Array.from(value).sort() : [];
    }
    /**
	 * Executes the command &ndash; applies the style classes to the selection or removes it from the selection.
	 *
	 * If the command value already contains the requested style, it will remove the style classes. Otherwise, it will set it.
	 *
	 * The execution result differs, depending on the {@link module:engine/model/document~Document#selection} and the
	 * style type (inline or block):
	 *
	 * * When applying inline styles:
	 *   * If the selection is on a range, the command applies the style classes to all nodes in that range.
	 *   * If the selection is collapsed in a non-empty node, the command applies the style classes to the
	 * {@link module:engine/model/document~Document#selection}.
	 *
	 * * When applying block styles:
	 *   * If the selection is on a range, the command applies the style classes to the nearest block parent element.
	 *
	 * @fires execute
	 * @param options Command options.
	 * @param options.styleName Style name matching the one defined in the
	 * {@link module:style/styleconfig~StyleConfig#definitions configuration}.
	 * @param options.forceValue Whether the command should add given style (`true`) or remove it (`false`) from the selection.
	 * If not set (default), the command will toggle the style basing on the first selected node. Note, that this will not force
	 * setting a style on an element that cannot receive given style.
	 */ execute({ styleName, forceValue }) {
        if (!this.enabledStyles.includes(styleName)) {
            /**
			 * Style command can be executed only with a correct style name.
			 *
			 * This warning may be caused by:
			 *
			 * * passing a name that is not specified in the {@link module:style/styleconfig~StyleConfig#definitions configuration}
			 * (e.g. a CSS class name),
			 * * when trying to apply a style that is not allowed on a given element.
			 *
			 * @error style-command-executed-with-incorrect-style-name
			 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('style-command-executed-with-incorrect-style-name');
            return;
        }
        const model = this.editor.model;
        const selection = model.document.selection;
        const htmlSupport = this.editor.plugins.get('GeneralHtmlSupport');
        const allDefinitions = [
            ...this._styleDefinitions.inline,
            ...this._styleDefinitions.block
        ];
        const activeDefinitions = allDefinitions.filter(({ name })=>this.value.includes(name));
        const definition = allDefinitions.find(({ name })=>name == styleName);
        const shouldAddStyle = forceValue === undefined ? !this.value.includes(definition.name) : forceValue;
        model.change(()=>{
            let selectables;
            if (isBlockStyleDefinition(definition)) {
                selectables = this._findAffectedBlocks(getBlocksFromSelection(selection), definition);
            } else {
                selectables = [
                    this._styleUtils.getAffectedInlineSelectable(definition, selection)
                ];
            }
            for (const selectable of selectables){
                if (shouldAddStyle) {
                    htmlSupport.addModelHtmlClass(definition.element, definition.classes, selectable);
                } else {
                    htmlSupport.removeModelHtmlClass(definition.element, getDefinitionExclusiveClasses(activeDefinitions, definition), selectable);
                }
            }
        });
    }
    /**
	 * Returns a set of elements that should be affected by the block-style change.
	 */ _findAffectedBlocks(selectedBlocks, definition) {
        const blocks = new Set();
        for (const selectedBlock of selectedBlocks){
            const ancestorBlocks = selectedBlock.getAncestors({
                includeSelf: true,
                parentFirst: true
            });
            for (const block of ancestorBlocks){
                if (block.is('rootElement')) {
                    break;
                }
                const affectedBlocks = this._styleUtils.getAffectedBlocks(definition, block);
                if (affectedBlocks) {
                    for (const affectedBlock of affectedBlocks){
                        blocks.add(affectedBlock);
                    }
                    break;
                }
            }
        }
        return blocks;
    }
}
/**
 * Returns classes that are defined only in the supplied definition and not in any other active definition. It's used
 * to ensure that classes used by other definitions are preserved when a style is removed. See #11748.
 *
 * @param activeDefinitions All currently active definitions affecting selected element(s).
 * @param definition Definition whose classes will be compared with all other active definition classes.
 * @returns Array of classes exclusive to the supplied definition.
 */ function getDefinitionExclusiveClasses(activeDefinitions, definition) {
    return activeDefinitions.reduce((classes, currentDefinition)=>{
        if (currentDefinition.name === definition.name) {
            return classes;
        }
        return classes.filter((className)=>!currentDefinition.classes.includes(className));
    }, definition.classes);
}
/**
 * Checks if provided style definition is of type block.
 */ function isBlockStyleDefinition(definition) {
    return 'isBlock' in definition;
}
/**
 * Gets block elements from selection. If there are none, returns first selected element.
 * @param selection Current document's selection.
 * @returns Selected blocks if there are any, first selected element otherwise.
 */ function getBlocksFromSelection(selection) {
    const blocks = Array.from(selection.getSelectedBlocks());
    if (blocks.length) {
        return blocks;
    }
    return [
        selection.getFirstPosition().parent
    ];
}
class ListStyleSupport extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    _listUtils;
    _styleUtils;
    _htmlSupport;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ListStyleSupport';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            StyleUtils,
            'GeneralHtmlSupport'
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        if (!editor.plugins.has('ListEditing')) {
            return;
        }
        this._styleUtils = editor.plugins.get(StyleUtils);
        this._listUtils = this.editor.plugins.get('ListUtils');
        this._htmlSupport = this.editor.plugins.get('GeneralHtmlSupport');
        this.listenTo(this._styleUtils, 'isStyleEnabledForBlock', (evt, [definition, block])=>{
            if (this._isStyleEnabledForBlock(definition, block)) {
                evt.return = true;
                evt.stop();
            }
        }, {
            priority: 'high'
        });
        this.listenTo(this._styleUtils, 'isStyleActiveForBlock', (evt, [definition, block])=>{
            if (this._isStyleActiveForBlock(definition, block)) {
                evt.return = true;
                evt.stop();
            }
        }, {
            priority: 'high'
        });
        this.listenTo(this._styleUtils, 'getAffectedBlocks', (evt, [definition, block])=>{
            const blocks = this._getAffectedBlocks(definition, block);
            if (blocks) {
                evt.return = blocks;
                evt.stop();
            }
        }, {
            priority: 'high'
        });
        this.listenTo(this._styleUtils, 'getStylePreview', (evt, [definition, children])=>{
            const templateDefinition = this._getStylePreview(definition, children);
            if (templateDefinition) {
                evt.return = templateDefinition;
                evt.stop();
            }
        }, {
            priority: 'high'
        });
    }
    /**
	 * Verifies if the given style is applicable to the provided block element.
	 */ _isStyleEnabledForBlock(definition, block) {
        const model = this.editor.model;
        if (![
            'ol',
            'ul',
            'li'
        ].includes(definition.element)) {
            return false;
        }
        if (!this._listUtils.isListItemBlock(block)) {
            return false;
        }
        const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
        if (definition.element == 'ol' || definition.element == 'ul') {
            if (!model.schema.checkAttribute(block, attributeName)) {
                return false;
            }
            const isNumbered = this._listUtils.isNumberedListType(block.getAttribute('listType'));
            const viewElementName = isNumbered ? 'ol' : 'ul';
            return definition.element == viewElementName;
        } else {
            return model.schema.checkAttribute(block, attributeName);
        }
    }
    /**
	 * Returns true if the given style is applied to the specified block element.
	 */ _isStyleActiveForBlock(definition, block) {
        const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
        const ghsAttributeValue = block.getAttribute(attributeName);
        return this._styleUtils.hasAllClasses(ghsAttributeValue, definition.classes);
    }
    /**
	 * Returns an array of block elements that style should be applied to.
	 */ _getAffectedBlocks(definition, block) {
        if (!this._isStyleEnabledForBlock(definition, block)) {
            return null;
        }
        if (definition.element == 'li') {
            return this._listUtils.expandListBlocksToCompleteItems(block, {
                withNested: false
            });
        } else {
            return this._listUtils.expandListBlocksToCompleteList(block);
        }
    }
    /**
	 * Returns a view template definition for the style preview.
	 */ _getStylePreview(definition, children) {
        const { element, classes } = definition;
        if (element == 'ol' || element == 'ul') {
            return {
                tag: element,
                attributes: {
                    class: classes
                },
                children: [
                    {
                        tag: 'li',
                        children
                    }
                ]
            };
        } else if (element == 'li') {
            return {
                tag: 'ol',
                children: [
                    {
                        tag: element,
                        attributes: {
                            class: classes
                        },
                        children
                    }
                ]
            };
        }
        return null;
    }
}
class TableStyleSupport extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    _tableUtils;
    _styleUtils;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'TableStyleSupport';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            StyleUtils
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        if (!editor.plugins.has('TableEditing')) {
            return;
        }
        this._styleUtils = editor.plugins.get(StyleUtils);
        this._tableUtils = this.editor.plugins.get('TableUtils');
        this.listenTo(this._styleUtils, 'isStyleEnabledForBlock', (evt, [definition, block])=>{
            if (this._isApplicable(definition, block)) {
                evt.return = this._isStyleEnabledForBlock(definition, block);
                evt.stop();
            }
        }, {
            priority: 'high'
        });
        this.listenTo(this._styleUtils, 'getAffectedBlocks', (evt, [definition, block])=>{
            if (this._isApplicable(definition, block)) {
                evt.return = this._getAffectedBlocks(definition, block);
                evt.stop();
            }
        }, {
            priority: 'high'
        });
        this.listenTo(this._styleUtils, 'configureGHSDataFilter', (evt, [{ block }])=>{
            const ghsDataFilter = this.editor.plugins.get('DataFilter');
            ghsDataFilter.loadAllowedConfig(block.filter((definition)=>definition.element == 'figcaption').map((definition)=>({
                    name: 'caption',
                    classes: definition.classes
                })));
        });
    }
    /**
	 * Checks if this plugin's custom logic should be applied for defintion-block pair.
	 *
	 * @param definition Style definition that is being considered.
	 * @param block Block element to check if should be styled.
	 * @returns True if the defintion-block pair meet the plugin criteria, false otherwise.
	 */ _isApplicable(definition, block) {
        if ([
            'td',
            'th'
        ].includes(definition.element)) {
            return block.name == 'tableCell';
        }
        if ([
            'thead',
            'tbody'
        ].includes(definition.element)) {
            return block.name == 'table';
        }
        return false;
    }
    /**
	 * Checks if the style definition should be applied to selected block.
	 *
	 * @param definition Style definition that is being considered.
	 * @param block Block element to check if should be styled.
	 * @returns True if the block should be style with the style description, false otherwise.
	 */ _isStyleEnabledForBlock(definition, block) {
        if ([
            'td',
            'th'
        ].includes(definition.element)) {
            const location = this._tableUtils.getCellLocation(block);
            const tableRow = block.parent;
            const table = tableRow.parent;
            const headingRows = table.getAttribute('headingRows') || 0;
            const headingColumns = table.getAttribute('headingColumns') || 0;
            const isHeadingCell = location.row < headingRows || location.column < headingColumns;
            if (definition.element == 'th') {
                return isHeadingCell;
            } else {
                return !isHeadingCell;
            }
        }
        if ([
            'thead',
            'tbody'
        ].includes(definition.element)) {
            const headingRows = block.getAttribute('headingRows') || 0;
            if (definition.element == 'thead') {
                return headingRows > 0;
            } else {
                return headingRows < this._tableUtils.getRows(block);
            }
        }
        /* istanbul ignore next -- @preserve */ return false;
    }
    /**
	 * Gets all blocks that the style should be applied to.
	 *
	 * @param definition Style definition that is being considered.
	 * @param block A block element from selection.
	 * @returns An array with the block that was passed as an argument if meets the criteria, null otherwise.
	 */ _getAffectedBlocks(definition, block) {
        if (!this._isStyleEnabledForBlock(definition, block)) {
            return null;
        }
        return [
            block
        ];
    }
}
class LinkStyleSupport extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    _styleUtils;
    _htmlSupport;
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'LinkStyleSupport';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            StyleUtils,
            'GeneralHtmlSupport'
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        if (!editor.plugins.has('LinkEditing')) {
            return;
        }
        this._styleUtils = editor.plugins.get(StyleUtils);
        this._htmlSupport = this.editor.plugins.get('GeneralHtmlSupport');
        this.listenTo(this._styleUtils, 'isStyleEnabledForInlineSelection', (evt, [definition, selection])=>{
            if (definition.element == 'a') {
                evt.return = this._isStyleEnabled(definition, selection);
                evt.stop();
            }
        }, {
            priority: 'high'
        });
        this.listenTo(this._styleUtils, 'isStyleActiveForInlineSelection', (evt, [definition, selection])=>{
            if (definition.element == 'a') {
                evt.return = this._isStyleActive(definition, selection);
                evt.stop();
            }
        }, {
            priority: 'high'
        });
        this.listenTo(this._styleUtils, 'getAffectedInlineSelectable', (evt, [definition, selection])=>{
            if (definition.element != 'a') {
                return;
            }
            const selectable = this._getAffectedSelectable(definition, selection);
            if (selectable) {
                evt.return = selectable;
                evt.stop();
            }
        }, {
            priority: 'high'
        });
    }
    /**
	 * Verifies if the given style is applicable to the provided document selection.
	 */ _isStyleEnabled(definition, selection) {
        const model = this.editor.model;
        // Handle collapsed selection.
        if (selection.isCollapsed) {
            return selection.hasAttribute('linkHref');
        }
        // Non-collapsed selection.
        for (const range of selection.getRanges()){
            for (const item of range.getItems()){
                if ((item.is('$textProxy') || model.schema.isInline(item)) && item.hasAttribute('linkHref')) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
	 * Returns true if the given style is applied to the specified document selection.
	 */ _isStyleActive(definition, selection) {
        const model = this.editor.model;
        const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
        // Handle collapsed selection.
        if (selection.isCollapsed) {
            if (selection.hasAttribute('linkHref')) {
                const ghsAttributeValue = selection.getAttribute(attributeName);
                if (this._styleUtils.hasAllClasses(ghsAttributeValue, definition.classes)) {
                    return true;
                }
            }
            return false;
        }
        // Non-collapsed selection.
        for (const range of selection.getRanges()){
            for (const item of range.getItems()){
                if ((item.is('$textProxy') || model.schema.isInline(item)) && item.hasAttribute('linkHref')) {
                    const ghsAttributeValue = item.getAttribute(attributeName);
                    return this._styleUtils.hasAllClasses(ghsAttributeValue, definition.classes);
                }
            }
        }
        return false;
    }
    /**
	 * Returns a selectable that given style should be applied to.
	 */ _getAffectedSelectable(definition, selection) {
        const model = this.editor.model;
        // Handle collapsed selection.
        if (selection.isCollapsed) {
            const linkHref = selection.getAttribute('linkHref');
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findAttributeRange"])(selection.getFirstPosition(), 'linkHref', linkHref, model);
        }
        // Non-collapsed selection.
        const ranges = [];
        for (const range of selection.getRanges()){
            // First expand range to include the whole link.
            const expandedRange = model.createRange(expandAttributePosition(range.start, 'linkHref', true, model), expandAttributePosition(range.end, 'linkHref', false, model));
            // Pick only ranges on links.
            for (const item of expandedRange.getItems()){
                if ((item.is('$textProxy') || model.schema.isInline(item)) && item.hasAttribute('linkHref')) {
                    ranges.push(this.editor.model.createRangeOn(item));
                }
            }
        }
        // Make sure that we have a continuous range on a link
        // (not split between text nodes with mixed attributes like bold etc.)
        return normalizeRanges(ranges);
    }
}
/**
 * Walks forward or backward (depends on the `lookBack` flag), node by node, as long as they have the same attribute value
 * and returns a position just before or after (depends on the `lookBack` flag) the last matched node.
 */ function expandAttributePosition(position, attributeName, lookBack, model) {
    const referenceNode = position.textNode || (lookBack ? position.nodeAfter : position.nodeBefore);
    if (!referenceNode || !referenceNode.hasAttribute(attributeName)) {
        return position;
    }
    const attributeValue = referenceNode.getAttribute(attributeName);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findAttributeRangeBound"])(position, attributeName, attributeValue, lookBack, model);
}
/**
 * Normalizes list of ranges by joining intersecting or "touching" ranges.
 *
 * Note: It assumes that ranges are sorted.
 */ function normalizeRanges(ranges) {
    for(let i = 1; i < ranges.length; i++){
        const joinedRange = ranges[i - 1].getJoined(ranges[i]);
        if (joinedRange) {
            // Replace the ranges on the list with the new joined range.
            ranges.splice(--i, 2, joinedRange);
        }
    }
    return ranges;
}
/**
 * The style engine feature.
 *
 * It configures the {@glink features/html/general-html-support General HTML Support feature} based on
 * {@link module:style/styleconfig~StyleConfig#definitions configured style definitions} and introduces the
 * {@link module:style/stylecommand~StyleCommand style command} that applies styles to the content of the document.
 */ class StyleEditing extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'StyleEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            'GeneralHtmlSupport',
            StyleUtils,
            ListStyleSupport,
            TableStyleSupport,
            LinkStyleSupport
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const dataSchema = editor.plugins.get('DataSchema');
        const styleUtils = editor.plugins.get('StyleUtils');
        const styleDefinitions = editor.config.get('style.definitions');
        const normalizedStyleDefinitions = styleUtils.normalizeConfig(dataSchema, styleDefinitions);
        editor.commands.add('style', new StyleCommand(editor, normalizedStyleDefinitions));
        styleUtils.configureGHSDataFilter(normalizedStyleDefinitions);
    }
}
/**
 * The style plugin.
 *
 * This is a "glue" plugin that loads the {@link module:style/styleediting~StyleEditing style editing feature}
 * and {@link module:style/styleui~StyleUI style UI feature}.
 */ class Style extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Style';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            StyleEditing,
            StyleUI
        ];
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-word-count/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "WordCount": (()=>WordCount)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/throttle.js [app-client] (ecmascript) <export default as throttle>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/isElement.js [app-client] (ecmascript) <export default as isElement>");
;
;
;
;
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module word-count/utils
 */ /**
 * Returns a plain text representation of an element and its children.
 *
 * @returns Plain text representing the model's data.
 */ function modelElementToPlainText(item) {
    if (item.is('$text') || item.is('$textProxy')) {
        return item.data;
    }
    const element = item;
    let text = '';
    let prev = null;
    for (const child of element.getChildren()){
        const childText = modelElementToPlainText(child);
        // If last block was finish, start from new line.
        if (prev && prev.is('element')) {
            text += '\n';
        }
        text += childText;
        prev = child;
    }
    return text;
}
/**
 * The word count plugin.
 *
 * This plugin calculates all words and characters in all {@link module:engine/model/text~Text text nodes} available in the model.
 * It also provides an HTML element that updates its state whenever the editor content is changed.
 *
 * The model's data is first converted to plain text using {@link module:word-count/utils~modelElementToPlainText}.
 * The number of words and characters in your text are determined based on the created plain text. Please keep in mind
 * that every block in the editor is separated with a newline character, which is included in the calculation.
 *
 * Here are some examples of how the word and character calculations are made:
 *
 * ```html
 * <paragraph>foo</paragraph>
 * <paragraph>bar</paragraph>
 * // Words: 2, Characters: 7
 *
 * <paragraph><$text bold="true">foo</$text>bar</paragraph>
 * // Words: 1, Characters: 6
 *
 * <paragraph>*&^%)</paragraph>
 * // Words: 0, Characters: 5
 *
 * <paragraph>foo(bar)</paragraph>
 * //Words: 1, Characters: 8
 *
 * <paragraph>12345</paragraph>
 * // Words: 1, Characters: 5
 * ```
 */ class WordCount extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * The configuration of this plugin.
	 */ _config;
    /**
	 * The reference to a {@link module:ui/view~View view object} that contains the self-updating HTML container.
	 */ _outputView;
    /**
	 * A regular expression used to recognize words in the editor's content.
	 */ _wordsMatchRegExp;
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        this.set('characters', 0);
        this.set('words', 0);
        // Don't wait for the #update event to set the value of the properties but obtain it right away.
        // This way, accessing the properties directly returns precise numbers, e.g. for validation, etc.
        // If not accessed directly, the properties will be refreshed upon #update anyway.
        Object.defineProperties(this, {
            characters: {
                get () {
                    return this.characters = this._getCharacters(this._getText());
                }
            },
            words: {
                get () {
                    return this.words = this._getWords(this._getText());
                }
            }
        });
        this.set('_wordsLabel', undefined);
        this.set('_charactersLabel', undefined);
        this._config = editor.config.get('wordCount') || {};
        this._outputView = undefined;
        this._wordsMatchRegExp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].features.isRegExpUnicodePropertySupported ? // Groups:
        // {L} - Any kind of letter from any language.
        // {N} - Any kind of numeric character in any script.
        new RegExp('([\\p{L}\\p{N}]+\\S?)+', 'gu') : /([a-zA-Z0-9À-ž]+\S?)+/gu;
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'WordCount';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        editor.model.document.on('change:data', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])(this._refreshStats.bind(this), 250));
        if (typeof this._config.onUpdate == 'function') {
            this.on('update', (evt, data)=>{
                this._config.onUpdate(data);
            });
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isElement$3e$__["isElement"])(this._config.container)) {
            this._config.container.appendChild(this.wordCountContainer);
        }
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        if (this._outputView) {
            this._outputView.element.remove();
            this._outputView.destroy();
        }
        super.destroy();
    }
    /**
	 * Creates a self-updating HTML element. Repeated executions return the same element.
	 * The returned element has the following HTML structure:
	 *
	 * ```html
	 * <div class="ck ck-word-count">
	 * 	<div class="ck-word-count__words">Words: 4</div>
	 * 	<div class="ck-word-count__characters">Characters: 28</div>
	 * </div>
	 * ```
	 */ get wordCountContainer() {
        const editor = this.editor;
        const t = editor.t;
        const displayWords = editor.config.get('wordCount.displayWords');
        const displayCharacters = editor.config.get('wordCount.displayCharacters');
        const bind = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Template"].bind(this, this);
        const children = [];
        if (!this._outputView) {
            this._outputView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"]();
            if (displayWords || displayWords === undefined) {
                this.bind('_wordsLabel').to(this, 'words', (words)=>{
                    return t('Words: %0', words);
                });
                children.push({
                    tag: 'div',
                    children: [
                        {
                            text: [
                                bind.to('_wordsLabel')
                            ]
                        }
                    ],
                    attributes: {
                        class: 'ck-word-count__words'
                    }
                });
            }
            if (displayCharacters || displayCharacters === undefined) {
                this.bind('_charactersLabel').to(this, 'characters', (words)=>{
                    return t('Characters: %0', words);
                });
                children.push({
                    tag: 'div',
                    children: [
                        {
                            text: [
                                bind.to('_charactersLabel')
                            ]
                        }
                    ],
                    attributes: {
                        class: 'ck-word-count__characters'
                    }
                });
            }
            this._outputView.setTemplate({
                tag: 'div',
                attributes: {
                    class: [
                        'ck',
                        'ck-word-count'
                    ]
                },
                children
            });
            this._outputView.render();
        }
        return this._outputView.element;
    }
    _getText() {
        let txt = '';
        for (const root of this.editor.model.document.getRoots()){
            if (txt !== '') {
                // Add a delimiter, so words from each root are treated independently.
                txt += '\n';
            }
            txt += modelElementToPlainText(root);
        }
        return txt;
    }
    /**
	 * Determines the number of characters in the current editor's model.
	 */ _getCharacters(txt) {
        return txt.replace(/\n/g, '').length;
    }
    /**
	 * Determines the number of words in the current editor's model.
	 */ _getWords(txt) {
        const detectedWords = txt.match(this._wordsMatchRegExp) || [];
        return detectedWords.length;
    }
    /**
	 * Determines the number of words and characters in the current editor's model and assigns it to {@link #characters} and {@link #words}.
	 * It also fires the {@link #event:update}.
	 *
	 * @fires update
	 */ _refreshStats() {
        const txt = this._getText();
        const words = this.words = this._getWords(txt);
        const characters = this.characters = this._getCharacters(txt);
        this.fire('update', {
            words,
            characters
        });
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-emoji/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "Emoji": (()=>Emoji),
    "EmojiCommand": (()=>EmojiCommand),
    "EmojiMention": (()=>EmojiMention),
    "EmojiPicker": (()=>EmojiPicker),
    "EmojiRepository": (()=>EmojiRepository),
    "EmojiUtils": (()=>EmojiUtils)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-utils/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-typing/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fuzzysort$2f$fuzzysort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/fuzzysort/fuzzysort.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-ui/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$groupBy$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__groupBy$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/groupBy.js [app-client] (ecmascript) <export default as groupBy>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$escapeRegExp$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__escapeRegExp$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/escapeRegExp.js [app-client] (ecmascript) <export default as escapeRegExp>");
;
;
;
;
;
;
/**
 * @license Copyright (c) 2023, Koala Interactive SAS
 * For licensing, see https://github.com/koala-interactive/is-emoji-supported/blob/master/LICENSE.md
 */ /**
 * @module emoji/utils/isemojisupported
 */ /**
 * Checks if the two pixels parts are the same using canvas.
 */ function isEmojiSupported(unicode) {
    const ctx = getCanvas();
    /* istanbul ignore next -- @preserve */ if (!ctx) {
        return false;
    }
    const CANVAS_HEIGHT = 25;
    const CANVAS_WIDTH = 20;
    const textSize = Math.floor(CANVAS_HEIGHT / 2);
    // Initialize canvas context.
    ctx.font = textSize + 'px Arial, Sans-Serif';
    ctx.textBaseline = 'top';
    ctx.canvas.width = CANVAS_WIDTH * 2;
    ctx.canvas.height = CANVAS_HEIGHT;
    ctx.clearRect(0, 0, CANVAS_WIDTH * 2, CANVAS_HEIGHT);
    // Draw in red on the left.
    ctx.fillStyle = '#FF0000';
    ctx.fillText(unicode, 0, 22);
    // Draw in blue on right.
    ctx.fillStyle = '#0000FF';
    ctx.fillText(unicode, CANVAS_WIDTH, 22);
    const a = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT).data;
    const count = a.length;
    let i = 0;
    // Search the first visible pixel.
    for(; i < count && !a[i + 3]; i += 4);
    // No visible pixel.
    /* istanbul ignore next -- @preserve */ if (i >= count) {
        return false;
    }
    // Emoji has immutable color, so we check the color of the emoji in two different colors.
    // the result show be the same.
    const x = CANVAS_WIDTH + i / 4 % CANVAS_WIDTH;
    const y = Math.floor(i / 4 / CANVAS_WIDTH);
    const b = ctx.getImageData(x, y, 1, 1).data;
    /* istanbul ignore next -- @preserve */ if (a[i] !== b[0] || a[i + 2] !== b[2]) {
        return false;
    }
    //Some emojis consist of different ones, so they will show multiple characters if they are not supported.
    /* istanbul ignore next -- @preserve */ if (ctx.measureText(unicode).width >= CANVAS_WIDTH) {
        return false;
    }
    // Supported.
    return true;
}
function getCanvas() {
    try {
        return document.createElement('canvas').getContext('2d', {
            willReadFrequently: true
        });
    } catch  {
        /* istanbul ignore next -- @preserve */ return null;
    }
}
/**
 * @module emoji/emojiutils
 */ const SKIN_TONE_MAP = {
    0: 'default',
    1: 'light',
    2: 'medium-light',
    3: 'medium',
    4: 'medium-dark',
    5: 'dark'
};
/**
 * A map representing an emoji and its release version.
 * It's used to identify a user's minimal supported emoji level.
 * We skip versions with older patches, such as 15.0 instead of 15.1 etc.
 */ const EMOJI_SUPPORT_LEVEL = {
    '🫩': 16,
    '🫨': 15.1,
    '🫠': 14,
    '😶‍🌫️': 13.1,
    '🧑‍💻': 12.1,
    '🥰': 11,
    '🤪': 5,
    '⚕️': 4,
    '🤣': 3,
    '👋🏽': 2,
    '😀': 1,
    '😐': 0.7,
    '😂': 0.6 // Face with Tears of Joy.
};
const BASELINE_EMOJI_WIDTH = 24;
/**
 * The Emoji utilities plugin.
 */ class EmojiUtils extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'EmojiUtils';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * Checks if the emoji is supported by verifying the emoji version supported by the system first.
	 * Then checks if emoji contains a zero width joiner (ZWJ), and if yes, then checks if it is supported by the system.
	 */ isEmojiSupported(item, emojiSupportedVersionByOs, container) {
        const isEmojiVersionSupported = item.version <= emojiSupportedVersionByOs;
        if (!isEmojiVersionSupported) {
            return false;
        }
        if (!this.hasZwj(item.emoji)) {
            return true;
        }
        return this.isEmojiZwjSupported(item, container);
    }
    /**
	 * Checks the supported emoji version by the OS, by sampling some representatives from different emoji releases.
	 */ getEmojiSupportedVersionByOs() {
        for (const [emoji, emojiVersion] of Object.entries(EMOJI_SUPPORT_LEVEL)){
            if (EmojiUtils._isEmojiSupported(emoji)) {
                return emojiVersion;
            }
        }
        return 0;
    }
    /**
	 * Check for ZWJ (zero width joiner) character.
	 */ hasZwj(emoji) {
        return emoji.includes('\u200d');
    }
    /**
	 * Checks whether the emoji is supported in the operating system.
	 */ isEmojiZwjSupported(item, container) {
        const emojiWidth = this.getNodeWidth(container, item.emoji);
        // On Windows, some supported emoji are ~50% bigger than the baseline emoji, but what we really want to guard
        // against are the ones that are 2x the size, because those are truly broken (person with red hair = person with
        // floating red wig, black cat = cat with black square, polar bear = bear with snowflake, etc.)
        // So here we set the threshold at 1.8 times the size of the baseline emoji.
        return emojiWidth < BASELINE_EMOJI_WIDTH * 1.8;
    }
    /**
	 * Returns the width of the provided node.
	 */ getNodeWidth(container, node) {
        const span = document.createElement('span');
        span.textContent = node;
        container.appendChild(span);
        const nodeWidth = span.offsetWidth;
        container.removeChild(span);
        return nodeWidth;
    }
    /**
	 * Creates a div for emoji width testing purposes.
	 */ createEmojiWidthTestingContainer() {
        const container = document.createElement('div');
        container.setAttribute('aria-hidden', 'true');
        container.style.position = 'absolute';
        container.style.left = '-9999px';
        container.style.whiteSpace = 'nowrap';
        container.style.fontSize = BASELINE_EMOJI_WIDTH + 'px';
        return container;
    }
    /**
	 * Adds default skin tone property to each emoji. If emoji defines other skin tones, they are added as well.
	 */ normalizeEmojiSkinTone(item) {
        const entry = {
            ...item,
            skins: {
                default: item.emoji
            }
        };
        if (item.skins) {
            item.skins.forEach((skin)=>{
                const skinTone = SKIN_TONE_MAP[skin.tone];
                entry.skins[skinTone] = skin.emoji;
            });
        }
        return entry;
    }
    /**
	 * Checks whether the emoji belongs to a group that is allowed.
	 */ isEmojiCategoryAllowed(item) {
        // Category group=2 contains skin tones only, which we do not want to render.
        return item.group !== 2;
    }
    /**
	 * A function used to determine if emoji is supported by detecting pixels.
	 *
	 * Referenced for unit testing purposes. Kept in a separate file because of licensing.
	 */ static _isEmojiSupported = isEmojiSupported;
}
// An endpoint from which the emoji data will be downloaded during plugin initialization.
// The `{version}` placeholder is replaced with the value from editor config.
const DEFAULT_EMOJI_DATABASE_URL = 'https://cdn.ckeditor.com/ckeditor5/data/emoji/{version}/en.json';
const DEFAULT_EMOJI_VERSION = 16;
/**
 * The emoji repository plugin.
 *
 * Loads the emoji repository from URL during plugin initialization and provides utility methods to search it.
 */ class EmojiRepository extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * Emoji repository in a configured version.
	 */ _items;
    /**
	 * The resolved URL from which the emoji repository is downloaded.
	 */ _url;
    /**
	 * A promise resolved after downloading the emoji collection.
	 * The promise resolves with `true` when the repository is successfully downloaded or `false` otherwise.
	 */ _repositoryPromise;
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            EmojiUtils
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'EmojiRepository';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('emoji', {
            version: undefined,
            skinTone: 'default',
            definitionsUrl: undefined,
            useCustomFont: false
        });
        this._url = this._getUrl();
        this._repositoryPromise = new Promise((resolve)=>{
            this._repositoryPromiseResolveCallback = resolve;
        });
        this._items = null;
    }
    /**
	 * @inheritDoc
	 */ async init() {
        this._warnAboutCdnUse();
        await this._loadAndCacheEmoji();
        this._items = this._getItems();
        if (!this._items) {
            /**
			 * Unable to identify the available emoji to display.
			 *
			 * See the {@glink features/emoji#troubleshooting troubleshooting} section in the {@glink features/emoji Emoji feature} guide
			 * for more details.
			 *
			 * @error emoji-repository-empty
			 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('emoji-repository-empty');
            return this._repositoryPromiseResolveCallback(false);
        }
        return this._repositoryPromiseResolveCallback(true);
    }
    /**
	 * Returns an array of emoji entries that match the search query.
	 * If the emoji repository is not loaded this method returns an empty array.
	 *
	 * @param searchQuery A search query to match emoji.
	 * @returns An array of emoji entries that match the search query.
	 */ getEmojiByQuery(searchQuery) {
        if (!this._items) {
            return [];
        }
        const searchQueryTokens = searchQuery.split(/\s/).filter(Boolean);
        // Perform the search only if there is at least two non-white characters next to each other.
        const shouldSearch = searchQueryTokens.some((token)=>token.length >= 2);
        if (!shouldSearch) {
            return [];
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fuzzysort$2f$fuzzysort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].go(searchQuery, this._items, {
            threshold: 0.6,
            keys: [
                'emoticon',
                'annotation',
                (emojiEntry)=>{
                    // Instead of searching over all tags, let's use only those that matches the query.
                    // It enables searching in tags with the space character in names.
                    const searchQueryTokens = searchQuery.split(/\s/).filter(Boolean);
                    const matchedTags = searchQueryTokens.flatMap((tok)=>{
                        return emojiEntry.tags?.filter((t)=>t.startsWith(tok));
                    });
                    return matchedTags.join();
                }
            ]
        }).map((result)=>result.obj);
    }
    /**
	 * Groups all emojis by categories.
	 * If the emoji repository is not loaded, it returns an empty array.
	 *
	 * @returns An array of emoji entries grouped by categories.
	 */ getEmojiCategories() {
        const repository = this._getItems();
        if (!repository) {
            return [];
        }
        const { t } = this.editor.locale;
        const categories = [
            {
                title: t('Smileys & Expressions'),
                icon: '😄',
                groupId: 0
            },
            {
                title: t('Gestures & People'),
                icon: '👋',
                groupId: 1
            },
            {
                title: t('Animals & Nature'),
                icon: '🐻',
                groupId: 3
            },
            {
                title: t('Food & Drinks'),
                icon: '🍎',
                groupId: 4
            },
            {
                title: t('Travel & Places'),
                icon: '🚘',
                groupId: 5
            },
            {
                title: t('Activities'),
                icon: '🏀',
                groupId: 6
            },
            {
                title: t('Objects'),
                icon: '💡',
                groupId: 7
            },
            {
                title: t('Symbols'),
                icon: '🔵',
                groupId: 8
            },
            {
                title: t('Flags'),
                icon: '🏁',
                groupId: 9
            }
        ];
        const groups = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$groupBy$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__groupBy$3e$__["groupBy"])(repository, 'group');
        return categories.map((category)=>{
            return {
                ...category,
                items: groups[category.groupId]
            };
        });
    }
    /**
	 * Returns an array of available skin tones.
	 */ getSkinTones() {
        const { t } = this.editor.locale;
        return [
            {
                id: 'default',
                icon: '👋',
                tooltip: t('Default skin tone')
            },
            {
                id: 'light',
                icon: '👋🏻',
                tooltip: t('Light skin tone')
            },
            {
                id: 'medium-light',
                icon: '👋🏼',
                tooltip: t('Medium Light skin tone')
            },
            {
                id: 'medium',
                icon: '👋🏽',
                tooltip: t('Medium skin tone')
            },
            {
                id: 'medium-dark',
                icon: '👋🏾',
                tooltip: t('Medium Dark skin tone')
            },
            {
                id: 'dark',
                icon: '👋🏿',
                tooltip: t('Dark skin tone')
            }
        ];
    }
    /**
	 * Indicates whether the emoji repository has been successfully downloaded and the plugin is operational.
	 */ isReady() {
        return this._repositoryPromise;
    }
    /**
	 * Returns the URL from which the emoji repository is downloaded. If the URL is not provided
	 * in the configuration, the default URL is used with the version from the configuration.
	 *
	 * If both the URL and version are provided, a warning is logged.
	 */ _getUrl() {
        const { definitionsUrl, version: version$1 } = this.editor.config.get('emoji');
        if (!definitionsUrl || definitionsUrl === 'cdn') {
            // URL was not provided or is set to 'cdn', so we use the default CDN URL.
            const urlVersion = version$1 || DEFAULT_EMOJI_VERSION;
            const url = new URL(DEFAULT_EMOJI_DATABASE_URL.replace('{version}', urlVersion.toString()));
            url.searchParams.set('editorVersion', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"]);
            return url;
        }
        if (version$1) {
            /**
			 * Both {@link module:emoji/emojiconfig~EmojiConfig#definitionsUrl `emoji.definitionsUrl`} and
			 * {@link module:emoji/emojiconfig~EmojiConfig#version `emoji.version`} configuration options
			 * are set. Only the `emoji.definitionsUrl` option will be used.
			 *
			 * The `emoji.version` option will be ignored and should be removed from the configuration.
			 *
			 * @error emoji-repository-redundant-version
			 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('emoji-repository-redundant-version');
        }
        return new URL(definitionsUrl);
    }
    /**
	 * Warn users on self-hosted installations that this plugin uses a CDN to fetch the emoji repository.
	 */ _warnAboutCdnUse() {
        const editor = this.editor;
        const config = editor.config.get('emoji');
        const licenseKey = editor.config.get('licenseKey');
        const distributionChannel = window[Symbol.for('cke distribution')];
        if (licenseKey === 'GPL') {
            // Don't warn GPL users.
            return;
        }
        if (distributionChannel === 'cloud') {
            // Don't warn cloud users, because they already use our CDN.
            return;
        }
        if (config && config.definitionsUrl) {
            // Don't warn users who have configured their own definitions URL.
            return;
        }
        /**
		 * It was detected that your installation uses a commercial license key,
		 * and the default {@glink features/emoji#emoji-source CKEditor CDN for Emoji plugin data}.
		 *
		 * To avoid this, you can use the {@link module:emoji/emojiconfig~EmojiConfig#definitionsUrl `emoji.definitionsUrl`}
		 * configuration option to provide a URL to your own emoji repository.
		 *
		 * If you want to suppress this warning, while using the default CDN, set this configuration option to `cdn`.
		 *
		 * @error emoji-repository-cdn-use
		 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('emoji-repository-cdn-use');
    }
    /**
	 * Returns the emoji repository in a configured version if it is a non-empty array. Returns `null` otherwise.
	 */ _getItems() {
        const repository = EmojiRepository._results[this._url.href];
        return repository && repository.length ? repository : null;
    }
    /**
	 * Loads the emoji repository. If the repository is already loaded, it returns the cached result.
	 * Otherwise, it fetches the repository from the URL and adds it to the cache.
	 */ async _loadAndCacheEmoji() {
        if (EmojiRepository._results[this._url.href]) {
            // The repository has already been downloaded.
            return;
        }
        const result = await fetch(this._url, {
            cache: 'force-cache'
        }).then((response)=>{
            if (!response.ok) {
                return [];
            }
            return response.json();
        }).catch(()=>{
            return [];
        });
        EmojiRepository._results[this._url.href] = this._normalizeEmoji(result);
    }
    /**
	 * Normalizes the raw data fetched from CDN. By normalization, we meant:
	 *
	 *  * Filter out unsupported emoji (these that will not render correctly),
	 *  * Prepare skin tone variants if an emoji defines them.
	 */ _normalizeEmoji(data) {
        const editor = this.editor;
        const useCustomFont = editor.config.get('emoji.useCustomFont');
        const emojiUtils = editor.plugins.get('EmojiUtils');
        const insertableEmoji = data.filter((item)=>emojiUtils.isEmojiCategoryAllowed(item));
        // When using a custom font, the feature does not filter any emoji.
        if (useCustomFont) {
            return insertableEmoji.map((item)=>emojiUtils.normalizeEmojiSkinTone(item));
        }
        const emojiSupportedVersionByOs = emojiUtils.getEmojiSupportedVersionByOs();
        const container = emojiUtils.createEmojiWidthTestingContainer();
        document.body.appendChild(container);
        const results = insertableEmoji.filter((item)=>emojiUtils.isEmojiSupported(item, emojiSupportedVersionByOs, container)).map((item)=>emojiUtils.normalizeEmojiSkinTone(item));
        container.remove();
        return results;
    }
    /**
	 * Versioned emoji repository.
	 */ static _results = {};
}
/**
 * Unable to load the emoji repository from the URL.
 *
 * If the URL works properly and there is no disruption of communication, please check your
 * {@glink getting-started/setup/csp Content Security Policy (CSP)} setting and make sure
 * the URL connection is allowed by the editor.
 *
 * @error emoji-repository-load-failed
 */ const EMOJI_MENTION_MARKER = ':';
const EMOJI_SHOW_ALL_OPTION_ID = ':__EMOJI_SHOW_ALL:';
const EMOJI_HINT_OPTION_ID = ':__EMOJI_HINT:';
/**
 * The emoji mention plugin.
 *
 * Introduces the autocomplete of emojis while typing.
 */ class EmojiMention extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * Defines a number of displayed items in the auto complete dropdown.
	 *
	 * It includes the "Show all emoji..." option if the `EmojiPicker` plugin is loaded.
	 */ _emojiDropdownLimit;
    /**
	 * Defines a skin tone that is set in the emoji config.
	 */ _skinTone;
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            EmojiRepository,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Typing"],
            'Mention'
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'EmojiMention';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        this.editor.config.define('emoji', {
            dropdownLimit: 6
        });
        this._emojiDropdownLimit = editor.config.get('emoji.dropdownLimit');
        this._skinTone = editor.config.get('emoji.skinTone');
        this._setupMentionConfiguration(editor);
    }
    /**
	 * Initializes the configuration for emojis in the mention feature.
	 * If the marker used by emoji mention is already registered, it displays a warning.
	 * If emoji mention configuration is detected, it does not register it for a second time.
	 */ _setupMentionConfiguration(editor) {
        const mergeFieldsPrefix = editor.config.get('mergeFields.prefix');
        const mentionFeedsConfigs = editor.config.get('mention.feeds');
        const isEmojiMarkerUsedByMergeFields = mergeFieldsPrefix ? mergeFieldsPrefix[0] === EMOJI_MENTION_MARKER : false;
        const isEmojiMarkerUsedByMention = mentionFeedsConfigs.filter((config)=>!config._isEmojiMarker).some((config)=>config.marker === EMOJI_MENTION_MARKER);
        if (isEmojiMarkerUsedByMention || isEmojiMarkerUsedByMergeFields) {
            /**
			 * The `marker` in the `emoji` config is already used by other plugin configuration.
			 *
			 * @error emoji-config-marker-already-used
			 * @param {string} marker Used marker.
			 */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logWarning"])('emoji-config-marker-already-used', {
                marker: EMOJI_MENTION_MARKER
            });
            return;
        }
        const isEmojiConfigDefined = mentionFeedsConfigs.some((config)=>config._isEmojiMarker);
        if (isEmojiConfigDefined) {
            return;
        }
        const emojiMentionFeedConfig = {
            _isEmojiMarker: true,
            marker: EMOJI_MENTION_MARKER,
            dropdownLimit: this._emojiDropdownLimit,
            itemRenderer: this._customItemRendererFactory(this.editor.t),
            feed: this._queryEmojiCallbackFactory()
        };
        this.editor.config.set('mention.feeds', [
            ...mentionFeedsConfigs,
            emojiMentionFeedConfig
        ]);
    }
    /**
	 * @inheritDoc
	 */ async init() {
        const editor = this.editor;
        this.emojiPickerPlugin = editor.plugins.has('EmojiPicker') ? editor.plugins.get('EmojiPicker') : null;
        this.emojiRepositoryPlugin = editor.plugins.get('EmojiRepository');
        this._isEmojiRepositoryAvailable = await this.emojiRepositoryPlugin.isReady();
        // Override the `mention` command listener if the emoji repository is ready.
        if (this._isEmojiRepositoryAvailable) {
            editor.once('ready', this._overrideMentionExecuteListener.bind(this));
        }
    }
    /**
	 * Returns the `itemRenderer()` callback for mention config.
	 */ _customItemRendererFactory(t) {
        return (item)=>{
            const itemElement = document.createElement('button');
            itemElement.classList.add('ck');
            itemElement.classList.add('ck-button');
            itemElement.classList.add('ck-button_with-text');
            itemElement.id = `mention-list-item-id${item.id.slice(0, -1)}`;
            itemElement.type = 'button';
            itemElement.tabIndex = -1;
            const labelElement = document.createElement('span');
            labelElement.classList.add('ck');
            labelElement.classList.add('ck-button__label');
            itemElement.appendChild(labelElement);
            if (item.id === EMOJI_HINT_OPTION_ID) {
                itemElement.classList.add('ck-list-item-button');
                itemElement.classList.add('ck-disabled');
                labelElement.textContent = t('Keep on typing to see the emoji.');
            } else if (item.id === EMOJI_SHOW_ALL_OPTION_ID) {
                labelElement.textContent = t('Show all emoji...');
            } else {
                labelElement.textContent = `${item.text} ${item.id}`;
            }
            return itemElement;
        };
    }
    /**
	 * Overrides the default mention execute listener to insert an emoji as plain text instead.
	 */ _overrideMentionExecuteListener() {
        const editor = this.editor;
        editor.commands.get('mention').on('execute', (event, data)=>{
            const eventData = data[0];
            // Ignore non-emoji auto-complete actions.
            if (eventData.marker !== EMOJI_MENTION_MARKER) {
                return;
            }
            // Do not propagate the event.
            event.stop();
            // Do nothing when executing after selecting a hint message.
            if (eventData.mention.id === EMOJI_HINT_OPTION_ID) {
                return;
            }
            // Trigger the picker UI.
            if (eventData.mention.id === EMOJI_SHOW_ALL_OPTION_ID) {
                const text = [
                    ...eventData.range.getItems()
                ].filter((item)=>item.is('$textProxy')).map((item)=>item.data).reduce((result, text)=>result + text, '');
                editor.model.change((writer)=>{
                    editor.model.deleteContent(writer.createSelection(eventData.range));
                });
                const emojiPickerPlugin = this.emojiPickerPlugin;
                emojiPickerPlugin.showUI(text.slice(1));
                setTimeout(()=>{
                    emojiPickerPlugin.emojiPickerView.focus();
                });
            } else {
                editor.execute('insertText', {
                    text: eventData.mention.text,
                    range: eventData.range
                });
            }
        }, {
            priority: 'high'
        });
    }
    /**
	 * Returns the `feed()` callback for mention config.
	 */ _queryEmojiCallbackFactory() {
        return (searchQuery)=>{
            // Do not show anything when a query starts with a space.
            if (searchQuery.startsWith(' ')) {
                return [];
            }
            // Do not show anything when a query starts with a marker character.
            if (searchQuery.startsWith(EMOJI_MENTION_MARKER)) {
                return [];
            }
            // If the repository plugin is not available, return an empty feed to avoid confusion. See: #17842.
            if (!this._isEmojiRepositoryAvailable) {
                return [];
            }
            const emojis = this.emojiRepositoryPlugin.getEmojiByQuery(searchQuery).map((emoji)=>{
                let text = emoji.skins[this._skinTone] || emoji.skins.default;
                if (this.emojiPickerPlugin) {
                    text = emoji.skins[this.emojiPickerPlugin.skinTone] || emoji.skins.default;
                }
                return {
                    id: `:${emoji.annotation}:`,
                    text
                };
            });
            if (!this.emojiPickerPlugin) {
                return emojis.slice(0, this._emojiDropdownLimit);
            }
            const actionItem = {
                id: searchQuery.length > 1 ? EMOJI_SHOW_ALL_OPTION_ID : EMOJI_HINT_OPTION_ID
            };
            return [
                ...emojis.slice(0, this._emojiDropdownLimit - 1),
                actionItem
            ];
        };
    }
}
/**
 * Command that shows the emoji user interface.
 */ class EmojiCommand extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Command"] {
    /**
	 * Updates the command's {@link #isEnabled} based on the current selection.
	 */ refresh() {
        const editor = this.editor;
        const model = editor.model;
        const schema = model.schema;
        const selection = model.document.selection;
        this.isEnabled = schema.checkChild(selection.getFirstPosition(), '$text');
    }
    /**
	 * Opens emoji user interface for the current document selection.
	 *
	 * @fires execute
	 * @param [searchValue=''] A default query used to filer the grid when opening the UI.
	 */ execute(searchValue = '') {
        const emojiPickerPlugin = this.editor.plugins.get('EmojiPicker');
        emojiPickerPlugin.showUI(searchValue);
    }
}
/**
 * A grid of emoji tiles. It allows browsing emojis and selecting them to be inserted into the content.
 */ class EmojiGridView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * A collection of the child tile views. Each tile represents a particular emoji.
	 */ tiles;
    /**
	 * Tracks information about the DOM focus in the grid.
	 */ focusTracker;
    /**
	 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
	 */ keystrokes;
    /**
	 * An array containing all emojis grouped by their categories.
	 */ emojiCategories;
    /**
	 * A collection of all already created tile views. Each tile represents a particular emoji.
	 * The cached tiles collection is used for efficiency purposes to avoid re-creating a particular
	 * tile again when the grid view has changed.
	 */ cachedTiles;
    /**
	 * A callback used to filter grid items by a specified query.
	 */ _getEmojiByQuery;
    /**
	 * @inheritDoc
	 */ constructor(locale, { categoryName, emojiCategories, getEmojiByQuery, skinTone }){
        super(locale);
        this.set('isEmpty', true);
        this.set('categoryName', categoryName);
        this.set('skinTone', skinTone);
        this.tiles = this.createCollection();
        this.cachedTiles = this.createCollection();
        this.focusTracker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusTracker"]();
        this.keystrokes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeystrokeHandler"]();
        this._getEmojiByQuery = getEmojiByQuery;
        this.emojiCategories = emojiCategories;
        const bind = this.bindTemplate;
        this.setTemplate({
            tag: 'div',
            children: [
                {
                    tag: 'div',
                    attributes: {
                        role: 'grid',
                        class: [
                            'ck',
                            'ck-emoji__grid'
                        ]
                    },
                    children: this.tiles
                }
            ],
            attributes: {
                role: 'tabpanel',
                class: [
                    'ck',
                    'ck-emoji__tiles',
                    // To avoid issues with focus cycling, ignore a grid when it's empty.
                    bind.if('isEmpty', 'ck-hidden', (value)=>value)
                ]
            }
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addKeyboardHandlingForGrid"])({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.tiles,
            numberOfColumns: ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].window.getComputedStyle(this.element.firstChild) // Responsive `.ck-emoji-grid__tiles`.
                .getPropertyValue('grid-template-columns').split(' ').length,
            uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
        });
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        this.keystrokes.listenTo(this.element);
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this.keystrokes.destroy();
        this.focusTracker.destroy();
    }
    /**
	 * Focuses the first focusable in {@link ~EmojiGridView#tiles} if available.
	 */ focus() {
        const firstTile = this.tiles.first;
        if (firstTile) {
            firstTile.focus();
        }
    }
    /**
	 * Filters the grid view by the given regular expression.
	 *
	 * It filters either by the pattern or an emoji category, but never both.
	 *
	 * @param pattern Expression to search or `null` when filter by category name.
	 */ filter(pattern) {
        const { matchingItems, allItems } = pattern ? this._getItemsByQuery(pattern.source) : this._getItemsByCategory();
        this._updateGrid(matchingItems);
        this.set('isEmpty', matchingItems.length === 0);
        return {
            resultsCount: matchingItems.length,
            totalItemsCount: allItems.length
        };
    }
    /**
	 * Filters emojis to show based on the specified query phrase.
	 *
	 * @param query A query used to filter the grid.
	 */ _getItemsByQuery(query) {
        return {
            matchingItems: this._getEmojiByQuery(query),
            allItems: this.emojiCategories.flatMap((group)=>group.items)
        };
    }
    /**
	 * Returns emojis that belong to the specified category.
	 */ _getItemsByCategory() {
        const emojiCategory = this.emojiCategories.find((item)=>item.title === this.categoryName);
        const { items } = emojiCategory;
        return {
            matchingItems: items,
            allItems: items
        };
    }
    /**
	 * Updates the grid by removing the existing items and insert the new ones.
	 *
	 * @param items An array of items to insert.
	 */ _updateGrid(items) {
        // Clean-up.
        [
            ...this.tiles
        ].forEach((item)=>{
            this.focusTracker.remove(item);
            this.tiles.remove(item);
        });
        items // Create tiles from matching results.
        .map((item)=>{
            const emoji = item.skins[this.skinTone] || item.skins.default;
            return this.cachedTiles.get(emoji) || this._createTile(emoji, item.annotation);
        }) // Insert new elements.
        .forEach((item)=>{
            this.tiles.add(item);
            this.focusTracker.add(item);
        });
    }
    /**
	 * Creates a new tile for the grid. Created tile is added to the {@link #cachedTiles} collection for further usage, if needed.
	 *
	 * @param emoji The emoji itself.
	 * @param name The name of the emoji (e.g. "Smiling Face with Smiling Eyes").
	 */ _createTile(emoji, name) {
        const tile = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"](this.locale);
        tile.viewUid = emoji;
        tile.extendTemplate({
            attributes: {
                class: [
                    'ck-emoji__tile'
                ]
            }
        });
        tile.set({
            label: emoji,
            tooltip: name,
            withText: true,
            ariaLabel: name,
            // To improve accessibility, disconnect a button and its label connection so that screen
            // readers can read the `[aria-label]` attribute directly from the more descriptive button.
            ariaLabelledBy: undefined
        });
        tile.on('execute', ()=>{
            this.fire('execute', {
                name,
                emoji
            });
        });
        this.cachedTiles.add(tile);
        return tile;
    }
}
/**
 * A class representing the navigation part of the emoji UI.
 * It is responsible allowing the user to select a particular emoji category.
 */ class EmojiCategoriesView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * Tracks information about the DOM focus in the grid.
	 */ focusTracker;
    /**
	 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
	 */ keystrokes;
    /**
	 * Helps cycling over focusable children in the input view.
	 */ focusCycler;
    /**
	 * A collection of the categories buttons.
	 */ buttonViews;
    /**
	 * @inheritDoc
	 */ constructor(locale, { emojiCategories, categoryName }){
        super(locale);
        this.buttonViews = this.createCollection(emojiCategories.map((emojiCategory)=>this._createCategoryButton(emojiCategory)));
        this.focusTracker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusTracker"]();
        this.keystrokes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeystrokeHandler"]();
        this.focusCycler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusCycler"]({
            focusables: this.buttonViews,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
                focusPrevious: 'arrowleft',
                focusNext: 'arrowright'
            }
        });
        this.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-emoji__categories-list'
                ],
                role: 'tablist'
            },
            children: this.buttonViews
        });
        this.on('change:categoryName', (event, name, newValue, oldValue)=>{
            const oldCategoryButton = this.buttonViews.find((button)=>button.tooltip === oldValue);
            if (oldCategoryButton) {
                oldCategoryButton.isOn = false;
            }
            const newCategoryButton = this.buttonViews.find((button)=>button.tooltip === newValue);
            newCategoryButton.isOn = true;
        });
        this.set('categoryName', categoryName);
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        this.buttonViews.forEach((buttonView)=>{
            this.focusTracker.add(buttonView);
        });
        this.keystrokes.listenTo(this.element);
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
        this.buttonViews.destroy();
    }
    /**
	 * @inheritDoc
	 */ focus() {
        this.buttonViews.first.focus();
    }
    /**
	 * Marks all categories buttons as enabled (clickable).
	 */ enableCategories() {
        this.buttonViews.forEach((buttonView)=>{
            buttonView.isEnabled = true;
        });
    }
    /**
	 * Marks all categories buttons as disabled (non-clickable).
	 */ disableCategories() {
        this.buttonViews.forEach((buttonView)=>{
            buttonView.set({
                class: '',
                isEnabled: false,
                isOn: false
            });
        });
    }
    /**
	 * Creates a button representing a category item.
	 */ _createCategoryButton(emojiCategory) {
        const buttonView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"]();
        const bind = buttonView.bindTemplate;
        // A `[role="tab"]` element requires also the `[aria-selected]` attribute with its state.
        buttonView.extendTemplate({
            attributes: {
                'aria-selected': bind.to('isOn', (value)=>value.toString()),
                class: [
                    'ck-emoji__category-item'
                ]
            }
        });
        buttonView.set({
            ariaLabel: emojiCategory.title,
            label: emojiCategory.icon,
            role: 'tab',
            tooltip: emojiCategory.title,
            withText: true,
            // To improve accessibility, disconnect a button and its label connection so that screen
            // readers can read the `[aria-label]` attribute directly from the more descriptive button.
            ariaLabelledBy: undefined
        });
        buttonView.on('execute', ()=>{
            this.categoryName = emojiCategory.title;
        });
        buttonView.on('change:isEnabled', ()=>{
            if (buttonView.isEnabled && buttonView.tooltip === this.categoryName) {
                buttonView.isOn = true;
            }
        });
        return buttonView;
    }
}
/**
 * A view responsible for providing an input element that allows filtering emoji by the provided query.
 */ class EmojiSearchView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * The find in text input view that stores the searched string.
	 */ inputView;
    /**
	 * An instance of the `EmojiGridView`.
	 */ gridView;
    /**
	 * @inheritDoc
	 */ constructor(locale, { gridView, resultsView }){
        super(locale);
        this.gridView = gridView;
        const t = locale.t;
        this.inputView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SearchTextView"](this.locale, {
            queryView: {
                label: t('Find an emoji (min. 2 characters)'),
                creator: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLabeledInputText"]
            },
            filteredView: this.gridView,
            infoView: {
                instance: resultsView
            }
        });
        this.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-search'
                ],
                tabindex: '-1'
            },
            children: [
                this.inputView.queryView
            ]
        });
        // Pass through the `search` event to handle it by a parent view.
        this.inputView.delegate('search').to(this);
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this.inputView.destroy();
    }
    /**
	 * Searches the {@link #gridView} for the given query.
	 *
	 * @param query The search query string.
	 */ search(query) {
        const regExp = query ? new RegExp((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$escapeRegExp$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__escapeRegExp$3e$__["escapeRegExp"])(query), 'ig') : null;
        const filteringResults = this.gridView.filter(regExp);
        this.inputView.fire('search', {
            query,
            ...filteringResults
        });
    }
    /**
	 * Allows defining the default value in the search text field.
	 *
	 * @param value The new value.
	 */ setInputValue(value) {
        if (!value) {
            this.inputView.queryView.fieldView.reset();
        } else {
            this.inputView.queryView.fieldView.value = value;
        }
    }
    /**
	 * Returns an input provided by a user in the search text field.
	 */ getInputValue() {
        return this.inputView.queryView.fieldView.element.value;
    }
    /**
	 * @inheritDoc
	 */ focus() {
        this.inputView.focus();
    }
}
/**
 * A view responsible for selecting a skin tone for an emoji.
 */ class EmojiToneView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * A dropdown element for selecting an active skin tone.
	 */ dropdownView;
    /**
	 * An array of available skin tones.
	 */ _skinTones;
    /**
	 * @inheritDoc
	 */ constructor(locale, { skinTone, skinTones }){
        super(locale);
        this.set('skinTone', skinTone);
        this._skinTones = skinTones;
        const t = locale.t;
        const accessibleLabel = t('Select skin tone');
        const dropdownView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDropdown"])(locale);
        const itemDefinitions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"]();
        for (const { id, icon, tooltip } of this._skinTones){
            const def = {
                type: 'button',
                model: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewModel"]({
                    value: id,
                    label: icon,
                    ariaLabel: tooltip,
                    tooltip,
                    tooltipPosition: 'e',
                    role: 'menuitemradio',
                    withText: true,
                    // To improve accessibility, disconnect a button and its label connection so that screen
                    // readers can read the `[aria-label]` attribute directly from the more descriptive button.
                    ariaLabelledBy: undefined
                })
            };
            def.model.bind('isOn').to(this, 'skinTone', (value)=>value === id);
            itemDefinitions.add(def);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addListToDropdown"])(dropdownView, itemDefinitions, {
            ariaLabel: accessibleLabel,
            role: 'menu'
        });
        dropdownView.buttonView.set({
            label: this._getSkinTone().icon,
            ariaLabel: accessibleLabel,
            ariaLabelledBy: undefined,
            isOn: false,
            withText: true,
            tooltip: accessibleLabel
        });
        this.dropdownView = dropdownView;
        // Execute command when an item from the dropdown is selected.
        this.listenTo(dropdownView, 'execute', (evt)=>{
            this.skinTone = evt.source.value;
        });
        dropdownView.buttonView.bind('label').to(this, 'skinTone', ()=>{
            return this._getSkinTone().icon;
        });
        dropdownView.buttonView.bind('ariaLabel').to(this, 'skinTone', ()=>{
            // Render a current state, but also what the dropdown does.
            return `${this._getSkinTone().tooltip}, ${accessibleLabel}`;
        });
        this.setTemplate({
            tag: 'div',
            attributes: {
                class: [
                    'ck',
                    'ck-emoji__skin-tone'
                ]
            },
            children: [
                dropdownView
            ]
        });
    }
    /**
	 * @inheritDoc
	 */ focus() {
        this.dropdownView.buttonView.focus();
    }
    /**
	 * Helper method for receiving an object describing the active skin tone.
	 */ _getSkinTone() {
        return this._skinTones.find((tone)=>tone.id === this.skinTone);
    }
}
/**
 * A view that glues pieces of the emoji panel together.
 */ class EmojiPickerView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
	 * A collection of the focusable children of the view.
	 */ items;
    /**
	 * Tracks information about the DOM focus in the view.
	 */ focusTracker;
    /**
	 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
	 */ keystrokes;
    /**
	 * Helps cycling over focusable {@link #items} in the view.
	 */ focusCycler;
    /**
	 * An instance of the `EmojiSearchView`.
	 */ searchView;
    /**
	 * An instance of the `EmojiToneView`.
	 */ toneView;
    /**
	 * An instance of the `EmojiCategoriesView`.
	 */ categoriesView;
    /**
	 * An instance of the `EmojiGridView`.
	 */ gridView;
    /**
	 * An instance of the `EmojiGridView`.
	 */ infoView;
    /**
	 * @inheritDoc
	 */ constructor(locale, { emojiCategories, getEmojiByQuery, skinTone, skinTones }){
        super(locale);
        const categoryName = emojiCategories[0].title;
        this.gridView = new EmojiGridView(locale, {
            categoryName,
            emojiCategories,
            getEmojiByQuery,
            skinTone
        });
        this.infoView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SearchInfoView"]();
        this.searchView = new EmojiSearchView(locale, {
            gridView: this.gridView,
            resultsView: this.infoView
        });
        this.categoriesView = new EmojiCategoriesView(locale, {
            emojiCategories,
            categoryName
        });
        this.toneView = new EmojiToneView(locale, {
            skinTone,
            skinTones
        });
        this.items = this.createCollection([
            this.searchView,
            this.toneView,
            this.categoriesView,
            this.gridView,
            this.infoView
        ]);
        this.focusTracker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusTracker"]();
        this.keystrokes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KeystrokeHandler"]();
        this.focusCycler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusCycler"]({
            focusables: this.items,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
                focusPrevious: 'shift + tab',
                focusNext: 'tab'
            }
        });
        this.setTemplate({
            tag: 'div',
            children: [
                {
                    tag: 'div',
                    children: [
                        this.searchView,
                        this.toneView
                    ],
                    attributes: {
                        class: [
                            'ck',
                            'ck-emoji__search'
                        ]
                    }
                },
                this.categoriesView,
                this.gridView,
                {
                    tag: 'div',
                    children: [
                        this.infoView
                    ],
                    attributes: {
                        class: [
                            'ck',
                            'ck-search__results'
                        ]
                    }
                }
            ],
            attributes: {
                tabindex: '-1',
                class: [
                    'ck',
                    'ck-emoji',
                    'ck-search'
                ]
            }
        });
        this._setupEventListeners();
    }
    /**
	 * @inheritDoc
	 */ render() {
        super.render();
        this.focusTracker.add(this.searchView.element);
        this.focusTracker.add(this.toneView.element);
        this.focusTracker.add(this.categoriesView.element);
        this.focusTracker.add(this.gridView.element);
        this.focusTracker.add(this.infoView.element);
        // Start listening for the keystrokes coming from #element.
        this.keystrokes.listenTo(this.element);
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
    }
    /**
	 * Focuses the search input.
	 */ focus() {
        this.searchView.focus();
    }
    /**
	 * Initializes interactions between sub-views.
	 */ _setupEventListeners() {
        const t = this.locale.t;
        // Disable the category switcher when filtering by a query.
        this.searchView.on('search', (evt, data)=>{
            if (data.query) {
                this.categoriesView.disableCategories();
            } else {
                this.categoriesView.enableCategories();
            }
        });
        // Show a user-friendly message depending on the search query.
        this.searchView.on('search', (evt, data)=>{
            if (data.query.length === 1) {
                this.infoView.set({
                    primaryText: t('Keep on typing to see the emoji.'),
                    secondaryText: t('The query must contain at least two characters.'),
                    isVisible: true
                });
            } else if (!data.resultsCount) {
                this.infoView.set({
                    primaryText: t('No emojis were found matching "%0".', data.query),
                    secondaryText: t('Please try a different phrase or check the spelling.'),
                    isVisible: true
                });
            } else {
                this.infoView.set({
                    isVisible: false
                });
            }
        });
        // Emit an update event to react to balloon dimensions changes.
        this.searchView.on('search', ()=>{
            this.fire('update');
            this.gridView.element.scrollTo(0, 0);
        });
        // Update the grid of emojis when the selected category is changed.
        this.categoriesView.on('change:categoryName', (ev, args, categoryName)=>{
            this.gridView.categoryName = categoryName;
            this.searchView.search('');
        });
        // Update the grid of emojis when the selected skin tone is changed.
        // In such a case, the displayed emoji should use an updated skin tone value.
        this.toneView.on('change:skinTone', (evt, propertyName, newValue)=>{
            this.gridView.skinTone = newValue;
            this.searchView.search(this.searchView.getInputValue());
        });
    }
}
const VISUAL_SELECTION_MARKER_NAME = 'emoji-picker';
/**
 * The emoji picker plugin.
 *
 * Introduces the `'emoji'` dropdown.
 */ class EmojiPicker extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            EmojiRepository,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ContextualBalloon"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Dialog"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$typing$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Typing"]
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'EmojiPicker';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ async init() {
        const editor = this.editor;
        this.balloonPlugin = editor.plugins.get('ContextualBalloon');
        this.emojiRepositoryPlugin = editor.plugins.get('EmojiRepository');
        // Skip registering a button in the toolbar and list item in the menu bar if the emoji repository is not ready.
        if (!await this.emojiRepositoryPlugin.isReady()) {
            return;
        }
        const command = new EmojiCommand(editor);
        editor.commands.add('emoji', command);
        editor.ui.componentFactory.add('emoji', ()=>{
            const button = this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ButtonView"], command);
            button.set({
                tooltip: true
            });
            return button;
        });
        editor.ui.componentFactory.add('menuBar:emoji', ()=>{
            return this._createButton(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuBarMenuListItemButtonView"], command);
        });
        this._setupConversion();
    }
    /**
	 * @inheritDoc
	 */ destroy() {
        super.destroy();
        if (this.emojiPickerView) {
            this.emojiPickerView.destroy();
        }
    }
    /**
	 * Represents an active skin tone. Its value depends on the emoji UI plugin.
	 *
	 * Before opening the UI for the first time, the returned value is read from the editor configuration.
	 * Otherwise, it reflects the user's intention.
	 */ get skinTone() {
        if (!this.emojiPickerView) {
            return this.editor.config.get('emoji.skinTone');
        }
        return this.emojiPickerView.gridView.skinTone;
    }
    /**
	 * Displays the balloon with the emoji picker.
	 *
	 * @param [searchValue=''] A default query used to filer the grid when opening the UI.
	 */ showUI(searchValue = '') {
        // Show visual selection on a text when the contextual balloon is displayed.
        // See #17654.
        this._showFakeVisualSelection();
        if (!this.emojiPickerView) {
            this.emojiPickerView = this._createEmojiPickerView();
        }
        if (searchValue) {
            this.emojiPickerView.searchView.setInputValue(searchValue);
        }
        this.emojiPickerView.searchView.search(searchValue);
        if (!this.balloonPlugin.hasView(this.emojiPickerView)) {
            this.balloonPlugin.add({
                view: this.emojiPickerView,
                position: this._getBalloonPositionData()
            });
        }
        this.emojiPickerView.focus();
    }
    /**
	 * Creates a button for toolbar and menu bar that will show the emoji dialog.
	 */ _createButton(ViewClass, command) {
        const buttonView = new ViewClass(this.editor.locale);
        const t = this.editor.locale.t;
        buttonView.bind('isEnabled').to(command, 'isEnabled');
        buttonView.set({
            label: t('Emoji'),
            icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["icons"].emoji,
            isToggleable: true
        });
        buttonView.on('execute', ()=>{
            this.showUI();
        });
        return buttonView;
    }
    /**
	 * Creates an instance of the `EmojiPickerView` class that represents an emoji balloon.
	 */ _createEmojiPickerView() {
        const emojiPickerView = new EmojiPickerView(this.editor.locale, {
            emojiCategories: this.emojiRepositoryPlugin.getEmojiCategories(),
            skinTone: this.editor.config.get('emoji.skinTone'),
            skinTones: this.emojiRepositoryPlugin.getSkinTones(),
            getEmojiByQuery: (query)=>{
                return this.emojiRepositoryPlugin.getEmojiByQuery(query);
            }
        });
        // Insert an emoji on a tile click.
        this.listenTo(emojiPickerView.gridView, 'execute', (evt, data)=>{
            const editor = this.editor;
            const textToInsert = data.emoji;
            this._hideUI();
            editor.execute('insertText', {
                text: textToInsert
            });
        });
        // Update the balloon position when layout is changed.
        this.listenTo(emojiPickerView, 'update', ()=>{
            if (this.balloonPlugin.visibleView === emojiPickerView) {
                this.balloonPlugin.updatePosition();
            }
        });
        // Close the panel on `Esc` key press when the **actions have focus**.
        emojiPickerView.keystrokes.set('Esc', (data, cancel)=>{
            this._hideUI();
            cancel();
        });
        // Close the dialog when clicking outside of it.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$ui$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clickOutsideHandler"])({
            emitter: emojiPickerView,
            contextElements: [
                this.balloonPlugin.view.element
            ],
            callback: ()=>this._hideUI(),
            activator: ()=>this.balloonPlugin.visibleView === emojiPickerView
        });
        return emojiPickerView;
    }
    /**
	 * Hides the balloon with the emoji picker.
	 */ _hideUI() {
        this.balloonPlugin.remove(this.emojiPickerView);
        this.emojiPickerView.searchView.setInputValue('');
        this.editor.editing.view.focus();
        this._hideFakeVisualSelection();
    }
    /**
	 * Registers converters.
	 */ _setupConversion() {
        const editor = this.editor;
        // Renders a fake visual selection marker on an expanded selection.
        editor.conversion.for('editingDowncast').markerToHighlight({
            model: VISUAL_SELECTION_MARKER_NAME,
            view: {
                classes: [
                    'ck-fake-emoji-selection'
                ]
            }
        });
        // Renders a fake visual selection marker on a collapsed selection.
        editor.conversion.for('editingDowncast').markerToElement({
            model: VISUAL_SELECTION_MARKER_NAME,
            view: (data, { writer })=>{
                if (!data.markerRange.isCollapsed) {
                    return null;
                }
                const markerElement = writer.createUIElement('span');
                writer.addClass([
                    'ck-fake-emoji-selection',
                    'ck-fake-emoji-selection_collapsed'
                ], markerElement);
                return markerElement;
            }
        });
    }
    /**
	 * Returns positioning options for the {@link #balloonPlugin}. They control the way the balloon is attached
	 * to the target element or selection.
	 */ _getBalloonPositionData() {
        const view = this.editor.editing.view;
        const viewDocument = view.document;
        // Set a target position by converting view selection range to DOM.
        const target = ()=>view.domConverter.viewRangeToDom(viewDocument.selection.getFirstRange());
        return {
            target
        };
    }
    /**
	 * Displays a fake visual selection when the contextual balloon is displayed.
	 *
	 * This adds an 'emoji-picker' marker into the document that is rendered as a highlight on selected text fragment.
	 */ _showFakeVisualSelection() {
        const model = this.editor.model;
        model.change((writer)=>{
            const range = model.document.selection.getFirstRange();
            if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
                writer.updateMarker(VISUAL_SELECTION_MARKER_NAME, {
                    range
                });
            } else {
                if (range.start.isAtEnd) {
                    const startPosition = range.start.getLastMatchingPosition(({ item })=>!model.schema.isContent(item), {
                        boundaries: range
                    });
                    writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
                        usingOperation: false,
                        affectsData: false,
                        range: writer.createRange(startPosition, range.end)
                    });
                } else {
                    writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
                        usingOperation: false,
                        affectsData: false,
                        range
                    });
                }
            }
        });
    }
    /**
	 * Hides the fake visual selection.
	 */ _hideFakeVisualSelection() {
        const model = this.editor.model;
        if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
            model.change((writer)=>{
                writer.removeMarker(VISUAL_SELECTION_MARKER_NAME);
            });
        }
    }
}
/**
 * The emoji plugin.
 *
 * This is a "glue" plugin which loads the following plugins:
 *
 * * {@link module:emoji/emojimention~EmojiMention},
 * * {@link module:emoji/emojipicker~EmojiPicker},
 */ class Emoji extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            EmojiMention,
            EmojiPicker
        ];
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Emoji';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ckeditor/ckeditor5-markdown-gfm/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ __turbopack_esm__({
    "GFMDataProcessor": (()=>GFMDataProcessor),
    "Markdown": (()=>Markdown),
    "MarkdownToHtml": (()=>MarkdownToHtml),
    "PasteFromMarkdownExperimental": (()=>PasteFromMarkdownExperimental)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-engine/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$marked$2f$lib$2f$marked$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/marked/lib/marked.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$turndown$2f$lib$2f$turndown$2e$browser$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/turndown/lib/turndown.browser.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$turndown$2d$plugin$2d$gfm$2f$lib$2f$turndown$2d$plugin$2d$gfm$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/turndown-plugin-gfm/lib/turndown-plugin-gfm.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$clipboard$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@ckeditor/ckeditor5-clipboard/dist/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
/**
 * This is a helper class used by the {@link module:markdown-gfm/markdown Markdown feature} to convert Markdown to HTML.
 */ class MarkdownToHtml {
    _parser;
    _options = {
        gfm: true,
        breaks: true,
        tables: true,
        xhtml: true,
        headerIds: false
    };
    constructor(){
        // Overrides.
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$marked$2f$lib$2f$marked$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["marked"].use({
            tokenizer: {
                // Disable the autolink rule in the lexer.
                autolink: ()=>null,
                url: ()=>null
            },
            renderer: {
                checkbox (...args) {
                    // Remove bogus space after <input type="checkbox"> because it would be preserved
                    // by DomConverter as it's next to an inline object.
                    return Object.getPrototypeOf(this).checkbox.call(this, ...args).trimRight();
                },
                code (...args) {
                    // Since marked v1.2.8, every <code> gets a trailing "\n" whether it originally
                    // ended with one or not (see https://github.com/markedjs/marked/issues/1884 to learn why).
                    // This results in a redundant soft break in the model when loaded into the editor, which
                    // is best prevented at this stage. See https://github.com/ckeditor/ckeditor5/issues/11124.
                    return Object.getPrototypeOf(this).code.call(this, ...args).replace('\n</code>', '</code>');
                }
            }
        });
        this._parser = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$marked$2f$lib$2f$marked$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["marked"];
    }
    parse(markdown) {
        return this._parser.parse(markdown, this._options);
    }
}
const autolinkRegex = /* #__PURE__ */ new RegExp(/\b(?:(?:https?|ftp):\/\/|www\.)/.source + // Domain name.
/(?![-_])(?:[-_a-z0-9\u00a1-\uffff]{1,63}\.)+(?:[a-z\u00a1-\uffff]{2,63})/.source + // The rest.
/(?:[^\s<>]*)/.source, 'gi');
class UpdatedTurndown extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$turndown$2f$lib$2f$turndown$2e$browser$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    escape(string) {
        const originalEscape = super.escape;
        function escape(string) {
            string = originalEscape(string);
            // Escape "<".
            string = string.replace(/</g, '\\<');
            return string;
        }
        // Urls should not be escaped. Our strategy is using a regex to find them and escape everything
        // which is out of the matches parts.
        let escaped = '';
        let lastLinkEnd = 0;
        for (const match of this._matchAutolink(string)){
            const index = match.index;
            // Append the substring between the last match and the current one (if anything).
            if (index > lastLinkEnd) {
                escaped += escape(string.substring(lastLinkEnd, index));
            }
            const matchedURL = match[0];
            escaped += matchedURL;
            lastLinkEnd = index + matchedURL.length;
        }
        // Add text after the last link or at the string start if no matches.
        if (lastLinkEnd < string.length) {
            escaped += escape(string.substring(lastLinkEnd, string.length));
        }
        return escaped;
    }
    /**
	 * Trimming end of link.
	 * https://github.github.com/gfm/#autolinks-extension-
	 */ *_matchAutolink(string) {
        for (const match of string.matchAll(autolinkRegex)){
            const matched = match[0];
            const length = this._autolinkFindEnd(matched);
            yield Object.assign([
                matched.substring(0, length)
            ], {
                index: match.index
            });
        // We could adjust regex.lastIndex but it's not needed because what we skipped is for sure not a valid URL.
        }
    }
    /**
	 * Returns the new length of the link (after it would trim trailing characters).
	 */ _autolinkFindEnd(string) {
        let length = string.length;
        while(length > 0){
            const char = string[length - 1];
            if ('?!.,:*_~\'"'.includes(char)) {
                length--;
            } else if (char == ')') {
                let openBrackets = 0;
                for(let i = 0; i < length; i++){
                    if (string[i] == '(') {
                        openBrackets++;
                    } else if (string[i] == ')') {
                        openBrackets--;
                    }
                }
                // If there is fewer opening brackets then closing ones we should remove a closing bracket.
                if (openBrackets < 0) {
                    length--;
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        return length;
    }
}
/**
 * This is a helper class used by the {@link module:markdown-gfm/markdown Markdown feature} to convert HTML to Markdown.
 */ class HtmlToMarkdown {
    _parser;
    constructor(){
        this._parser = this._createParser();
    }
    parse(html) {
        return this._parser.turndown(html);
    }
    keep(elements) {
        this._parser.keep(elements);
    }
    _createParser() {
        const parser = new UpdatedTurndown({
            codeBlockStyle: 'fenced',
            hr: '---',
            headingStyle: 'atx'
        });
        parser.use([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$turndown$2d$plugin$2d$gfm$2f$lib$2f$turndown$2d$plugin$2d$gfm$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfm"],
            this._todoList
        ]);
        return parser;
    }
    // This is a copy of the original taskListItems rule from turndown-plugin-gfm, with minor changes.
    _todoList(turndown) {
        turndown.addRule('taskListItems', {
            filter (node) {
                return node.type === 'checkbox' && // Changes here as CKEditor outputs a deeper structure.
                (node.parentNode.nodeName === 'LI' || node.parentNode.parentNode.nodeName === 'LI');
            },
            replacement (content, node) {
                return (node.checked ? '[x]' : '[ ]') + ' ';
            }
        });
    }
}
/**
 * This data processor implementation uses GitHub Flavored Markdown as input/output data.
 *
 * See the {@glink features/markdown Markdown output} guide to learn more on how to enable it.
 */ class GFMDataProcessor {
    /**
	 * HTML data processor used to process HTML produced by the Markdown-to-HTML converter and the other way.
	 */ _htmlDP;
    /**
	 * Helper for converting Markdown to HTML.
	 */ _markdown2html;
    /**
	 * Helper for converting HTML to Markdown.
	 */ _html2markdown;
    /**
	 * Creates a new instance of the Markdown data processor class.
	 */ constructor(document){
        this._htmlDP = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$engine$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HtmlDataProcessor"](document);
        this._markdown2html = new MarkdownToHtml();
        this._html2markdown = new HtmlToMarkdown();
    }
    /**
	 * Keeps the specified element in the output as HTML. This is useful if the editor contains
	 * features producing HTML that is not a part of the Markdown standard.
	 *
	 * By default, all HTML tags are removed.
	 *
	 * @param element The element name to be kept.
	 */ keepHtml(element) {
        this._html2markdown.keep([
            element
        ]);
    }
    /**
	 * Converts the provided Markdown string to a view tree.
	 *
	 * @param data A Markdown string.
	 * @returns The converted view element.
	 */ toView(data) {
        const html = this._markdown2html.parse(data);
        return this._htmlDP.toView(html);
    }
    /**
	 * Converts the provided {@link module:engine/view/documentfragment~DocumentFragment} to data format &ndash; in this
	 * case to a Markdown string.
	 *
	 * @returns Markdown string.
	 */ toData(viewFragment) {
        const html = this._htmlDP.toData(viewFragment);
        return this._html2markdown.parse(html);
    }
    /**
	 * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
	 * and not processed during the conversion from Markdown to view elements.
	 *
	 * The raw data can be later accessed by a
	 * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
	 *
	 * @param pattern The pattern matching all view elements whose content should
	 * be treated as raw data.
	 */ registerRawContentMatcher(pattern) {
        this._htmlDP.registerRawContentMatcher(pattern);
    }
    /**
	 * This method does not have any effect on the data processor result. It exists for compatibility with the
	 * {@link module:engine/dataprocessor/dataprocessor~DataProcessor `DataProcessor` interface}.
	 */ useFillerType() {}
}
/**
 * The GitHub Flavored Markdown (GFM) plugin.
 *
 * For a detailed overview, check the {@glink features/markdown Markdown feature} guide.
 */ class Markdown extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.data.processor = new GFMDataProcessor(editor.data.viewDocument);
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'Markdown';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
}
const ALLOWED_MARKDOWN_FIRST_LEVEL_TAGS = [
    'SPAN',
    'BR',
    'PRE',
    'CODE'
];
/**
 * The GitHub Flavored Markdown (GFM) paste plugin.
 *
 * For a detailed overview, check the {@glink features/pasting/paste-markdown Paste Markdown feature} guide.
 */ class PasteFromMarkdownExperimental extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"] {
    /**
	 * @internal
	 */ _gfmDataProcessor;
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        this._gfmDataProcessor = new GFMDataProcessor(editor.data.viewDocument);
    }
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'PasteFromMarkdownExperimental';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ckeditor$2f$ckeditor5$2d$clipboard$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClipboardPipeline"]
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const clipboardPipeline = editor.plugins.get('ClipboardPipeline');
        let shiftPressed = false;
        this.listenTo(viewDocument, 'keydown', (evt, data)=>{
            shiftPressed = data.shiftKey;
        });
        this.listenTo(clipboardPipeline, 'inputTransformation', (evt, data)=>{
            if (shiftPressed) {
                return;
            }
            const dataAsTextHtml = data.dataTransfer.getData('text/html');
            if (!dataAsTextHtml) {
                const dataAsTextPlain = data.dataTransfer.getData('text/plain');
                data.content = this._gfmDataProcessor.toView(dataAsTextPlain);
                return;
            }
            const markdownFromHtml = this._parseMarkdownFromHtml(dataAsTextHtml);
            if (markdownFromHtml) {
                data.content = this._gfmDataProcessor.toView(markdownFromHtml);
            }
        });
    }
    /**
	 * Determines if the code copied from a website in the `text/html` type can be parsed as Markdown.
	 * It removes any OS-specific HTML tags, for example, <meta> on macOS and <!--StartFragment--> on Windows.
	 * Then removes a single wrapper HTML tag or wrappers for sibling tags, and if there are no more tags left,
	 * returns the remaining text. Returns null if there are any remaining HTML tags detected.
	 *
	 * @param htmlString Clipboard content in the `text/html` type format.
	 */ _parseMarkdownFromHtml(htmlString) {
        const withoutOsSpecificTags = this._removeOsSpecificTags(htmlString);
        if (!this._containsOnlyAllowedFirstLevelTags(withoutOsSpecificTags)) {
            return null;
        }
        const withoutWrapperTag = this._removeFirstLevelWrapperTagsAndBrs(withoutOsSpecificTags);
        if (this._containsAnyRemainingHtmlTags(withoutWrapperTag)) {
            return null;
        }
        return this._replaceHtmlReservedEntitiesWithCharacters(withoutWrapperTag);
    }
    /**
	 * Removes OS-specific tags.
	 *
	 * @param htmlString Clipboard content in the `text/html` type format.
	 */ _removeOsSpecificTags(htmlString) {
        // Removing the <meta> tag present on Mac.
        const withoutMetaTag = htmlString.replace(/^<meta\b[^>]*>/, '').trim();
        // Removing the <html> tag present on Windows.
        const withoutHtmlTag = withoutMetaTag.replace(/^<html>/, '').replace(/<\/html>$/, '').trim();
        // Removing the <body> tag present on Windows.
        const withoutBodyTag = withoutHtmlTag.replace(/^<body>/, '').replace(/<\/body>$/, '').trim();
        // Removing the <!--StartFragment--> tag present on Windows.
        return withoutBodyTag.replace(/^<!--StartFragment-->/, '').replace(/<!--EndFragment-->$/, '').trim();
    }
    /**
	 * If the input HTML string contains any first-level formatting tags
	 * like <b>, <strong>, or <i>, we should not treat it as Markdown.
	 *
	 * @param htmlString Clipboard content.
	 */ _containsOnlyAllowedFirstLevelTags(htmlString) {
        const parser = new DOMParser();
        const { body: tempElement } = parser.parseFromString(htmlString, 'text/html');
        const tagNames = Array.from(tempElement.children).map((el)=>el.tagName);
        return tagNames.every((el)=>ALLOWED_MARKDOWN_FIRST_LEVEL_TAGS.includes(el));
    }
    /**
	 * Removes multiple HTML wrapper tags from a list of sibling HTML tags.
	 *
	 * @param htmlString Clipboard content without any OS-specific tags.
	 */ _removeFirstLevelWrapperTagsAndBrs(htmlString) {
        const parser = new DOMParser();
        const { body: tempElement } = parser.parseFromString(htmlString, 'text/html');
        const brElements = tempElement.querySelectorAll('br');
        for (const br of brElements){
            br.replaceWith('\n');
        }
        const outerElements = tempElement.querySelectorAll(':scope > *');
        for (const element of outerElements){
            const elementClone = element.cloneNode(true);
            element.replaceWith(...elementClone.childNodes);
        }
        return tempElement.innerHTML;
    }
    /**
	 * Determines if a string contains any HTML tags.
	 */ _containsAnyRemainingHtmlTags(str) {
        return str.includes('<');
    }
    /**
	 * Replaces the reserved HTML entities with the actual characters.
	 *
	 * @param htmlString Clipboard content without any tags.
	 */ _replaceHtmlReservedEntitiesWithCharacters(htmlString) {
        return htmlString.replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/&nbsp;/g, ' ');
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40ckeditor_a79786._.js.map